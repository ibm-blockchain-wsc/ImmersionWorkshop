{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Blockchain Immersion Workshop Welcome! This two-day workshop combines lectures and hands-on labs to teach you the foundamentals of blockchain for business. On Day 1, we focus on blockchain 101, blockchain use cases, and the open source framework called Hyperledger Fabric that powers blockchain for business. On Day 2, you will learn about the IBM-specific offerings that leverage Hyperledger Fabric, and how our unique combination of expertise, governance and operations tooling, and infrastructure capabilities with LinuxONE can help you achieve business results faster and more securely. Agenda Day 1 Blockchain Explained Vehicle Lifecycle Demo Blockchain Use Cases Hyperledger Fabric Lab Lunch / Informal use case discussions Blockchain Explored Part 1 VSCode Lab Day 2 Blockchain Explored Part 2 IBM Blockchain Platform Next Steps Lunch Introduction to IBM Cloud Private and Kubernetes IBM Blockchain Platform for IBM Cloud Private Lab Acknowledgements Latrell Freeman for providing us with the backbone automation scripts Dave Wakeman for providing guidance on using MkDocs to make this Github Pages site Thanks to the following people who helped us test out the labs: Steven Bodie, Kevin Breitenother, Victoria Coates, Jack Sykes, MacKenna Kelleher, Keziah Knopp, Jasmine Burgess Contacts Austin Grice Barry Silliman Garrett Woodworth Jin VanStee","title":"Home"},{"location":"#blockchain-immersion-workshop","text":"Welcome! This two-day workshop combines lectures and hands-on labs to teach you the foundamentals of blockchain for business. On Day 1, we focus on blockchain 101, blockchain use cases, and the open source framework called Hyperledger Fabric that powers blockchain for business. On Day 2, you will learn about the IBM-specific offerings that leverage Hyperledger Fabric, and how our unique combination of expertise, governance and operations tooling, and infrastructure capabilities with LinuxONE can help you achieve business results faster and more securely.","title":"Blockchain Immersion Workshop"},{"location":"#agenda","text":"","title":"Agenda"},{"location":"#day-1","text":"Blockchain Explained Vehicle Lifecycle Demo Blockchain Use Cases Hyperledger Fabric Lab Lunch / Informal use case discussions Blockchain Explored Part 1 VSCode Lab","title":"Day 1"},{"location":"#day-2","text":"Blockchain Explored Part 2 IBM Blockchain Platform Next Steps Lunch Introduction to IBM Cloud Private and Kubernetes IBM Blockchain Platform for IBM Cloud Private Lab","title":"Day 2"},{"location":"#acknowledgements","text":"Latrell Freeman for providing us with the backbone automation scripts Dave Wakeman for providing guidance on using MkDocs to make this Github Pages site Thanks to the following people who helped us test out the labs: Steven Bodie, Kevin Breitenother, Victoria Coates, Jack Sykes, MacKenna Kelleher, Keziah Knopp, Jasmine Burgess","title":"Acknowledgements"},{"location":"#contacts","text":"Austin Grice Barry Silliman Garrett Woodworth Jin VanStee","title":"Contacts"},{"location":"connect-home/","text":"Welcome to Marbles Connect-a-thon with IBM Blockchain Platform for IBM Cloud Private (IBP4ICP) The goal of the lab is to give you hands on experience interacting with IBM Blockchain Platform for IBM Cloud Private (IBP4ICP). You will take on the role of an organization that is part of a larger Hyperledger Fabric blockchain consortium called the Marbles business network. This lab is broken into two parts. In the first part, you will interact with your deployed peer, and enable the Marbles front end application to connect to the marbles chaincode installed on your peer. In the second part, you will go through the process of enabling the Marbles application to deploy inside a Kubernetes cluster. You will be able to transact marbles with the other lab participants who are all acting as their own organizations in the Marbles business network. Note This lab runs on Linux on IBM Z images and connects to an IBM Cloud Private cluster. Both environments run on IBM Z systems in the IBM Washington Systems Center (WSC). In order to connect to this environment, you must be VPN'ed into the WSC network. Open your CISCO AnyConnect client and point to: ssl.wsc.ihost.com . You will be given IDs and passwords at the beginning of the lab. Tip If you find any typos, errors, or just want to provide helpful feedback to make this lab better, please click on the GitHub icon in the lower left corner of this page to create an issue in the repository. Thanks for your feedback!","title":"Introduction"},{"location":"connect-home/#welcome-to-marbles-connect-a-thon-with-ibm-blockchain-platform-for-ibm-cloud-private-ibp4icp","text":"The goal of the lab is to give you hands on experience interacting with IBM Blockchain Platform for IBM Cloud Private (IBP4ICP). You will take on the role of an organization that is part of a larger Hyperledger Fabric blockchain consortium called the Marbles business network. This lab is broken into two parts. In the first part, you will interact with your deployed peer, and enable the Marbles front end application to connect to the marbles chaincode installed on your peer. In the second part, you will go through the process of enabling the Marbles application to deploy inside a Kubernetes cluster. You will be able to transact marbles with the other lab participants who are all acting as their own organizations in the Marbles business network. Note This lab runs on Linux on IBM Z images and connects to an IBM Cloud Private cluster. Both environments run on IBM Z systems in the IBM Washington Systems Center (WSC). In order to connect to this environment, you must be VPN'ed into the WSC network. Open your CISCO AnyConnect client and point to: ssl.wsc.ihost.com . You will be given IDs and passwords at the beginning of the lab. Tip If you find any typos, errors, or just want to provide helpful feedback to make this lab better, please click on the GitHub icon in the lower left corner of this page to create an issue in the repository. Thanks for your feedback!","title":"Welcome to Marbles Connect-a-thon with IBM Blockchain Platform for IBM Cloud Private (IBP4ICP)"},{"location":"connect-part1/","text":"Overview The goal of this part of the lab is to go through the process of using your peer with the fabric command line interface (cli) tools and connecting it with marbles. In this part of the lab, you will: Connect to your peer Log in to our Kubernetes cluster Take a look at your peer setup environment variables Check the chaincode on the peer and the channel Submit transactions with your peer to create yourself as a marbles owner with a marble Configure the marbles application to connect to your peer Connect the marbles application to your peer Connect to your peer An IBM Blockchain Platform network has been set up with an organization for each member of the lab in our IBM Cloud Private Kubernetes Cluster. The necessary certificate material and environment variables to operate your peer as well as the marbles project have been packaged into a container for your use during the lab. This container is labeled based on your team. Please open a terminal window on your computer and set your given ip address and ssh into that z machine IP_ADDRESS=givenip ssh bcuser@$IP_ADDRESS Sample Output: Welcome to Ubuntu 16.04.5 LTS (GNU/Linux 4.4.0-139-generic s390x) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantage Last login: Mon Jan 21 21:43:38 2019 from 192.168.22.64 bcuser@ubuntu16045:~ Then, add the cluster to your /etc/hosts and add the self-signed certificate to your ca-certificates echo 192.168.22.81 wsc-ibp-icp-cluster.icp | sudo tee --append /etc/hosts sudo mkdir /usr/local/share/ca-certificates/wsc-ibp-icp-cluster.icp sudo openssl s_client -showcerts -servername wsc-ibp-icp-cluster.icp -connect wsc-ibp-icp-cluster.icp:8443 /dev/null 2 /dev/null | sudo openssl x509 | sudo tee /usr/local/share/ca-certificates/wsc-ibp-icp-cluster.icp/ca.crt sudo update-ca-certificates Sample Output: 192.168.22.81 wsc-ibp-icp-cluster.icp -----BEGIN CERTIFICATE----- MIIFfjCCA2agAwIBAgIQbJlENedx5PvDbGD7XLDnITANBgkqhkiG9w0BAQsFADBj MQswCQYDVQQGEwJVUzERMA8GA1UECAwITmV3IFlvcmsxDzANBgNVBAcMBkFybW9u azEaMBgGA1UECgwRSUJNIENsb3VkIFByaXZhdGUxFDASBgNVBAMMC3d3dy5pYm0u Y29tMCAXDTE4MTIxMjE5NTQ1MVoYDzIxMTgxMTE4MTk1NDUxWjBgMQswCQYDVQQG EwJDTjEQMA4GA1UECAwHU2hhYW54aTEOMAwGA1UEBwwFWGknYW4xGjAYBgNVBAoM EUlCTSBDbG91ZCBQcml2YXRlMRMwEQYDVQQDDAppY3Atcm91dGVyMIIBIjANBgkq hkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArsBisMJEyMGHZ+93mcFsXX0AQc+QXSVW o53f3JEd2Kn+tZLx57vOzRWmMop7B1pSe06c1GwFKofOWSTgHCHv8DO8+h9TIm3x +9IUaLx65mxrTMToUjIxjNyt2JjElHJskxrbpwJsofG59gxhGal8ed89SveXYIL/ PkXvkm5jsoPaRFjgQq0KJoy9UO26aD/FMJu9HzV+7P6Tu8Q+OJHgWSvIgKfX9vOg qyMxv8vGYEGh4jLgQFRMMfXdH01y2diZ259771wHjsTdMRUnxRC36RTDgIXp+0CR 143p1+dmucYD5G45rOwzPuDi67VNho8mtXs5ohTQfovj4FdcDVtFgQIDAQABo4IB LTCCASkwCQYDVR0TBAIwADAdBgNVHQ4EFgQUIMoa55D0BPmJ5FYOEiIa6mw+qtYw gZUGA1UdIwSBjTCBioAUZ9zE9CrhJ2Lm/tLiDLDK5H3asjqhZ6RlMGMxCzAJBgNV BAYTAlVTMREwDwYDVQQIDAhOZXcgWW9yazEPMA0GA1UEBwwGQXJtb25rMRowGAYD VQQKDBFJQk0gQ2xvdWQgUHJpdmF0ZTEUMBIGA1UEAwwLd3d3LmlibS5jb22CCQCV Y/GaGOxNzTAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwCwYDVR0PBAQD AgWgMDkGA1UdEQQyMDCHBH8AAAGCCWxvY2FsaG9zdIcEwKgWUYIXd3NjLWlicC1p Y3AtY2x1c3Rlci5pY3AwDQYJKoZIhvcNAQELBQADggIBABCkUfS8TTO2sPJlJjAn ZiatcrliKZ2KJqdNNouF68E+xHfthfXxhl93TP5oUEw7lFN8yRb+z0o16wZksliw h8FpunHZAuQ+M2qI3afIiRU2H58drGHkBmbZwoMYAQaFrU+A9VEzgibtjBHCkL4p g+3kzQySCJq+A9lmVq/gwrd3cqfPxsFckqq1eGvP8BfcwxvkUIPnOp/Vh9f2jgK7 UNfmPd4hZSzTr2jOfdBAGaltc4C+MAougCAppz7cVQXvb9A2b7ffF3JmYbr626Bk Pp7c0rZAzLRsoZy8ngT9zS+9CucY8MolpPDQmBL48asaMYCRgTx6wAgD6bDzJnpt F0c+FFf7k4782vJELs4gwXkkWRVmaHBlHn4yfYObsiS23snhu2Fvuu2bBWmFMXEr PCK9d1JO1czb672fd18aOj6pmNLZMiIfwIxOxkDpASa4urOhA4sV/61cTpxCSuGs MFhrLN9rKvPlQCh+z/gLPvcf/DVuKoRO+JIVLKl7oSp4GQY7HjdpzggUvCxayp3J EUe4eqOnN50oogTFw8FA4/mNrMzt4wXfk/1yPgWS9ey0EBuFg8fTi2GjLuR00Xsb pjbmU0n0RUpzWdZBHZwb2SpvA6D5M7Ii+aFM0eH5YK5gCU9U9x3hI1MjAtVsINsF cTiYtc/9hu704vR7CQ3uFvOk -----END CERTIFICATE----- Updating certificates in /etc/ssl/certs... 1 added, 0 removed; done. Running hooks in /etc/ca-certificates/update.d... done. Take particular note that 1 certificate was added and 0 removed in your output like in the sample output above. Next, set your team name and login to the private docker repository TEAM=teamxx credential=p@ssw0rd echo $credential | docker login wsc-ibp-icp-cluster.icp:8500 -u $TEAM --password-stdin Sample Output: Login Succeeded Now, start your unique image which will return a command prompt: docker run --rm -it -v /var/run/docker.sock:/var/run/docker.sock --name $TEAM -p 3000:3001 wsc-ibp-icp-cluster.icp:8500/lab-test/connectathon-s390x-$TEAM:1.0 bash This command is using Docker to run your team's container in an interactive bash shell and connect it to your machine's docker socket so you can create sibling containers from your container image. Additionally, you are giving it the name of your team and forwarding traffic on port 3000 of the host to port 3001 on your container to access your marbles application during the lab. Login to our Kubernetes cluster Run the following command to connect to the running IBM Cloud Private Kubernetes cluster. cloudctl login -a https://192.168.22.81:8443 -u $team -p $credential -n lab-test Sample Output: Targeted account wsc-ibp-icp-cluster Account (id-wsc-ibp-icp-cluster-account) Targeted namespace lab-test Configuring kubectl ... Property clusters.wsc-ibp-icp-cluster unset. Property users.wsc-ibp-icp-cluster-user unset. Property contexts.wsc-ibp-icp-cluster-context unset. Cluster wsc-ibp-icp-cluster set. User wsc-ibp-icp-cluster-user set. Context wsc-ibp-icp-cluster-context created. Switched to context wsc-ibp-icp-cluster-context . OK Configuring helm: /root/.helm OK Take a look at your peer setup environment variables In order to operate your peer a number of environment variables need to be set. Let's take a look at some of the environment variables set for the Hyperledger Fabric cli to work with your peer: env | grep CORE Sample Output: CORE_PEER_LOCALMSPID=org0 CORE_PEER_TLS_ENABLED=true CORE_PEER_MSPCONFIGPATH=/home/org0/admin CORE_PEER_TLS_ROOTCERT_FILE=/home/org0/peertls.pem CORE_PEER_ADDRESS=192.168.22.81:30035 CORE_PEER_LOCALMSPID=org0 defines the local MSP or Membership Services Provider of the peer which contains the identifying information (i.e., certs and keys) for the peer as well as the certificates of trusted Certificate Authorities which are authorized to issue identities on behalf of the organization. (In this example org0 is the MSPID, yours will correspond with your team) CORE_PEER_TLS_ENABLED=true is used to enable transport layer security (TLS) communication. CORE_PEER_MSPCONFIGPATH points to the MSP material you are using to operate the peer CORE_PEER_TLS_ROOTCERT_FILE is the root TLS certificate for the peer which your system needs to trust to have a TLS connection with the peer. CORE_PEER_ADDRESS is the peer's IP address used to connect with the peer. Check the chaincode on the peer and the channel In order to check which chaincode is installed on your peer run: peer chaincode list --installed Sample Output: Get installed chaincodes on peer: Name: marbles, Version: 1.0, Path: marbles, Id: 4421fd51a7949b08620ab8db7407d1269c38e4ef2edd143b1a78d56ae82eaa2d You will notice the marbles chaincode has been installed on your peer. Next, let's check which chaincode is instantiated on the channel: peer chaincode list --instantiated -C $CHANNEL Sample Output: Get instantiated chaincodes on channel mychannel: Name: marbles, Version: 1.0, Path: marbles, Escc: escc, Vscc: vscc Here, you see the marbles chaincode has also been instantiated on the channel and is ready to be used to submit transactions. Submit transactions with the peer to create yourself as a marbles owner with a marble of your own Now it's time for one of your team members to add yourself as a marbles owner to the channel. First set your name as the marbles owner owner=Garrett Then create the owner with the following command: peer chaincode invoke -C ${CHANNEL} -n ${CC_NAME} -c '{ Args :[ init_owner , o0'$team' , '$owner' , '$CORE_PEER_LOCALMSPID' ]}' --tls --cafile $ORDERER_CA -o ${ORDERER_1} Sample Output: 2019-03-08 03:47:55.093 UTC [chaincodeCmd] chaincodeInvokeOrQuery - INFO 001 Chaincode invoke successful. result: status:200 Next, give your owner a black marble: peer chaincode invoke -C ${CHANNEL} -n ${CC_NAME} -c '{ Args :[ init_marble , m0'$team' , black , 200 , o0'$team' , '$CORE_PEER_LOCALMSPID' ]}' --tls --cafile $ORDERER_CA -o ${ORDERER_1} Sample Output 2019-03-08 03:48:02.027 UTC [chaincodeCmd] chaincodeInvokeOrQuery - INFO 001 Chaincode invoke successful. result: status:200 Finally, run a query against the ledger to see your owner and marble as well as everyone else's so far: peer chaincode invoke -C ${CHANNEL} -n ${CC_NAME} -c '{ Args :[ read_everything ]}' --tls --cafile $ORDERER_CA -o ${ORDERER_1} Sample Output: 2019-03-15 08:47:04.730 UTC [chaincodeCmd] chaincodeInvokeOrQuery - INFO 001 Chaincode invoke successful. result: status:200 payload: {\\ owners\\ :[{\\ docType\\ :\\ marble_owner\\ ,\\ id\\ :\\ o015525575491703BpSw\\ ,\\ username\\ :\\ rick\\ ,\\ company\\ :\\ org0\\ ,\\ enabled\\ :true} Note: This will grow as more marbles and owners get added to the ledger by your org and other orgs. Configure the marbles application to connect to your peer Go into the marbles directory: cd marbles/config The marbles application will connect to your fabric network using the Hyperledger Fabric Node.js Software Development Kit (SDK) Application Programming Interface (API) by consuming information in the file connection_profile_tls.json Take a look at this file with cat connection_profile_tls.json Take note that this file has connection information and TLS certificates for your, peers, certificate authority (CA), and the orderer for your network. Next, you will be able to specify which users you want to enroll in your application. Edit the file marbles_tls.json to do this: vim marbles_tls.json Edit the names to what you want in the usernames section such as: { cred_filename : connection_profile_tls.json , use_events : true, keep_alive_secs : 120, usernames : [ Beth , Rick , Jerry ], port : 3001 } In vim you edit by typing i and then making your changes using the arrow keys to navigate. Once you are finished making changes hit the escape key. Then save your changes with a save command such as :x , holding down shift and typing ZZ ( shift + ZZ ), shift + ZQ or using the worst option :wq . Once the file has been saved, move back to the parent directory with cd .. Connect the marbles application to your peer Run npm install -g gulp This will install the gulp npm package necessary to run the marbles application. Run npm install This will install the dependencies for the marbles application specified in the package.json file in the /home/marbles directory. This may take a few minutes. You will notice a bunch of CXX(target) in the output of this command because two of the packages (i.e., pkcs11js and grpc) needs to be compiled from source for s390x. This needs to happen since the binaries are not publicly available for this platform. When this command completes it will return your terminal to you. Now you can start the marbles application with gulp marbles_tls Open up a web browser on your pc and navigate to the ip given to you earlier at port 3000 in the form xxx.xxx.xxx.xxx:3000 where xxx.xxx.xxx.xxx is your given ip address with each x being a possible digit (e.g., 192.168.22.150:3000 ). First, choose Express to setup your marbles application Here you can see your org, the owners and marbles you created in the marbles_tls.json file and the marble and owner you created with the cli. You created a black marble with the cli and the application randomly selects a color for the marbles created from the marbles_tls.json file (in this case black, but your mileage with the random function may vary) We can also see the other orgs and their marbles that are connected in this connectathon. Next turn on story mode to see the marble transaction process: Click on settings Enable Story Mode Finally, trade some marbles to other users. Click on a marble from a user in your org and drag it to another user in your org Click and drag a marble from a member in your org and move it to a member of a different org Click and drag a marble from a member of a different org and drag it to a member of your org Notice that you can give marbles to other orgs but can't take them and think about why this may be the case... Now close the application by returning to your terminal and typing ctrl + c to return your terminal prompt. You have now setup the marbles application. Please move on to part 2 where you will deploy this into your cluster.","title":"Part 1"},{"location":"connect-part1/#overview","text":"The goal of this part of the lab is to go through the process of using your peer with the fabric command line interface (cli) tools and connecting it with marbles. In this part of the lab, you will: Connect to your peer Log in to our Kubernetes cluster Take a look at your peer setup environment variables Check the chaincode on the peer and the channel Submit transactions with your peer to create yourself as a marbles owner with a marble Configure the marbles application to connect to your peer Connect the marbles application to your peer","title":"Overview"},{"location":"connect-part1/#connect-to-your-peer","text":"An IBM Blockchain Platform network has been set up with an organization for each member of the lab in our IBM Cloud Private Kubernetes Cluster. The necessary certificate material and environment variables to operate your peer as well as the marbles project have been packaged into a container for your use during the lab. This container is labeled based on your team. Please open a terminal window on your computer and set your given ip address and ssh into that z machine IP_ADDRESS=givenip ssh bcuser@$IP_ADDRESS Sample Output: Welcome to Ubuntu 16.04.5 LTS (GNU/Linux 4.4.0-139-generic s390x) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantage Last login: Mon Jan 21 21:43:38 2019 from 192.168.22.64 bcuser@ubuntu16045:~ Then, add the cluster to your /etc/hosts and add the self-signed certificate to your ca-certificates echo 192.168.22.81 wsc-ibp-icp-cluster.icp | sudo tee --append /etc/hosts sudo mkdir /usr/local/share/ca-certificates/wsc-ibp-icp-cluster.icp sudo openssl s_client -showcerts -servername wsc-ibp-icp-cluster.icp -connect wsc-ibp-icp-cluster.icp:8443 /dev/null 2 /dev/null | sudo openssl x509 | sudo tee /usr/local/share/ca-certificates/wsc-ibp-icp-cluster.icp/ca.crt sudo update-ca-certificates Sample Output: 192.168.22.81 wsc-ibp-icp-cluster.icp -----BEGIN CERTIFICATE----- MIIFfjCCA2agAwIBAgIQbJlENedx5PvDbGD7XLDnITANBgkqhkiG9w0BAQsFADBj MQswCQYDVQQGEwJVUzERMA8GA1UECAwITmV3IFlvcmsxDzANBgNVBAcMBkFybW9u azEaMBgGA1UECgwRSUJNIENsb3VkIFByaXZhdGUxFDASBgNVBAMMC3d3dy5pYm0u Y29tMCAXDTE4MTIxMjE5NTQ1MVoYDzIxMTgxMTE4MTk1NDUxWjBgMQswCQYDVQQG EwJDTjEQMA4GA1UECAwHU2hhYW54aTEOMAwGA1UEBwwFWGknYW4xGjAYBgNVBAoM EUlCTSBDbG91ZCBQcml2YXRlMRMwEQYDVQQDDAppY3Atcm91dGVyMIIBIjANBgkq hkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArsBisMJEyMGHZ+93mcFsXX0AQc+QXSVW o53f3JEd2Kn+tZLx57vOzRWmMop7B1pSe06c1GwFKofOWSTgHCHv8DO8+h9TIm3x +9IUaLx65mxrTMToUjIxjNyt2JjElHJskxrbpwJsofG59gxhGal8ed89SveXYIL/ PkXvkm5jsoPaRFjgQq0KJoy9UO26aD/FMJu9HzV+7P6Tu8Q+OJHgWSvIgKfX9vOg qyMxv8vGYEGh4jLgQFRMMfXdH01y2diZ259771wHjsTdMRUnxRC36RTDgIXp+0CR 143p1+dmucYD5G45rOwzPuDi67VNho8mtXs5ohTQfovj4FdcDVtFgQIDAQABo4IB LTCCASkwCQYDVR0TBAIwADAdBgNVHQ4EFgQUIMoa55D0BPmJ5FYOEiIa6mw+qtYw gZUGA1UdIwSBjTCBioAUZ9zE9CrhJ2Lm/tLiDLDK5H3asjqhZ6RlMGMxCzAJBgNV BAYTAlVTMREwDwYDVQQIDAhOZXcgWW9yazEPMA0GA1UEBwwGQXJtb25rMRowGAYD VQQKDBFJQk0gQ2xvdWQgUHJpdmF0ZTEUMBIGA1UEAwwLd3d3LmlibS5jb22CCQCV Y/GaGOxNzTAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwCwYDVR0PBAQD AgWgMDkGA1UdEQQyMDCHBH8AAAGCCWxvY2FsaG9zdIcEwKgWUYIXd3NjLWlicC1p Y3AtY2x1c3Rlci5pY3AwDQYJKoZIhvcNAQELBQADggIBABCkUfS8TTO2sPJlJjAn ZiatcrliKZ2KJqdNNouF68E+xHfthfXxhl93TP5oUEw7lFN8yRb+z0o16wZksliw h8FpunHZAuQ+M2qI3afIiRU2H58drGHkBmbZwoMYAQaFrU+A9VEzgibtjBHCkL4p g+3kzQySCJq+A9lmVq/gwrd3cqfPxsFckqq1eGvP8BfcwxvkUIPnOp/Vh9f2jgK7 UNfmPd4hZSzTr2jOfdBAGaltc4C+MAougCAppz7cVQXvb9A2b7ffF3JmYbr626Bk Pp7c0rZAzLRsoZy8ngT9zS+9CucY8MolpPDQmBL48asaMYCRgTx6wAgD6bDzJnpt F0c+FFf7k4782vJELs4gwXkkWRVmaHBlHn4yfYObsiS23snhu2Fvuu2bBWmFMXEr PCK9d1JO1czb672fd18aOj6pmNLZMiIfwIxOxkDpASa4urOhA4sV/61cTpxCSuGs MFhrLN9rKvPlQCh+z/gLPvcf/DVuKoRO+JIVLKl7oSp4GQY7HjdpzggUvCxayp3J EUe4eqOnN50oogTFw8FA4/mNrMzt4wXfk/1yPgWS9ey0EBuFg8fTi2GjLuR00Xsb pjbmU0n0RUpzWdZBHZwb2SpvA6D5M7Ii+aFM0eH5YK5gCU9U9x3hI1MjAtVsINsF cTiYtc/9hu704vR7CQ3uFvOk -----END CERTIFICATE----- Updating certificates in /etc/ssl/certs... 1 added, 0 removed; done. Running hooks in /etc/ca-certificates/update.d... done. Take particular note that 1 certificate was added and 0 removed in your output like in the sample output above. Next, set your team name and login to the private docker repository TEAM=teamxx credential=p@ssw0rd echo $credential | docker login wsc-ibp-icp-cluster.icp:8500 -u $TEAM --password-stdin Sample Output: Login Succeeded Now, start your unique image which will return a command prompt: docker run --rm -it -v /var/run/docker.sock:/var/run/docker.sock --name $TEAM -p 3000:3001 wsc-ibp-icp-cluster.icp:8500/lab-test/connectathon-s390x-$TEAM:1.0 bash This command is using Docker to run your team's container in an interactive bash shell and connect it to your machine's docker socket so you can create sibling containers from your container image. Additionally, you are giving it the name of your team and forwarding traffic on port 3000 of the host to port 3001 on your container to access your marbles application during the lab.","title":"Connect to your peer"},{"location":"connect-part1/#login-to-our-kubernetes-cluster","text":"Run the following command to connect to the running IBM Cloud Private Kubernetes cluster. cloudctl login -a https://192.168.22.81:8443 -u $team -p $credential -n lab-test Sample Output: Targeted account wsc-ibp-icp-cluster Account (id-wsc-ibp-icp-cluster-account) Targeted namespace lab-test Configuring kubectl ... Property clusters.wsc-ibp-icp-cluster unset. Property users.wsc-ibp-icp-cluster-user unset. Property contexts.wsc-ibp-icp-cluster-context unset. Cluster wsc-ibp-icp-cluster set. User wsc-ibp-icp-cluster-user set. Context wsc-ibp-icp-cluster-context created. Switched to context wsc-ibp-icp-cluster-context . OK Configuring helm: /root/.helm OK","title":"Login to our Kubernetes cluster"},{"location":"connect-part1/#take-a-look-at-your-peer-setup-environment-variables","text":"In order to operate your peer a number of environment variables need to be set. Let's take a look at some of the environment variables set for the Hyperledger Fabric cli to work with your peer: env | grep CORE Sample Output: CORE_PEER_LOCALMSPID=org0 CORE_PEER_TLS_ENABLED=true CORE_PEER_MSPCONFIGPATH=/home/org0/admin CORE_PEER_TLS_ROOTCERT_FILE=/home/org0/peertls.pem CORE_PEER_ADDRESS=192.168.22.81:30035 CORE_PEER_LOCALMSPID=org0 defines the local MSP or Membership Services Provider of the peer which contains the identifying information (i.e., certs and keys) for the peer as well as the certificates of trusted Certificate Authorities which are authorized to issue identities on behalf of the organization. (In this example org0 is the MSPID, yours will correspond with your team) CORE_PEER_TLS_ENABLED=true is used to enable transport layer security (TLS) communication. CORE_PEER_MSPCONFIGPATH points to the MSP material you are using to operate the peer CORE_PEER_TLS_ROOTCERT_FILE is the root TLS certificate for the peer which your system needs to trust to have a TLS connection with the peer. CORE_PEER_ADDRESS is the peer's IP address used to connect with the peer.","title":"Take a look at your peer setup environment variables"},{"location":"connect-part1/#check-the-chaincode-on-the-peer-and-the-channel","text":"In order to check which chaincode is installed on your peer run: peer chaincode list --installed Sample Output: Get installed chaincodes on peer: Name: marbles, Version: 1.0, Path: marbles, Id: 4421fd51a7949b08620ab8db7407d1269c38e4ef2edd143b1a78d56ae82eaa2d You will notice the marbles chaincode has been installed on your peer. Next, let's check which chaincode is instantiated on the channel: peer chaincode list --instantiated -C $CHANNEL Sample Output: Get instantiated chaincodes on channel mychannel: Name: marbles, Version: 1.0, Path: marbles, Escc: escc, Vscc: vscc Here, you see the marbles chaincode has also been instantiated on the channel and is ready to be used to submit transactions.","title":"Check the chaincode on the peer and the channel"},{"location":"connect-part1/#submit-transactions-with-the-peer-to-create-yourself-as-a-marbles-owner-with-a-marble-of-your-own","text":"Now it's time for one of your team members to add yourself as a marbles owner to the channel. First set your name as the marbles owner owner=Garrett Then create the owner with the following command: peer chaincode invoke -C ${CHANNEL} -n ${CC_NAME} -c '{ Args :[ init_owner , o0'$team' , '$owner' , '$CORE_PEER_LOCALMSPID' ]}' --tls --cafile $ORDERER_CA -o ${ORDERER_1} Sample Output: 2019-03-08 03:47:55.093 UTC [chaincodeCmd] chaincodeInvokeOrQuery - INFO 001 Chaincode invoke successful. result: status:200 Next, give your owner a black marble: peer chaincode invoke -C ${CHANNEL} -n ${CC_NAME} -c '{ Args :[ init_marble , m0'$team' , black , 200 , o0'$team' , '$CORE_PEER_LOCALMSPID' ]}' --tls --cafile $ORDERER_CA -o ${ORDERER_1} Sample Output 2019-03-08 03:48:02.027 UTC [chaincodeCmd] chaincodeInvokeOrQuery - INFO 001 Chaincode invoke successful. result: status:200 Finally, run a query against the ledger to see your owner and marble as well as everyone else's so far: peer chaincode invoke -C ${CHANNEL} -n ${CC_NAME} -c '{ Args :[ read_everything ]}' --tls --cafile $ORDERER_CA -o ${ORDERER_1} Sample Output: 2019-03-15 08:47:04.730 UTC [chaincodeCmd] chaincodeInvokeOrQuery - INFO 001 Chaincode invoke successful. result: status:200 payload: {\\ owners\\ :[{\\ docType\\ :\\ marble_owner\\ ,\\ id\\ :\\ o015525575491703BpSw\\ ,\\ username\\ :\\ rick\\ ,\\ company\\ :\\ org0\\ ,\\ enabled\\ :true} Note: This will grow as more marbles and owners get added to the ledger by your org and other orgs.","title":"Submit transactions with the peer to create yourself as a marbles owner with a marble of your own"},{"location":"connect-part1/#configure-the-marbles-application-to-connect-to-your-peer","text":"Go into the marbles directory: cd marbles/config The marbles application will connect to your fabric network using the Hyperledger Fabric Node.js Software Development Kit (SDK) Application Programming Interface (API) by consuming information in the file connection_profile_tls.json Take a look at this file with cat connection_profile_tls.json Take note that this file has connection information and TLS certificates for your, peers, certificate authority (CA), and the orderer for your network. Next, you will be able to specify which users you want to enroll in your application. Edit the file marbles_tls.json to do this: vim marbles_tls.json Edit the names to what you want in the usernames section such as: { cred_filename : connection_profile_tls.json , use_events : true, keep_alive_secs : 120, usernames : [ Beth , Rick , Jerry ], port : 3001 } In vim you edit by typing i and then making your changes using the arrow keys to navigate. Once you are finished making changes hit the escape key. Then save your changes with a save command such as :x , holding down shift and typing ZZ ( shift + ZZ ), shift + ZQ or using the worst option :wq . Once the file has been saved, move back to the parent directory with cd ..","title":"Configure the marbles application to connect to your peer"},{"location":"connect-part1/#connect-the-marbles-application-to-your-peer","text":"Run npm install -g gulp This will install the gulp npm package necessary to run the marbles application. Run npm install This will install the dependencies for the marbles application specified in the package.json file in the /home/marbles directory. This may take a few minutes. You will notice a bunch of CXX(target) in the output of this command because two of the packages (i.e., pkcs11js and grpc) needs to be compiled from source for s390x. This needs to happen since the binaries are not publicly available for this platform. When this command completes it will return your terminal to you. Now you can start the marbles application with gulp marbles_tls Open up a web browser on your pc and navigate to the ip given to you earlier at port 3000 in the form xxx.xxx.xxx.xxx:3000 where xxx.xxx.xxx.xxx is your given ip address with each x being a possible digit (e.g., 192.168.22.150:3000 ). First, choose Express to setup your marbles application Here you can see your org, the owners and marbles you created in the marbles_tls.json file and the marble and owner you created with the cli. You created a black marble with the cli and the application randomly selects a color for the marbles created from the marbles_tls.json file (in this case black, but your mileage with the random function may vary) We can also see the other orgs and their marbles that are connected in this connectathon. Next turn on story mode to see the marble transaction process: Click on settings Enable Story Mode Finally, trade some marbles to other users. Click on a marble from a user in your org and drag it to another user in your org Click and drag a marble from a member in your org and move it to a member of a different org Click and drag a marble from a member of a different org and drag it to a member of your org Notice that you can give marbles to other orgs but can't take them and think about why this may be the case... Now close the application by returning to your terminal and typing ctrl + c to return your terminal prompt. You have now setup the marbles application. Please move on to part 2 where you will deploy this into your cluster.","title":"Connect the marbles application to your peer"},{"location":"connect-part2/","text":"Overview The goal of this part of the lab is to guide you through the process of packaging up a blockchain front end application to run inside a Kubernetes cluster. In the lab environment, this happens to be the same cluster that is hosting your blockchain components. In the real world, this may not always be the case. In this part of the lab, you will: Build a docker image with the Marbles UI Test the container locally on your Linux image Push the image to the ICP cluster's private docker registry Create a Kubernetes deployment and service for the Marbles UI Deploy the Kubernetes deployment Test the marbles UI Only if you stopped in between the lab parts 1 and 2 make sure you still have an ssh connection to your bcuser instance. If not please rerun IP_ADDRESS=givenip for your given ip and ssh bcuser@$IP_ADDRESS Check to make sure you are still in your docker image. If you got out of your docker image go back into the image by first setting your TEAM with TEAM=teamxx where xx is the number of your team. Then, check if your container is still running with docker ps | grep team a) If you get sample output showing a container such as: 6e6ad92499b1 wsc-ibp-icp-cluster.icp:8500/lab-test/connectathon-s390x-team10:1.0 \"bash\" 12 minutes ago Up 12 minutes 0.0.0.0:3000- 3001/tcp team10 follow Option a) of step 3 below b) If you get sample output not showing anything such as: follow Option b) of step 3 below Do only 1 of the options below based on step 2 above! a) exec back into your running container with docker exec -it $TEAM sh OR b) restart your container with docker run --rm -it -v /var/run/docker.sock:/var/run/docker.sock --name $TEAM -p 3000:3001 wsc-ibp-icp-cluster.icp:8500/lab-test/connectathon-s390x-$TEAM:1.0 bash Before you start, make sure you are still logged in to the cluster. Run the following commands to display the pods that are currently deployed to our cluster. First, type kubectl get pods Sample Output: NAME READY STATUS RESTARTS AGE connectathon-orderer-orderer-85bb44f87c-qk662 1/1 Running 0 1d connectathon-ordererorg-ca-fabric-ca-deployment-7f6b9b6577whxgr 1/1 Running 0 1d connectathon-org0-ca-fabric-ca-deployment-67cf7486dd-9wtg7 1/1 Running 0 1d connectathon-org0peer1-55fc894b9-5qncl 2/2 Running 0 1d connectathon-org1-ca-fabric-ca-deployment-59f9457fc5-9jmfp 1/1 Running 0 1d connectathon-org10-ca-fabric-ca-deployment-76794dcbbf-jdkcr 1/1 Running 0 1d connectathon-org10peer1-86dc5fcdf7-6c5qm 2/2 Running 0 39m connectathon-org11-ca-fabric-ca-deployment-5bc55cc776-5cjbz 1/1 Running 0 1d connectathon-org11peer1-69f67d965-svwjh 2/2 Running 0 1d connectathon-org1peer1-7665b7c6d7-x8spx 2/2 Running 0 1d connectathon-org2-ca-fabric-ca-deployment-787cbdf766-qwdjw 1/1 Running 0 1d connectathon-org2peer1-7d4bbfc7bf-gs9qv 2/2 Running 0 1d connectathon-org3-ca-fabric-ca-deployment-54cfc78777-m782f 1/1 Running 0 1d If you are able to see the output of the kubectl command such as above you are still logged in. If not, run: cloudctl login -a https://192.168.22.81:8443 -u $team -p $credential -n lab-test Sample Output: Targeted account wsc-ibp-icp-cluster Account (id-wsc-ibp-icp-cluster-account) Targeted namespace lab-test Configuring kubectl ... Property clusters.wsc-ibp-icp-cluster unset. Property users.wsc-ibp-icp-cluster-user unset. Property contexts.wsc-ibp-icp-cluster-context unset. Cluster wsc-ibp-icp-cluster set. User wsc-ibp-icp-cluster-user set. Context wsc-ibp-icp-cluster-context created. Switched to context wsc-ibp-icp-cluster-context . OK Configuring helm: /root/.helm OK Now, run kubectl get pods | grep $CORE_PEER_LOCALMSPID Sample Output: NAME READY STATUS RESTARTS AGE connectathon-org0-ca-fabric-ca-deployment-67cf7486dd-9wtg7 1/1 Running 0 7h connectathon-org0peer1-55fc894b9-5qncl 2/2 Running 0 7h You should see one peer pod, and one CA pod. Both should be in Running status. Your organization only has one peer in this scenario. Build a docker image Now that you have tested the Marbles front end User Interface (Marbles UI, for short), let's save it as a docker image using the supplied Dockerfile. A Dockerfile is a text document that contains all the commands a user could call on the command line to assemble an image. Think of it as a specific way to package up a set of files and instructions that together make up a microservice. Go to your marbles directory: cd /home/marbles Here you should see a Dockerfile: ls -ltr Dockerfile Sample Output: -rw-rw-r-- 1 1000 1000 394 Feb 28 22:12 Dockerfile If you are curious, cat the file to look at its contents: cat Dockerfile Sample Output: FROM node:8-alpine ENV NPM_CONFIG_LOGLEVEL warn RUN mkdir -p /usr/src/app WORKDIR /usr/src/app COPY package.json /usr/src/app/ RUN apk add --no-cache --virtual .build-deps make gcc g++ python \\ npm install --silent \\ npm install gulp -g ---unsafe-perm \\ apk del .build-deps .build-deps make gcc g++ python COPY . /usr/src/app/ EXPOSE 3001 CMD [ gulp , marbles_tls ] The above Dockerfile builds from an Alpine node image already out there in DockerHub. This is a bare bones Linux image of the Alpine distribution with node version 8 installed. Next, the NPM_CONFIG_LOGLEVEL for npm is globally set to warn so that npm will only print errors and warnings. ENV is used for this to persist this change as an environment variable in your finished container. Then, it uses RUN to run a command inside of the base node:8-alpine container to make a directory for the marbles application. WORKDIR makes this directory the current working directory. Moreover, COPY brings the package.json file (containing the names of the application's dependent node modules) into the containers /usr/src/app directory. The following RUN command uses apk (Alpine's package manager) to install a variety of pre-reqs to your npm install such as make, gcc and python, before running the actual npm install twice to install both the necessary node modules needed by the Marbles UI itself and gulp to start the marbles UI. Note that this is all done in one line with to make it occur in one layer. This way, at the end of the RUN you can use a delete command apk del and take the developer tools you no longer need out of your image. If you instead ran this as multiple commands, you would not be able to shrink your image size since previous layers can't be effectively deleted due to the layered file system. Finally, you copy the application itself and the connection profile materials into your working directory, document the port you will run marbles on ( 3001 ), and set a command for the container to run when it starts gulp marbles_tls . Now let's run docker build in the /home/marbles directory: docker build -t marbles-$team . NOTE: Please remember to not forget that pesky . Otherwise you will get an error saying \"docker build\" requires exactly 1 argument Sample Output: Sending build context to Docker daemon 261.9MB Step 1/9 : FROM node:8-alpine --- 66f08ecb7600 Step 2/9 : ENV NPM_CONFIG_LOGLEVEL warn --- Using cache --- 180c28267c41 Step 3/9 : RUN mkdir -p /usr/src/app --- Using cache --- f9615b4a1813 Step 4/9 : WORKDIR /usr/src/app --- Using cache --- e53d507c2bf9 .... .... lots more messages .... Successfully built 9b57c7c3e480 Successfully tagged marbles-team00:latest Now you should see this new image that you just built: docker images Sample Output: Test the docker image locally Let's test the image that was just built, by running it locally: docker run -it --init -p 3001:3001/tcp --name marbles-$team marbles-$team Sample Output [20:57:50] Using gulpfile /usr/src/app/gulpfile.js [20:57:50] Starting 'env_tls'... [20:57:50] Finished 'env_tls' after 73 \u03bcs [20:57:50] Starting 'build-sass'... [20:57:50] Finished 'build-sass' after 7.48 ms [20:57:50] Starting 'watch-sass'... [20:57:50] Finished 'watch-sass' after 7.47 ms [20:57:50] Starting 'watch-server'... [20:57:50] Finished 'watch-server' after 2.55 ms [20:57:50] Starting 'server'... info: Checking connection profile is done info: Loaded config file /usr/src/app/config/marbles_tls.json info: Loaded connection profile file /usr/src/app/config/connection_profile_tls.json ... lots of output ... - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - debug: Detected that we have launched successfully before debug: Welcome back - Marbles is ready debug: Open your browser to http://localhost:3001 and login as admin - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - After you see the \"Open your browser to https://localhost:3001\" message, point your browser to the IP address of your Linux image, e.g., http://192.168.22.107:3001 and you will see the Marbles UI. Once you verify that the image works locally, it's time to stop the running container. Type Ctrl + C to exit out of the running container in the current terminal. Push image to the ICP Cluster's private repo You will now tag the image you created with the private repo's host name and port number, followed by the namespace you are using, as follows. docker tag marbles-$team:latest wsc-ibp-icp-cluster.icp:8500/lab-test/marbles-$team:1.0 Log into the docker private registry using your teamNN id and credential, as follows: echo $credential | docker login wsc-ibp-icp-cluster.icp:8500 -u $team --password-stdin Sample Output: WARNING! Your password will be stored unencrypted in /root/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded Now push up the image using the tag you just created (again be mindful that the name pushed in the output will reflect your team name): docker push wsc-ibp-icp-cluster.icp:8500/lab-test/marbles-$team:1.0 Sample Output: The push refers to repository [wsc-ibp-icp-cluster.icp:8500/lab-test/marbles-team00] c8490573a0d8: Pushed 8e63f87572fb: Pushed a6a08bb664f7: Pushed 3a30ca7a2471: Pushed ccc0f617b78a: Pushed 1801fc515e2a: Pushed 1.0: digest: sha256:6a796e973817f714b64e767b3c35affd93a6dc5df7ef12ca872aca64d20a5155 size: 1997 Let's log in to the ICP Console for the first time and verify that your image got pushed up to the cluster's private docker registry. Point your browser to https://192.168.22.81:8443 . Accept that it's using a self-signed certificate. This should lead you to the sign in page. Log in with your team's credentials given to you at the beginning of the lab: you can find this by echoing the team and credential variables in your terminal: echo $team echo $credential . Your team is your username and your credential is your password. You can verify your image got pushed up by going to the hamburger menu on the top left corner and selecting Container Images and look for lab-test/marbles-teamNN. Note: you will have to go to the last page to see images under the namespace lab-test. Create a Kubernetes deployment and service Log in to the ICP cluster with your team's ID and password: cloudctl login -a https://192.168.22.81:8443 -u $team -p $credential -n lab-test Sample Output: Targeted account wsc-ibp-icp-cluster Account (id-wsc-ibp-icp-cluster-account) Targeted namespace lab-test Configuring kubectl ... Property clusters.wsc-ibp-icp-cluster unset. Property users.wsc-ibp-icp-cluster-user unset. Property contexts.wsc-ibp-icp-cluster-context unset. Cluster wsc-ibp-icp-cluster set. User wsc-ibp-icp-cluster-user set. Context wsc-ibp-icp-cluster-context created. Switched to context wsc-ibp-icp-cluster-context . OK Configuring helm: /root/.helm OK Verify that your organization's Fabric pods are running. Note that you have a Fabric CA pod and one Fabric peer pod running. The environment variable $CORE_PEER_LOCALMSPID was set for you and it was set to your peer's MSPID. In this lab environment, your MSPID corresponds to your team number. i.e. team01 will be org1, team02 will be org2, etc. kubectl get pods | grep connectathon-$CORE_PEER_LOCALMSPID Sample Output: connectathon-org0-ca-fabric-ca-deployment-67cf7486dd-xgqkb 1/1 Running 0 7h connectathon-org0peer1-55fc894b9-fhz2f 2/2 Running 0 7h You should have a Kubernetes deployment yaml file in your /home/marbles directory called marbles-teamNN.yaml . Kubernetes objects are defined in yaml files and then created on or applied to a running cluster. You can create a Kubernetes resource from the ICP Console as well. But here you will do this via the command line tool kubectl which interacts with the Kubernetes API Server on the cluster. Now run the following command to create a marbles deployment yaml file that matches your team name. cat marbles-teamNN.yaml | sed -r 's/teamNN/'$team'/' marbles-$team.yaml You can cat the yaml file to see its contents: cat marbles-$team.yaml Sample Output: apiVersion: v1 kind: Service metadata: name: marbles-team00-svc spec: selector: app: marbles-team00 ports: - protocol: TCP port: 3001 targetPort: 3001 type: NodePort --- apiVersion: extensions/v1beta1 kind: Deployment metadata: name: marbles-team00-deploy labels: app: marbles-team00 spec: selector: matchLabels: app: marbles-team00 replicas: 1 template: metadata: labels: app: marbles-team00 spec: containers: - name: marbles-team00 image: wsc-ibp-icp-cluster.icp:8500/lab-test/marbles-team00:1.0 ports: - containerPort: 3001 imagePullPolicy: Always The important parts to point out in the yaml file are that it will create a Kubernetes service called marbles-team00-svc and that it is pointing to the marbles-team00 container. The service will be of type NodePort which means this service will be reachable outside of the cluster. The yaml file will also create a Kubernetes deployment that has one pod with one container that will be based off of the wsc-ibp-icp-cluster.icp:8500/lab-test/marbles-team00:1.0 image that you pushed to the private registry earlier. Deploy the service and test the Marbles UI Now you are ready to create the Kubernetes resources. Run the following command: kubectl apply -f marbles-$team.yaml service/marbles-team00-svc created deployment.extensions/marbles-team00-deploy created The deployment will create one pod that has one container. A service is also created. Check that your pod is READY 1/1 and in Running status: kubectl get pods | grep marbles-$team marbles-team00-deploy-55649dbc5b-xf787 1/1 Running 0 35s Launch the Marbles service and test the Marbles UI Now, let's navigate through the ICP Console to your deployment. Point your browser to https://192.168.22.81:8443 . Accept that it's using a self signed certificate. This should lead you to the sign in page. Log in with your team's credentials given to you at the beginning of the lab. Go to the hamburger menu on the upper left corner, and select Workloads - Deployments . Find your team's deployment, it should be similar to marbles-team00-deploy but with your team name. Click on your deployment. You will be taken to the details page of your deployment. Upon further exploration you will see the deployment has one ReplicaSet, and one Pod. You can choose to click into either the ReplicaSet or Pod to get details about those two objects. Now click on the Launch button for your deployment. This will bring up the Marbles UI. At this point, depending on where the other classroom students are, you will see two or more organizations in the Marbles UI. Test out the application by transacting some marbles with your neighboring students. Enabling Story Mode in Settings will provide a step by step guided experience during each transaction. Congratulations! You've successfully created a container for the Marbles front end application, created a Kubernetes deployment for it, and deployed it in a IBM Cloud Private Kubernetes cluster.","title":"Part 2"},{"location":"connect-part2/#overview","text":"The goal of this part of the lab is to guide you through the process of packaging up a blockchain front end application to run inside a Kubernetes cluster. In the lab environment, this happens to be the same cluster that is hosting your blockchain components. In the real world, this may not always be the case. In this part of the lab, you will: Build a docker image with the Marbles UI Test the container locally on your Linux image Push the image to the ICP cluster's private docker registry Create a Kubernetes deployment and service for the Marbles UI Deploy the Kubernetes deployment Test the marbles UI","title":"Overview"},{"location":"connect-part2/#only-if-you-stopped-in-between-the-lab-parts-1-and-2","text":"make sure you still have an ssh connection to your bcuser instance. If not please rerun IP_ADDRESS=givenip for your given ip and ssh bcuser@$IP_ADDRESS Check to make sure you are still in your docker image. If you got out of your docker image go back into the image by first setting your TEAM with TEAM=teamxx where xx is the number of your team. Then, check if your container is still running with docker ps | grep team a) If you get sample output showing a container such as: 6e6ad92499b1 wsc-ibp-icp-cluster.icp:8500/lab-test/connectathon-s390x-team10:1.0 \"bash\" 12 minutes ago Up 12 minutes 0.0.0.0:3000- 3001/tcp team10 follow Option a) of step 3 below b) If you get sample output not showing anything such as: follow Option b) of step 3 below Do only 1 of the options below based on step 2 above! a) exec back into your running container with docker exec -it $TEAM sh OR b) restart your container with docker run --rm -it -v /var/run/docker.sock:/var/run/docker.sock --name $TEAM -p 3000:3001 wsc-ibp-icp-cluster.icp:8500/lab-test/connectathon-s390x-$TEAM:1.0 bash","title":"Only if you stopped in between the lab parts 1 and 2"},{"location":"connect-part2/#before-you-start-make-sure-you-are-still-logged-in-to-the-cluster","text":"Run the following commands to display the pods that are currently deployed to our cluster. First, type kubectl get pods Sample Output: NAME READY STATUS RESTARTS AGE connectathon-orderer-orderer-85bb44f87c-qk662 1/1 Running 0 1d connectathon-ordererorg-ca-fabric-ca-deployment-7f6b9b6577whxgr 1/1 Running 0 1d connectathon-org0-ca-fabric-ca-deployment-67cf7486dd-9wtg7 1/1 Running 0 1d connectathon-org0peer1-55fc894b9-5qncl 2/2 Running 0 1d connectathon-org1-ca-fabric-ca-deployment-59f9457fc5-9jmfp 1/1 Running 0 1d connectathon-org10-ca-fabric-ca-deployment-76794dcbbf-jdkcr 1/1 Running 0 1d connectathon-org10peer1-86dc5fcdf7-6c5qm 2/2 Running 0 39m connectathon-org11-ca-fabric-ca-deployment-5bc55cc776-5cjbz 1/1 Running 0 1d connectathon-org11peer1-69f67d965-svwjh 2/2 Running 0 1d connectathon-org1peer1-7665b7c6d7-x8spx 2/2 Running 0 1d connectathon-org2-ca-fabric-ca-deployment-787cbdf766-qwdjw 1/1 Running 0 1d connectathon-org2peer1-7d4bbfc7bf-gs9qv 2/2 Running 0 1d connectathon-org3-ca-fabric-ca-deployment-54cfc78777-m782f 1/1 Running 0 1d If you are able to see the output of the kubectl command such as above you are still logged in. If not, run: cloudctl login -a https://192.168.22.81:8443 -u $team -p $credential -n lab-test Sample Output: Targeted account wsc-ibp-icp-cluster Account (id-wsc-ibp-icp-cluster-account) Targeted namespace lab-test Configuring kubectl ... Property clusters.wsc-ibp-icp-cluster unset. Property users.wsc-ibp-icp-cluster-user unset. Property contexts.wsc-ibp-icp-cluster-context unset. Cluster wsc-ibp-icp-cluster set. User wsc-ibp-icp-cluster-user set. Context wsc-ibp-icp-cluster-context created. Switched to context wsc-ibp-icp-cluster-context . OK Configuring helm: /root/.helm OK Now, run kubectl get pods | grep $CORE_PEER_LOCALMSPID Sample Output: NAME READY STATUS RESTARTS AGE connectathon-org0-ca-fabric-ca-deployment-67cf7486dd-9wtg7 1/1 Running 0 7h connectathon-org0peer1-55fc894b9-5qncl 2/2 Running 0 7h You should see one peer pod, and one CA pod. Both should be in Running status. Your organization only has one peer in this scenario.","title":"Before you start, make sure you are still logged in to the cluster."},{"location":"connect-part2/#build-a-docker-image","text":"Now that you have tested the Marbles front end User Interface (Marbles UI, for short), let's save it as a docker image using the supplied Dockerfile. A Dockerfile is a text document that contains all the commands a user could call on the command line to assemble an image. Think of it as a specific way to package up a set of files and instructions that together make up a microservice. Go to your marbles directory: cd /home/marbles Here you should see a Dockerfile: ls -ltr Dockerfile Sample Output: -rw-rw-r-- 1 1000 1000 394 Feb 28 22:12 Dockerfile If you are curious, cat the file to look at its contents: cat Dockerfile Sample Output: FROM node:8-alpine ENV NPM_CONFIG_LOGLEVEL warn RUN mkdir -p /usr/src/app WORKDIR /usr/src/app COPY package.json /usr/src/app/ RUN apk add --no-cache --virtual .build-deps make gcc g++ python \\ npm install --silent \\ npm install gulp -g ---unsafe-perm \\ apk del .build-deps .build-deps make gcc g++ python COPY . /usr/src/app/ EXPOSE 3001 CMD [ gulp , marbles_tls ] The above Dockerfile builds from an Alpine node image already out there in DockerHub. This is a bare bones Linux image of the Alpine distribution with node version 8 installed. Next, the NPM_CONFIG_LOGLEVEL for npm is globally set to warn so that npm will only print errors and warnings. ENV is used for this to persist this change as an environment variable in your finished container. Then, it uses RUN to run a command inside of the base node:8-alpine container to make a directory for the marbles application. WORKDIR makes this directory the current working directory. Moreover, COPY brings the package.json file (containing the names of the application's dependent node modules) into the containers /usr/src/app directory. The following RUN command uses apk (Alpine's package manager) to install a variety of pre-reqs to your npm install such as make, gcc and python, before running the actual npm install twice to install both the necessary node modules needed by the Marbles UI itself and gulp to start the marbles UI. Note that this is all done in one line with to make it occur in one layer. This way, at the end of the RUN you can use a delete command apk del and take the developer tools you no longer need out of your image. If you instead ran this as multiple commands, you would not be able to shrink your image size since previous layers can't be effectively deleted due to the layered file system. Finally, you copy the application itself and the connection profile materials into your working directory, document the port you will run marbles on ( 3001 ), and set a command for the container to run when it starts gulp marbles_tls . Now let's run docker build in the /home/marbles directory: docker build -t marbles-$team . NOTE: Please remember to not forget that pesky . Otherwise you will get an error saying \"docker build\" requires exactly 1 argument Sample Output: Sending build context to Docker daemon 261.9MB Step 1/9 : FROM node:8-alpine --- 66f08ecb7600 Step 2/9 : ENV NPM_CONFIG_LOGLEVEL warn --- Using cache --- 180c28267c41 Step 3/9 : RUN mkdir -p /usr/src/app --- Using cache --- f9615b4a1813 Step 4/9 : WORKDIR /usr/src/app --- Using cache --- e53d507c2bf9 .... .... lots more messages .... Successfully built 9b57c7c3e480 Successfully tagged marbles-team00:latest Now you should see this new image that you just built: docker images Sample Output:","title":"Build a docker image"},{"location":"connect-part2/#test-the-docker-image-locally","text":"Let's test the image that was just built, by running it locally: docker run -it --init -p 3001:3001/tcp --name marbles-$team marbles-$team Sample Output [20:57:50] Using gulpfile /usr/src/app/gulpfile.js [20:57:50] Starting 'env_tls'... [20:57:50] Finished 'env_tls' after 73 \u03bcs [20:57:50] Starting 'build-sass'... [20:57:50] Finished 'build-sass' after 7.48 ms [20:57:50] Starting 'watch-sass'... [20:57:50] Finished 'watch-sass' after 7.47 ms [20:57:50] Starting 'watch-server'... [20:57:50] Finished 'watch-server' after 2.55 ms [20:57:50] Starting 'server'... info: Checking connection profile is done info: Loaded config file /usr/src/app/config/marbles_tls.json info: Loaded connection profile file /usr/src/app/config/connection_profile_tls.json ... lots of output ... - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - debug: Detected that we have launched successfully before debug: Welcome back - Marbles is ready debug: Open your browser to http://localhost:3001 and login as admin - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - After you see the \"Open your browser to https://localhost:3001\" message, point your browser to the IP address of your Linux image, e.g., http://192.168.22.107:3001 and you will see the Marbles UI. Once you verify that the image works locally, it's time to stop the running container. Type Ctrl + C to exit out of the running container in the current terminal.","title":"Test the docker image locally"},{"location":"connect-part2/#push-image-to-the-icp-clusters-private-repo","text":"You will now tag the image you created with the private repo's host name and port number, followed by the namespace you are using, as follows. docker tag marbles-$team:latest wsc-ibp-icp-cluster.icp:8500/lab-test/marbles-$team:1.0 Log into the docker private registry using your teamNN id and credential, as follows: echo $credential | docker login wsc-ibp-icp-cluster.icp:8500 -u $team --password-stdin Sample Output: WARNING! Your password will be stored unencrypted in /root/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded Now push up the image using the tag you just created (again be mindful that the name pushed in the output will reflect your team name): docker push wsc-ibp-icp-cluster.icp:8500/lab-test/marbles-$team:1.0 Sample Output: The push refers to repository [wsc-ibp-icp-cluster.icp:8500/lab-test/marbles-team00] c8490573a0d8: Pushed 8e63f87572fb: Pushed a6a08bb664f7: Pushed 3a30ca7a2471: Pushed ccc0f617b78a: Pushed 1801fc515e2a: Pushed 1.0: digest: sha256:6a796e973817f714b64e767b3c35affd93a6dc5df7ef12ca872aca64d20a5155 size: 1997 Let's log in to the ICP Console for the first time and verify that your image got pushed up to the cluster's private docker registry. Point your browser to https://192.168.22.81:8443 . Accept that it's using a self-signed certificate. This should lead you to the sign in page. Log in with your team's credentials given to you at the beginning of the lab: you can find this by echoing the team and credential variables in your terminal: echo $team echo $credential . Your team is your username and your credential is your password. You can verify your image got pushed up by going to the hamburger menu on the top left corner and selecting Container Images and look for lab-test/marbles-teamNN. Note: you will have to go to the last page to see images under the namespace lab-test.","title":"Push image to the ICP Cluster's private repo"},{"location":"connect-part2/#create-a-kubernetes-deployment-and-service","text":"Log in to the ICP cluster with your team's ID and password: cloudctl login -a https://192.168.22.81:8443 -u $team -p $credential -n lab-test Sample Output: Targeted account wsc-ibp-icp-cluster Account (id-wsc-ibp-icp-cluster-account) Targeted namespace lab-test Configuring kubectl ... Property clusters.wsc-ibp-icp-cluster unset. Property users.wsc-ibp-icp-cluster-user unset. Property contexts.wsc-ibp-icp-cluster-context unset. Cluster wsc-ibp-icp-cluster set. User wsc-ibp-icp-cluster-user set. Context wsc-ibp-icp-cluster-context created. Switched to context wsc-ibp-icp-cluster-context . OK Configuring helm: /root/.helm OK Verify that your organization's Fabric pods are running. Note that you have a Fabric CA pod and one Fabric peer pod running. The environment variable $CORE_PEER_LOCALMSPID was set for you and it was set to your peer's MSPID. In this lab environment, your MSPID corresponds to your team number. i.e. team01 will be org1, team02 will be org2, etc. kubectl get pods | grep connectathon-$CORE_PEER_LOCALMSPID Sample Output: connectathon-org0-ca-fabric-ca-deployment-67cf7486dd-xgqkb 1/1 Running 0 7h connectathon-org0peer1-55fc894b9-fhz2f 2/2 Running 0 7h You should have a Kubernetes deployment yaml file in your /home/marbles directory called marbles-teamNN.yaml . Kubernetes objects are defined in yaml files and then created on or applied to a running cluster. You can create a Kubernetes resource from the ICP Console as well. But here you will do this via the command line tool kubectl which interacts with the Kubernetes API Server on the cluster. Now run the following command to create a marbles deployment yaml file that matches your team name. cat marbles-teamNN.yaml | sed -r 's/teamNN/'$team'/' marbles-$team.yaml You can cat the yaml file to see its contents: cat marbles-$team.yaml Sample Output: apiVersion: v1 kind: Service metadata: name: marbles-team00-svc spec: selector: app: marbles-team00 ports: - protocol: TCP port: 3001 targetPort: 3001 type: NodePort --- apiVersion: extensions/v1beta1 kind: Deployment metadata: name: marbles-team00-deploy labels: app: marbles-team00 spec: selector: matchLabels: app: marbles-team00 replicas: 1 template: metadata: labels: app: marbles-team00 spec: containers: - name: marbles-team00 image: wsc-ibp-icp-cluster.icp:8500/lab-test/marbles-team00:1.0 ports: - containerPort: 3001 imagePullPolicy: Always The important parts to point out in the yaml file are that it will create a Kubernetes service called marbles-team00-svc and that it is pointing to the marbles-team00 container. The service will be of type NodePort which means this service will be reachable outside of the cluster. The yaml file will also create a Kubernetes deployment that has one pod with one container that will be based off of the wsc-ibp-icp-cluster.icp:8500/lab-test/marbles-team00:1.0 image that you pushed to the private registry earlier.","title":"Create a Kubernetes deployment and service"},{"location":"connect-part2/#deploy-the-service-and-test-the-marbles-ui","text":"Now you are ready to create the Kubernetes resources. Run the following command: kubectl apply -f marbles-$team.yaml service/marbles-team00-svc created deployment.extensions/marbles-team00-deploy created The deployment will create one pod that has one container. A service is also created. Check that your pod is READY 1/1 and in Running status: kubectl get pods | grep marbles-$team marbles-team00-deploy-55649dbc5b-xf787 1/1 Running 0 35s","title":"Deploy the service and test the Marbles UI"},{"location":"connect-part2/#launch-the-marbles-service-and-test-the-marbles-ui","text":"Now, let's navigate through the ICP Console to your deployment. Point your browser to https://192.168.22.81:8443 . Accept that it's using a self signed certificate. This should lead you to the sign in page. Log in with your team's credentials given to you at the beginning of the lab. Go to the hamburger menu on the upper left corner, and select Workloads - Deployments . Find your team's deployment, it should be similar to marbles-team00-deploy but with your team name. Click on your deployment. You will be taken to the details page of your deployment. Upon further exploration you will see the deployment has one ReplicaSet, and one Pod. You can choose to click into either the ReplicaSet or Pod to get details about those two objects. Now click on the Launch button for your deployment. This will bring up the Marbles UI. At this point, depending on where the other classroom students are, you will see two or more organizations in the Marbles UI. Test out the application by transacting some marbles with your neighboring students. Enabling Story Mode in Settings will provide a step by step guided experience during each transaction. Congratulations! You've successfully created a container for the Marbles front end application, created a Kubernetes deployment for it, and deployed it in a IBM Cloud Private Kubernetes cluster.","title":"Launch the Marbles service and test the Marbles UI"},{"location":"hlf-home/","text":"Introduction to HLF lab -- Barry","title":"Introduction"},{"location":"hlf-home/#introduction-to-hlf-lab-barry","text":"","title":"Introduction to HLF lab -- Barry"},{"location":"hlf/","text":"Lab Content --- Barry","title":"Lab"},{"location":"hlf/#lab-content-barry","text":"","title":"Lab Content --- Barry"},{"location":"vscode-home/","text":"Visual Studio Code Overview Lab Note: This is a rough draft of a lab right now, which means grammar is optional now. I will fix this before the lab is ready for showtime :) Welcome to the Visual Studio Code (VSCode) Overview Lab. Throughout the course of this lab experience you will see how impactful the VSCode application and the IBM Blockchain Platform extension is when creating your smart contract (chaincode). The first part ( part 1 ) of this lab is very basic and is meant to walk you through getting started with the IBM Blockchain Platform extension. Part 2 follows a tutorial called Commercial Paper which will utilize the new application programming model in Hyperledger Fabric version 1.4 - which is the first long term support release of Hyperledger Fabric. Speaking of Hyperledger Fabric, we will be using a locally deployed Fabric whose components will run as Docker containers on your lab workstation. If you want to deploy your smart contract to a production environment, you can connect your IBM Blockchain Platform VSCode extension to the IBM Blockchain Platform in the public IBM Cloud. Furthermore, in the future you will be able to connect this to your IBM Blockchain Platform running in IBM Cloud Private. This will empower you and your company to write and test your smart contract within VSCode before you deploy it into production. We might incorporate this capability into the Blockchain Immersion Workshop later this year. To keep abreast of all the updates to the workshop, check the workshop\\'s github page for updates. We hope you enjoy this lab and please let us know if you run into an issue or think something doesn\\'t look right. In this lab we will be using the following versions: Visual Studio Code: 1.31.1 IBM Blockchain Platform Extension: 0.3.2 Hyperledger Fabric: v1.4 Special thanks to the following contributors to this lab: Matthew Golby-Kirk Matt Lucas Dennis Miller Jin VanStee Barry Silliman Garrett Woodworth Austin Grice Foreword: Why and the Benefits of VSCode and IBM Blockchain One of the hurdles in getting started with blockchain is the creation and testing of a smart contract or \\\"chaincode.\\\" Before, you had to package your smart contract, install it on your blockchain peer and then instantiate the chaincode on the channel. Furthermore, you had to submit transactions and hope that all of the lines of code you created simply worked. This hassle created a lot of questions. For example, does the smart contract even work before installing it on our blockchain network? How do we know that our smart contract is good for all the participants in our network? Does our smart contract have to abide by some legalities that have been set in place by the state or federal government? These questions, and many more, have to be answered when formulating our blockchain network and creating the smart contract. What if we could have an environment for testing our smart contract before it goes into production? The IBM Blockchain Platform extension has been created to assist users in developing, testing, and deploying smart contracts, enabling users to connect to a local Hyperledger Fabric development environment (what the lab today covers) to test smart contracts before deploying them into a production environment (IBM Blockchain Platform running in the cloud or within your own premises with IBM Blockchain Platform on IBM Cloud Private). Within VSCode, you can employ a series of commands to gain the maximum benefit of your blockchain network. Over the course of this lab, we will use quite a few of these commands. Below is a series of commands: Command Description Add Gateway Add a Hyperledger Fabric instance gateway Add Identity To Wallet Add an identity to be used when connecting to a Hyperledger Fabric gateway Connect Via Gateway Connect to a Hyperledger Fabric blockchain using a gateway Create Smart Contract Project Create a new JavaScript or TypeScript smart contract project Create Identity (register and enroll) Create, register and enroll a new identity from the runtime certificate authority Debug Debug a Smart Contract Delete Gateway Delete a Hyperledger Fabric instance gateway Delete Package Delete a smart contract package Disconnect From Gateway Disconnect from the blockchain gateway you're currently connected to Edit Gateway Edit connection profile or wallet used for connecting to a blockchain gateway Export Connection Details Export connection details for the a Hyperledger Fabric instance Export Package Export an already-packaged smart contract package to use outside VSCode Generate Smart Contract Tests Create a functional level test file for instantiated smart contracts Import Package Import a smart contract package Install Smart Contract Install a smart contract package onto a peer Instantiate Smart Contract Instantiate an installed smart contract package onto a channel Open Fabric Runtime Terminal Open a terminal with access to the Fabric runtime (peer CLI) Package a Smart Contract Project Create a new smart contract package from a project in the Explorer Refresh Fabric Gateways Refresh the Fabric Gateways view Refresh Smart Contract Packages Refresh the Smart Contract Packages view Restart Local Fabric Ops Refresh the Local Fabric Ops view Start Fabric Runtime Start a Hyperledger Fabric instance Stop Fabric Runtime Stop a Hyperledger Fabric instance Submit Transaction Submit a transaction to a smart contract Evaluate Transaction Evaluate a smart contract transaction Teardown Fabric Runtime Teardown the local_fabric runtime (hard reset) Toggle Development Mode Toggle the Hyperledger Fabric instance development mode Upgrade Smart Contract Upgrade an instantiated smart contract View Homepage View the extensions homepage As you can see, these commands can do a lot. With the IBM Blockchain Platform extension only being at version 0.3.2 (as of 3/12/2019), you can expect the list of commands and features to evolve. If you think there is a feature or enhancement that should be created, you can create an issue here: https://github.com/IBM-Blockchain/blockchain-vscode-extension/issues Equally, if you want to stay on top of all the releases of the extension and what updates came with each release, you can view that here: https://github.com/IBM-Blockchain/blockchain-vscode-extension/releases","title":"Introduction"},{"location":"vscode-home/#visual-studio-code-overview-lab","text":"Note: This is a rough draft of a lab right now, which means grammar is optional now. I will fix this before the lab is ready for showtime :) Welcome to the Visual Studio Code (VSCode) Overview Lab. Throughout the course of this lab experience you will see how impactful the VSCode application and the IBM Blockchain Platform extension is when creating your smart contract (chaincode). The first part ( part 1 ) of this lab is very basic and is meant to walk you through getting started with the IBM Blockchain Platform extension. Part 2 follows a tutorial called Commercial Paper which will utilize the new application programming model in Hyperledger Fabric version 1.4 - which is the first long term support release of Hyperledger Fabric. Speaking of Hyperledger Fabric, we will be using a locally deployed Fabric whose components will run as Docker containers on your lab workstation. If you want to deploy your smart contract to a production environment, you can connect your IBM Blockchain Platform VSCode extension to the IBM Blockchain Platform in the public IBM Cloud. Furthermore, in the future you will be able to connect this to your IBM Blockchain Platform running in IBM Cloud Private. This will empower you and your company to write and test your smart contract within VSCode before you deploy it into production. We might incorporate this capability into the Blockchain Immersion Workshop later this year. To keep abreast of all the updates to the workshop, check the workshop\\'s github page for updates. We hope you enjoy this lab and please let us know if you run into an issue or think something doesn\\'t look right. In this lab we will be using the following versions: Visual Studio Code: 1.31.1 IBM Blockchain Platform Extension: 0.3.2 Hyperledger Fabric: v1.4 Special thanks to the following contributors to this lab: Matthew Golby-Kirk Matt Lucas Dennis Miller Jin VanStee Barry Silliman Garrett Woodworth Austin Grice","title":"Visual Studio Code Overview Lab"},{"location":"vscode-home/#foreword-why-and-the-benefits-of-vscode-and-ibm-blockchain","text":"One of the hurdles in getting started with blockchain is the creation and testing of a smart contract or \\\"chaincode.\\\" Before, you had to package your smart contract, install it on your blockchain peer and then instantiate the chaincode on the channel. Furthermore, you had to submit transactions and hope that all of the lines of code you created simply worked. This hassle created a lot of questions. For example, does the smart contract even work before installing it on our blockchain network? How do we know that our smart contract is good for all the participants in our network? Does our smart contract have to abide by some legalities that have been set in place by the state or federal government? These questions, and many more, have to be answered when formulating our blockchain network and creating the smart contract. What if we could have an environment for testing our smart contract before it goes into production? The IBM Blockchain Platform extension has been created to assist users in developing, testing, and deploying smart contracts, enabling users to connect to a local Hyperledger Fabric development environment (what the lab today covers) to test smart contracts before deploying them into a production environment (IBM Blockchain Platform running in the cloud or within your own premises with IBM Blockchain Platform on IBM Cloud Private). Within VSCode, you can employ a series of commands to gain the maximum benefit of your blockchain network. Over the course of this lab, we will use quite a few of these commands. Below is a series of commands: Command Description Add Gateway Add a Hyperledger Fabric instance gateway Add Identity To Wallet Add an identity to be used when connecting to a Hyperledger Fabric gateway Connect Via Gateway Connect to a Hyperledger Fabric blockchain using a gateway Create Smart Contract Project Create a new JavaScript or TypeScript smart contract project Create Identity (register and enroll) Create, register and enroll a new identity from the runtime certificate authority Debug Debug a Smart Contract Delete Gateway Delete a Hyperledger Fabric instance gateway Delete Package Delete a smart contract package Disconnect From Gateway Disconnect from the blockchain gateway you're currently connected to Edit Gateway Edit connection profile or wallet used for connecting to a blockchain gateway Export Connection Details Export connection details for the a Hyperledger Fabric instance Export Package Export an already-packaged smart contract package to use outside VSCode Generate Smart Contract Tests Create a functional level test file for instantiated smart contracts Import Package Import a smart contract package Install Smart Contract Install a smart contract package onto a peer Instantiate Smart Contract Instantiate an installed smart contract package onto a channel Open Fabric Runtime Terminal Open a terminal with access to the Fabric runtime (peer CLI) Package a Smart Contract Project Create a new smart contract package from a project in the Explorer Refresh Fabric Gateways Refresh the Fabric Gateways view Refresh Smart Contract Packages Refresh the Smart Contract Packages view Restart Local Fabric Ops Refresh the Local Fabric Ops view Start Fabric Runtime Start a Hyperledger Fabric instance Stop Fabric Runtime Stop a Hyperledger Fabric instance Submit Transaction Submit a transaction to a smart contract Evaluate Transaction Evaluate a smart contract transaction Teardown Fabric Runtime Teardown the local_fabric runtime (hard reset) Toggle Development Mode Toggle the Hyperledger Fabric instance development mode Upgrade Smart Contract Upgrade an instantiated smart contract View Homepage View the extensions homepage As you can see, these commands can do a lot. With the IBM Blockchain Platform extension only being at version 0.3.2 (as of 3/12/2019), you can expect the list of commands and features to evolve. If you think there is a feature or enhancement that should be created, you can create an issue here: https://github.com/IBM-Blockchain/blockchain-vscode-extension/issues Equally, if you want to stay on top of all the releases of the extension and what updates came with each release, you can view that here: https://github.com/IBM-Blockchain/blockchain-vscode-extension/releases","title":"Foreword: Why and the Benefits of VSCode and IBM Blockchain"},{"location":"vscode-part1/","text":"Part 1: VSCode and the IBM Blockchain Extension Section 1: Overview In this part of the lab, we will guide you through the steps for generating, installing and instantiating a smart contract and then testing that smart contract to verify that it works. Before all of that, we will have you start up the local Hyperledger Fabric network so that we can build our smart contract on top of it. In this lab, we have you deploy to a local network that is running on your laptop, but you can also connect the IBM Blockchain Platform VSCode extension to either your IBM Blockchain Platform network running in the cloud or your IBM Blockchain Platform on IBM Cloud Private network on-premises. Below is a breakdown of Part 1 of our lab: Install and Start up a Blockchain Network: We must make sure that all levels of software (docker, node, npm, docker-compose and yo) are at the correct level before we start building our smart contract. Then, we will install the IBM Blockchain Platform extension that will allow us to create and develop our smart contract. Once we have done that, we will then start up the Hyperledger Fabric network, which will consist of a certificate authority (CA), orderer (solo - meant for dev/test), couchdb, ccenv (chaincode environment), and most importantly our peer. Create our Smart Contract: Now that we have a running Hyperledger Fabric blockchain network, we will create our smart contract. The smart contract will be very basic in nature, but we will explain what the contract is trying to accomplish before we go through some of the unique features that the extension can do for us and our smart contract. Package, Install and Instantiate our Smart Contract: Since we have an understanding of how our smart contract works, we will need to install (peer level command) it on our peer and then instantiate (channel level command) the installed smart contract on the channel. Once we have instantiated the smart contract, we will be able to submit transactions. Unit Test our Smart Contract: Once we have an instantiated smart contract on our channel, we will then test out the code to make sure that the contract will actually work when we submit transactions. This checks all the files within our smart contract and simulates all of our transactions. We will know we are cooking with gas when our test comes back successful. This test feature does not actually commit anything to the ledger or world state, but the last section of part 1 of this lab will submit tests that will commit data to the ledger. We will go into detail once we get to that point. Submit Transactions: What fun is it to have a working smart contract and have it instantiated across the channel, if we can\\'t submit transactions? In this section, we will actually submit transactions from the UI of VSCode. We will see data get committed to the ledger. Generate Smart Contract Test Client: In the final section of part 1, we will generate a test file that will test our smart contract, while submitting transactions to the ledger. We will view the docker logs of our running smart contract and see the transactions being added to the logs as well as the ledger. Section 2: Install and Start Up a Blockchain Network NOTE: For Part 1 of our lab, we will be using the terminal within VSCode. Do not execute the commands within the actual terminal application. You can enter them from the terminal application, but the instructions below will all be within the VSCode terminal. Part 2 of this lab, you will use the terminal application. 1. Open up your teminal and type in the following commands: tecadmin@ubuntubase:~$ node -v # We want Node to be v8.x or higher v8.11.3 tecadmin@ubuntubase:~$ npm -v # We want NPM to be v5.x or higher 5.6.0 tecadmin@ubuntubase:~$ yo --version # We want yo to be v2.x or higher 2.0.5 tecadmin@ubuntubase:~$ docker --version # We want Docker to be v17.06.2-ce or higher Docker version 17.06.2-ce, build cec0b72 tecadmin@ubuntubase:~$ docker-compose --version # We want Docker Compose to be v1.14.0 or higher docker-compose version 1.14.0, build c7bdf9e If you get a version that doesn\\'t support our qualifications, raise your hand and tell the instructor. 2. From the same command line, enter the following command: tecadmin@ubuntubase:~$ code This will start Visual Studio Code (VSCode) 3. From the user interface (UI) of VSCode, click on the 4th item down. This will allow you to search for available extensions to install and work from 4. In the search bar, type in blockchain and that should populate all the available extensions that deal with blockchain. The top choice should be the IBM Blockchain Platform extension. I promise we didn\\'t manipulate the algothrim to make it the top choice! If you see the IBM Blockchain Platform (IBP) extension, please click on install to install the extension. 5. Once you have successfully installed the extension, you should see an outline of a block just below the extensions button (approximately, the 6th button in VSCode). Go ahead and click on that button. Once you do, you\\'ll be welcomed with the IBM Blockchain Platform VSCode Homepage with the sides being divided into thirds. The IBM Blockchain Extension perspective is broken into thirds on the left. It is broken into Smart Contract Packages , Local Fabric Ops and Fabric Gateways . Smart Contract Packages is the home for all of our smart contracts that are packaged into .cds files. It packages these smart contracts based on the files that are in the Editor perspective. Now, just because there are packages here doesn\\'t mean that the smart contract is actually installed and instantiated on the channel. To do that we can go to the Local Fabric Ops pane. The Local Fabric Ops is a place where we can quickly gather and see all of our network information. If you untoggle the Smart Contracts flag, we can see all the contracts that are installed and instantiated. We can install and instantiate smart contracts from the Local Fabric Ops field. The Channel field shows all of the channels that are in our blockchain network. By default when we do Start Fabric Runtime in the next command, we\\'ll join a channel called mychannel . The Nodes field shows us all of the peers that are in our network. In the Organizations field, we\\'ll see all the organizations that are in the network. You can have an organization with no peers (nodes - in this case), but you can\\'t have a peer without an organization. An organization can have many peers. The last pane, Fabric Gateway , allows you to connect to a Hyperledger Fabric instance by an identity. In our case, it will be the Admin@org1.example.com of our local Fabric network. In Part 2 of this lab, we will create an identity and submit transactions from this new identity. 6. Hover your mouse over the Local Fabric Ops panel and we\\'ll see three dots - ... - and click on those dots. We\\'ll be presented with two options. Start Fabric Runtime and Teardown Fabric Runtime are those two options. We will want to click on Start Fabric Runtime in this case. This will start our local Hyperledger Fabric network. It will stand up a peer, certificate authority, orderer and a couchdb container. In addition to standing up these containers, it will join our peer to a channel called mychannel . The difference between Start Fabric Runtime and Teardown Fabric Runtime might be obvious, but Start Fabric Runtime grabs all of the Hyperledger Fabric images and starts them as containers. In addition, it builds the crypto material (certificates, public and private keys) and creates and joins a sample channel called mychannel . The other option, Teardown Fabric Runtime basically cleans up the network and removes all of the containers that Start Fabric Runtime builds. It does leave the Start Fabric Runtime docker images. To do a full cleanup, we will need to manually remove those images and containers. 7. How do we know if we have a successful blockchain network up and running? I\\'m glad you asked! We will see messages flooding the Output panel. We will want to see a message that resembles the one below: [2/20/2019 7:26:54 PM] [INFO] 2019-02-21 00:26:34.756 UTC [cli.common] readBlock - INFO 002 Received block: 0 [2/20/2019 7:26:54 PM] [INFO] 2019-02-21 00:26:34.930 UTC [channelCmd] InitCmdFactory - INFO 001 Endorser and orderer connections initialized [2/20/2019 7:26:55 PM] [INFO] 2019-02-21 00:26:35.458 UTC [channelCmd] executeJoin - INFO 002 Successfully submitted proposal to join channel 8. We can verify that everything is up and working by entering the following docker ps -a command that will print out all of our containers Section 3: Create our Smart Contract Now that we have a local running Hyperledger Fabric network, let\\'s create our Smart Contract that we will then install and instantiate onto our network. 1. We can do that by clicking on the gear icon in the bottom left and then clicking on Command Palette. This will give us the option to do a series of commands, some that are VSCode-related and some that are IBM Blockchain Platform-related. 2. You will notice a series of commands pop up. Go ahead and enter this command below into the search bar: IBM Blockchain Platform: Create Smart Contract Project This command will generate a skeleton smart contract for us. We will walk through all that it generates in a second. 3. We might get a message that says : Can this extension install missing npm packages before proceeding? Select yes if that message comes up. What it is installing is generator-fabric which is actually the generator that creates our skeleton smart contract. 4. We\\'ll then get a message that says : Chose smart contract language (esc to cancel) Choose JavaScript as our smart contract language of choice 5. Then will pop open a folder directory. Since we are starting a new project, let\\'s create a new folder for our smart contract. We can call this folder mycontract . Then click on open to allow VSCode to generate our smart contract in that folder. 6. We will get another pop-up asking : Choose how to open your new project We\\'ll want to select Add to workplace to add it to our VSCode 7. So we have created our smart contract, but gosh darnit, where is it? Well, let\\'s click on the Explorer in the top left. It\\'s the first botton on our left side panel 8. From the Explorer page, we will see all the open tabs we have open in VSCode and then all the smart contracts we created in our workspace, which should only be our [mycontract]{.title-ref}. 9. If you navigate within this UI to lib/my-contract.js and click on my-contract.js it will open that file within VSCode. From there we can inspect this file to see what our smart contract is capable of. In this case, we only have instantiate, transaction1 and transaction2 The main file in our smart contract is the my-contract.js file. It contains information as to the various transactions we can do as well as pulling in some predefined classes. Take a look at these lines in the code These couple of lines are vital to understand what is happening in our smart contract, below. The MyContract class contains the transaction definitions for mycontract - like instantiate, transaction1 and transaction2. It's these transactions that bring mycontract into existence. We'll examine these transactions soon, but for now notice how MyContract extends the Hyperledger Fabric Contract class which is the first line of code here. Our mycontract will use built-in features of these classes, such as automatic method invocation, a per-transaction context, transaction handlers, and class-shared state : const { Contract } = require('fabric-contract-api'); class MyContract extends Contract { You might have noticed an extra variable in each transaction definition -- ctx . It's called the transaction context, and it's always first. By default, it maintains both per-contract and per-transaction information relevant to transaction logic. We also see that transaction1 expects 1 argument in addition to ctx and transaction2 expects 2 different arugments in addition to ctx. The instantiate transaction expects an instantiate argument when actually instantiating this smart contract. You can see that below. In fact, we will instantiate in the next section : async instantiate(ctx) { console.info('instantiate'); } async transaction1(ctx, arg1) { console.info('transaction1', arg1); } async transaction2(ctx, arg1, arg2) { console.info('transaction2', arg1, arg2); } Section 4: Package, Install and Instantiate our Smart Contract In this section, we will package the smart contract we just created and then install and instantiate it onto our local Hyperledger Fabric network. We will realize how easy this is very soon. 1. In order to successfully install and instantiate a smart contract, we first need to package our contract up. We can do this by navigating to the IBP Extension (the block outline within our VSCode). 2. Once we are in the IBP extension, repeat the steps from section 2, step 1 by clicking on the gear in the bottom left and then selecting Command Palette . When it asks us for a command to run, type this in and press enter : IBM Blockchain Platform: Package a Smart Contract Project 3. Then the extension will create a package (a .cds file) with your smart contract name and then set its version to 0.0.1 - in this case mycontract@0.0.1 within the Smart Contract Packages side panel. 4. Now that we have our smart contract packaged up, untoggle the Smart Contracts option from within the Local Fabric Ops panel. There you will have the option to install and instantiate our smart contract package. Since we all are very smart, we know that we have to install before instantiating. So do that by clicking on + Install . 5. Installing chaincode is a peer level operation, so we will get a pop-up message asking which peer to install the chaincode on. Simply click on the peer it gives us, in this case it is peer0.org1.example.com . Then it will ask what to install. We will want to install mycontract@0.0.1 onto that peer. Press enter to begin this operation : Peer: peer0.org1.example.com Package: mycontract@0.0.1 6. Once we have it installed, we see the smart contract underneath the Installed section of the Local Fabric Ops panel. Make sure this is there before continuing. 7. To activate the chaincode on the peer, we have to instantiate the chaincode. To do this, simply click on the + Instantiate underneath the Instantiated option. Since instantiation is a channel operation, it will ask what channel to instantiate the chaincode on. You will want to instantiate on mychannel and then the mycontract@0.0.1 as the smart contract. Then it will ask what function we want to pass through. We want to enter instantiate here. Then for the last popup message, simply just press enter and it will begin to instantiate : Channel: mychannel Package: mycontract@0.0.1 # It should say installed to the right of the package Function: instantiate 8. We will know if we successfully instantiated the smart contract when it says so underneath the Instantiated section in the Local Fabric Ops panel. Section 5: Unit Test our Smart Contract In this section, we will test our smart contract to make sure the transactions will work the way they should. This test does not commit any data to the ledger, but rather tests to make sure they work in general. You can say this is a way to make sure your code is working the way you want it to. Later, we will test our transactions that commit data to the ledger. 1. Jump back up to our Explorer perspective at the top left of VSCode. From there naviagate to mycontract/test/my-contract.js and actually click on the my-contract.js file to open it in our VSCode. 2. Once you have the file open, right click on my-contract.js and then select Open in Terminal - this will open this file path directly to our terminal at the bottom of our VSCode 3. From there you will see your terminal go directly to our test folder. We can verify it by entering pwd and observing that we are in the path from where we created our smart contract folder back in section 2. Equally, we can do a ls -l command to verify that we see our my-contract.js file in there. 4. To test our smart contract code, simply enter npm test from the terminal in VSCode : tecadmin@ubuntubase:~/Desktop/mycontract/test$ npm test 5. From there, we will test our smart contract. If we are successful, we will see the following messages below : #instantiate instantiate \u2713 should work #transaction1 transaction1 hello \u2713 should work #transaction2 transaction2 hello world \u2713 should work 3 passing (25ms) Section 6: Submit Transactions In this section we will actually submit transactions after knowing that our smart contract is good to go! 1. Enter the following command to see all of our Docker containers running. Please do this from the command line in VSCode : tecadmin@ubuntubase:~/Desktop/mycontract/test$ docker ps -a You should see 5 containers running: peer, cerificate authority, orderer, couchdb and the chaincode container 2. To see the logs of our chaincode container enter the following commmand from your terminal in VSCode. NOTE: scroll to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/test$ docker logs -f fabricvscodelocalfabric-peer0.org1.example.com-mycontract-0.0.1 NOTE: The docker smart contract container name will be different if you named your smart contract something other than mycontract . 3. Navigate to the IBP Extension where we will utilize the third panel on the left - called Fabric Gateways 4. From here, click on Admin@org1.example.com and you will see all the channels in our network, in this case it is just mychannel . Untoggle on mychannel and then mycontract@0.0.1 to see all of our possible transactions: instantiate, transaction1, transaction2 5. Once you have untoggled all the required things, right click on transaction1 and select Submit Transaction . Again there will be a popup in the top middle of VSCode. When it asks for an argument, type in Hello and press enter : Arguments: \"Hello\" 6. Once the transaction has been submitted, you should see the transaction coming through the chaincode container. 7. Equally, you could check the logs of your peer by entering the following command within VSCode. I\\'m grep-ing these logs because there is a lot of output due to the signatures and messages a transaction sends, but I\\'m just wanting to see all the blocks : tecadmin@ubuntubase:~/Desktop/mycontract/test$ docker logs -f fabricvscodelocalfabric_peer0.org1.example.com | grep block 2019-02-21 20:02:09.209 UTC [endorser] callChaincode - INFO 093 [mychannel][c55f59cc] Entry chaincode: name:\"mycontract\" 2019-02-21 20:02:09.213 UTC [endorser] callChaincode - INFO 094 [mychannel][c55f59cc] Exit chaincode: name:\"mycontract\" (4ms) 2019-02-21 20:02:09.213 UTC [comm.grpc.server] 1 - INFO 095 unary call completed {\"grpc.start_time\": \"2019-02-21T20:02:09.207Z\", \"grpc.service\": \"protos.Endorser\", \"grpc.method\": \"ProcessProposal\", \"grpc.peer_address\": \"172.18.0.1:39474\", \"grpc.code\": \"OK\", \"grpc.call_duration\": \"6.3366ms\"} 2019-02-21 20:02:09.945 UTC [endorser] callChaincode - INFO 096 [mychannel][4bb0a014] Entry chaincode: name:\"mycontract\" 2019-02-21 20:02:09.948 UTC [endorser] callChaincode - INFO 097 [mychannel][4bb0a014] Exit chaincode: name:\"mycontract\" (3ms) 2019-02-21 20:02:09.949 UTC [comm.grpc.server] 1 - INFO 098 unary call completed {\"grpc.start_time\": \"2019-02-21T20:02:09.944Z\", \"grpc.service\": \"protos.Endorser\", \"grpc.method\": \"ProcessProposal\", \"grpc.peer_address\": \"172.18.0.1:39474\", \"grpc.code\": \"OK\", \"grpc.call_duration\": \"4.6952ms\"} 2019-02-21 20:09:52.334 UTC [endorser] callChaincode - INFO 099 [mychannel][3015cddc] Entry chaincode: name:\"mycontract\" 2019-02-21 20:09:52.340 UTC [endorser] callChaincode - INFO 09a [mychannel][3015cddc] Exit chaincode: name:\"mycontract\" (6ms) 2019-02-21 20:09:52.340 UTC [comm.grpc.server] 1 - INFO 09b unary call completed {\"grpc.start_time\": \"2019-02-21T20:09:52.333Z\", \"grpc.service\": \"protos.Endorser\", \"grpc.method\": \"ProcessProposal\", \"grpc.peer_address\": \"172.18.0.1:39474\", \"grpc.code\": \"OK\", \"grpc.call_duration\": \"7.2863ms\"} 2019-02-21 20:09:54.435 UTC [gossip.privdata] StoreBlock - INFO 09c [mychannel] Received block [2] from buffer 2019-02-21 20:09:54.437 UTC [committer.txvalidator] Validate - INFO 09d [mychannel] Validated block [2] in 1ms 2019-02-21 20:09:54.698 UTC [kvledger] CommitWithPvtData - INFO 09e [mychannel] Committed block [2] with 1 transaction(s) in 260ms (state_validation=69ms block_commit=92ms state_commit=76ms) Can you guess what Block: #1 was? 8. Feel free to pass in other transactions if you would like! Section 7: Generate Smart Contract Test Client In this section, we will generate a test client for our smart contract as well. This test is different from the unit tests in section 5 due to the fact that we will actually commit a transaction to the ledger with data. 1. From the IBP Extension and within the Fabric Gateways panel, right click on the smart contract - in this case mycontract@0.0.1 . Then click on Generate Smart Contract Tests . 2. When another pop-up opens, select JavaScript as the smart contract language. In VSCode you will see a new file open again. In my case it is called MyContract-mycontract@0.0.1.test.js : SmartContract Language: JavaScript File Name: MyContract-mycontract@0.0.1.test.js NOTE: If we see a little caution box appear in the bottom, right click on the X to close that message. That little booger of a message is as annoying as someone typing @here on a SLACK channel 3. Within that new file, scroll down to where you see transaction1 , in my case it is on line 71, but that could be different for you. A couple of lines down (on 83 for me) you\\'ll see ( NOTE: I realize the picture differs, but with each release of the IBM Blockchain extension, they might add or delete lines with certain files.) const args = ['']; . Now, place some text between those two apostrophes : const args = ['This is test transaction']; We could even do this if we wanted too : const args = [\"I'm going to brag to my friends about my blockchain skillz and not my spelling skills\"]; 4. Before we do anything further, please save (control + s) this file. Now that we have data to put onto the ledger, click on Run Test to submit the transaction and we should see this in the terminal. The Run Test button can be found by placing your cursor just above the transaction1 code. The output below will occur within your VSCode terminal : tecadmin@ubuntubase:~/Desktop/mycontract$ cd /home/tecadmin/Desktop/mycontract tecadmin@ubuntubase:~/Desktop/mycontract$ node_modules/.bin/mocha functionalTests/MyContract-mycontract@0.0.1.test.js --grep=\"transaction1\" MyContract-mycontract@0.0.1 2019-02-21T20:44:28.345Z - info: [TransactionEventHandler]: _strategySuccess: strategy success for transaction \"975a2eaf65a3d6866aeae6e102226c00fefa99395b660869c5fb30d0557e19e2\" \u2713 transaction1 (2453ms) 1 passing (3s) 5. Again, we can check the logs of our chaincode container within your VSCode terminal. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract$ docker logs -f fabricvscodelocalfabric-peer0.org1.example.com-mycontract-0.0.1 mycontract@0.0.1 start /usr/local/src fabric-chaincode-node start \"--peer.address\" \"peer0.org1.example.com:7052\" (node:18) DeprecationWarning: grpc.load: Use the @grpc/proto-loader module with grpc.loadPackageDefinition instead Command succeeded instantiate transaction1 Hello transaction1 6. If we wanted to check the logs of the peer, we can do that as well within your VSCode terminal. You\\'ll see similar output as what is below : tecadmin@ubuntubase:~/Desktop/mycontract$ docker logs -f fabricvscodelocalfabric_peer0.org1.example.com | grep block 2019-02-21 20:29:41.609 UTC [endorser] callChaincode - INFO 09f [mychannel][40cef608] Entry chaincode: name:\"mycontract\" 2019-02-21 20:29:41.615 UTC [endorser] callChaincode - INFO 0a0 [mychannel][40cef608] Exit chaincode: name:\"mycontract\" (7ms) 2019-02-21 20:29:41.616 UTC [comm.grpc.server] 1 - INFO 0a1 unary call completed {\"grpc.start_time\": \"2019-02-21T20:29:41.607Z\", \"grpc.service\": \"protos.Endorser\", \"grpc.method\": \"ProcessProposal\", \"grpc.peer_address\": \"172.18.0.1:39474\", \"grpc.code\": \"OK\", \"grpc.call_duration\": \"8.9484ms\"} 2019-02-21 20:44:16.003 UTC [endorser] callChaincode - INFO 0a2 [mychannel][34444572] Entry chaincode: name:\"cscc\" 2019-02-21 20:44:16.005 UTC [endorser] callChaincode - INFO 0a3 [mychannel][34444572] Exit chaincode: name:\"cscc\" (1ms) 2019-02-21 20:44:16.005 UTC [comm.grpc.server] 1 - INFO 0a4 unary call completed {\"grpc.start_time\": \"2019-02-21T20:44:16.003Z\", \"grpc.service\": \"protos.Endorser\", \"grpc.method\": \"ProcessProposal\", \"grpc.peer_address\": \"172.18.0.1:39632\", \"grpc.code\": \"OK\", \"grpc.call_duration\": \"1.9887ms\"} 2019-02-21 20:44:16.021 UTC [endorser] callChaincode - INFO 0a5 [mychannel][975a2eaf] Entry chaincode: name:\"mycontract\" 2019-02-21 20:44:16.046 UTC [endorser] callChaincode - INFO 0a6 [mychannel][975a2eaf] Exit chaincode: name:\"mycontract\" (25ms) 2019-02-21 20:44:16.046 UTC [comm.grpc.server] 1 - INFO 0a7 unary call completed {\"grpc.start_time\": \"2019-02-21T20:44:16.02Z\", \"grpc.service\": \"protos.Endorser\", \"grpc.method\": \"ProcessProposal\", \"grpc.peer_address\": \"172.18.0.1:39632\", \"grpc.code\": \"OK\", \"grpc.call_duration\": \"26.922ms\"} 2019-02-21 20:44:18.151 UTC [gossip.privdata] StoreBlock - INFO 0a8 [mychannel] Received block [3] from buffer 2019-02-21 20:44:18.154 UTC [committer.txvalidator] Validate - INFO 0a9 [mychannel] Validated block [3] in 2ms 2019-02-21 20:44:18.418 UTC [kvledger] CommitWithPvtData - INFO 0aa [mychannel] Committed block [3] with 1 transaction(s) in 264ms (state_validation=66ms block_commit=93ms state_commit=85ms) 7. To prepare for Part 2: Commercial Paper Tutorial close out of all the tabs in VSCode and exit all log messages in your terminal by pressing control + c . Additionally, you can switch back to the Explorer tab and close the mycontract folder by right clicking on it and selecting Remove Folder from Workplace .","title":"Part 1"},{"location":"vscode-part1/#part-1-vscode-and-the-ibm-blockchain-extension","text":"","title":"Part 1: VSCode and the IBM Blockchain Extension"},{"location":"vscode-part1/#section-1-overview","text":"In this part of the lab, we will guide you through the steps for generating, installing and instantiating a smart contract and then testing that smart contract to verify that it works. Before all of that, we will have you start up the local Hyperledger Fabric network so that we can build our smart contract on top of it. In this lab, we have you deploy to a local network that is running on your laptop, but you can also connect the IBM Blockchain Platform VSCode extension to either your IBM Blockchain Platform network running in the cloud or your IBM Blockchain Platform on IBM Cloud Private network on-premises. Below is a breakdown of Part 1 of our lab: Install and Start up a Blockchain Network: We must make sure that all levels of software (docker, node, npm, docker-compose and yo) are at the correct level before we start building our smart contract. Then, we will install the IBM Blockchain Platform extension that will allow us to create and develop our smart contract. Once we have done that, we will then start up the Hyperledger Fabric network, which will consist of a certificate authority (CA), orderer (solo - meant for dev/test), couchdb, ccenv (chaincode environment), and most importantly our peer. Create our Smart Contract: Now that we have a running Hyperledger Fabric blockchain network, we will create our smart contract. The smart contract will be very basic in nature, but we will explain what the contract is trying to accomplish before we go through some of the unique features that the extension can do for us and our smart contract. Package, Install and Instantiate our Smart Contract: Since we have an understanding of how our smart contract works, we will need to install (peer level command) it on our peer and then instantiate (channel level command) the installed smart contract on the channel. Once we have instantiated the smart contract, we will be able to submit transactions. Unit Test our Smart Contract: Once we have an instantiated smart contract on our channel, we will then test out the code to make sure that the contract will actually work when we submit transactions. This checks all the files within our smart contract and simulates all of our transactions. We will know we are cooking with gas when our test comes back successful. This test feature does not actually commit anything to the ledger or world state, but the last section of part 1 of this lab will submit tests that will commit data to the ledger. We will go into detail once we get to that point. Submit Transactions: What fun is it to have a working smart contract and have it instantiated across the channel, if we can\\'t submit transactions? In this section, we will actually submit transactions from the UI of VSCode. We will see data get committed to the ledger. Generate Smart Contract Test Client: In the final section of part 1, we will generate a test file that will test our smart contract, while submitting transactions to the ledger. We will view the docker logs of our running smart contract and see the transactions being added to the logs as well as the ledger.","title":"Section 1: Overview"},{"location":"vscode-part1/#section-2-install-and-start-up-a-blockchain-network","text":"NOTE: For Part 1 of our lab, we will be using the terminal within VSCode. Do not execute the commands within the actual terminal application. You can enter them from the terminal application, but the instructions below will all be within the VSCode terminal. Part 2 of this lab, you will use the terminal application. 1. Open up your teminal and type in the following commands: tecadmin@ubuntubase:~$ node -v # We want Node to be v8.x or higher v8.11.3 tecadmin@ubuntubase:~$ npm -v # We want NPM to be v5.x or higher 5.6.0 tecadmin@ubuntubase:~$ yo --version # We want yo to be v2.x or higher 2.0.5 tecadmin@ubuntubase:~$ docker --version # We want Docker to be v17.06.2-ce or higher Docker version 17.06.2-ce, build cec0b72 tecadmin@ubuntubase:~$ docker-compose --version # We want Docker Compose to be v1.14.0 or higher docker-compose version 1.14.0, build c7bdf9e If you get a version that doesn\\'t support our qualifications, raise your hand and tell the instructor. 2. From the same command line, enter the following command: tecadmin@ubuntubase:~$ code This will start Visual Studio Code (VSCode) 3. From the user interface (UI) of VSCode, click on the 4th item down. This will allow you to search for available extensions to install and work from 4. In the search bar, type in blockchain and that should populate all the available extensions that deal with blockchain. The top choice should be the IBM Blockchain Platform extension. I promise we didn\\'t manipulate the algothrim to make it the top choice! If you see the IBM Blockchain Platform (IBP) extension, please click on install to install the extension. 5. Once you have successfully installed the extension, you should see an outline of a block just below the extensions button (approximately, the 6th button in VSCode). Go ahead and click on that button. Once you do, you\\'ll be welcomed with the IBM Blockchain Platform VSCode Homepage with the sides being divided into thirds. The IBM Blockchain Extension perspective is broken into thirds on the left. It is broken into Smart Contract Packages , Local Fabric Ops and Fabric Gateways . Smart Contract Packages is the home for all of our smart contracts that are packaged into .cds files. It packages these smart contracts based on the files that are in the Editor perspective. Now, just because there are packages here doesn\\'t mean that the smart contract is actually installed and instantiated on the channel. To do that we can go to the Local Fabric Ops pane. The Local Fabric Ops is a place where we can quickly gather and see all of our network information. If you untoggle the Smart Contracts flag, we can see all the contracts that are installed and instantiated. We can install and instantiate smart contracts from the Local Fabric Ops field. The Channel field shows all of the channels that are in our blockchain network. By default when we do Start Fabric Runtime in the next command, we\\'ll join a channel called mychannel . The Nodes field shows us all of the peers that are in our network. In the Organizations field, we\\'ll see all the organizations that are in the network. You can have an organization with no peers (nodes - in this case), but you can\\'t have a peer without an organization. An organization can have many peers. The last pane, Fabric Gateway , allows you to connect to a Hyperledger Fabric instance by an identity. In our case, it will be the Admin@org1.example.com of our local Fabric network. In Part 2 of this lab, we will create an identity and submit transactions from this new identity. 6. Hover your mouse over the Local Fabric Ops panel and we\\'ll see three dots - ... - and click on those dots. We\\'ll be presented with two options. Start Fabric Runtime and Teardown Fabric Runtime are those two options. We will want to click on Start Fabric Runtime in this case. This will start our local Hyperledger Fabric network. It will stand up a peer, certificate authority, orderer and a couchdb container. In addition to standing up these containers, it will join our peer to a channel called mychannel . The difference between Start Fabric Runtime and Teardown Fabric Runtime might be obvious, but Start Fabric Runtime grabs all of the Hyperledger Fabric images and starts them as containers. In addition, it builds the crypto material (certificates, public and private keys) and creates and joins a sample channel called mychannel . The other option, Teardown Fabric Runtime basically cleans up the network and removes all of the containers that Start Fabric Runtime builds. It does leave the Start Fabric Runtime docker images. To do a full cleanup, we will need to manually remove those images and containers. 7. How do we know if we have a successful blockchain network up and running? I\\'m glad you asked! We will see messages flooding the Output panel. We will want to see a message that resembles the one below: [2/20/2019 7:26:54 PM] [INFO] 2019-02-21 00:26:34.756 UTC [cli.common] readBlock - INFO 002 Received block: 0 [2/20/2019 7:26:54 PM] [INFO] 2019-02-21 00:26:34.930 UTC [channelCmd] InitCmdFactory - INFO 001 Endorser and orderer connections initialized [2/20/2019 7:26:55 PM] [INFO] 2019-02-21 00:26:35.458 UTC [channelCmd] executeJoin - INFO 002 Successfully submitted proposal to join channel 8. We can verify that everything is up and working by entering the following docker ps -a command that will print out all of our containers","title":"Section 2: Install and Start Up a Blockchain Network"},{"location":"vscode-part1/#section-3-create-our-smart-contract","text":"Now that we have a local running Hyperledger Fabric network, let\\'s create our Smart Contract that we will then install and instantiate onto our network. 1. We can do that by clicking on the gear icon in the bottom left and then clicking on Command Palette. This will give us the option to do a series of commands, some that are VSCode-related and some that are IBM Blockchain Platform-related. 2. You will notice a series of commands pop up. Go ahead and enter this command below into the search bar: IBM Blockchain Platform: Create Smart Contract Project This command will generate a skeleton smart contract for us. We will walk through all that it generates in a second. 3. We might get a message that says : Can this extension install missing npm packages before proceeding? Select yes if that message comes up. What it is installing is generator-fabric which is actually the generator that creates our skeleton smart contract. 4. We\\'ll then get a message that says : Chose smart contract language (esc to cancel) Choose JavaScript as our smart contract language of choice 5. Then will pop open a folder directory. Since we are starting a new project, let\\'s create a new folder for our smart contract. We can call this folder mycontract . Then click on open to allow VSCode to generate our smart contract in that folder. 6. We will get another pop-up asking : Choose how to open your new project We\\'ll want to select Add to workplace to add it to our VSCode 7. So we have created our smart contract, but gosh darnit, where is it? Well, let\\'s click on the Explorer in the top left. It\\'s the first botton on our left side panel 8. From the Explorer page, we will see all the open tabs we have open in VSCode and then all the smart contracts we created in our workspace, which should only be our [mycontract]{.title-ref}. 9. If you navigate within this UI to lib/my-contract.js and click on my-contract.js it will open that file within VSCode. From there we can inspect this file to see what our smart contract is capable of. In this case, we only have instantiate, transaction1 and transaction2 The main file in our smart contract is the my-contract.js file. It contains information as to the various transactions we can do as well as pulling in some predefined classes. Take a look at these lines in the code These couple of lines are vital to understand what is happening in our smart contract, below. The MyContract class contains the transaction definitions for mycontract - like instantiate, transaction1 and transaction2. It's these transactions that bring mycontract into existence. We'll examine these transactions soon, but for now notice how MyContract extends the Hyperledger Fabric Contract class which is the first line of code here. Our mycontract will use built-in features of these classes, such as automatic method invocation, a per-transaction context, transaction handlers, and class-shared state : const { Contract } = require('fabric-contract-api'); class MyContract extends Contract { You might have noticed an extra variable in each transaction definition -- ctx . It's called the transaction context, and it's always first. By default, it maintains both per-contract and per-transaction information relevant to transaction logic. We also see that transaction1 expects 1 argument in addition to ctx and transaction2 expects 2 different arugments in addition to ctx. The instantiate transaction expects an instantiate argument when actually instantiating this smart contract. You can see that below. In fact, we will instantiate in the next section : async instantiate(ctx) { console.info('instantiate'); } async transaction1(ctx, arg1) { console.info('transaction1', arg1); } async transaction2(ctx, arg1, arg2) { console.info('transaction2', arg1, arg2); }","title":"Section 3: Create our Smart Contract"},{"location":"vscode-part1/#section-4-package-install-and-instantiate-our-smart-contract","text":"In this section, we will package the smart contract we just created and then install and instantiate it onto our local Hyperledger Fabric network. We will realize how easy this is very soon. 1. In order to successfully install and instantiate a smart contract, we first need to package our contract up. We can do this by navigating to the IBP Extension (the block outline within our VSCode). 2. Once we are in the IBP extension, repeat the steps from section 2, step 1 by clicking on the gear in the bottom left and then selecting Command Palette . When it asks us for a command to run, type this in and press enter : IBM Blockchain Platform: Package a Smart Contract Project 3. Then the extension will create a package (a .cds file) with your smart contract name and then set its version to 0.0.1 - in this case mycontract@0.0.1 within the Smart Contract Packages side panel. 4. Now that we have our smart contract packaged up, untoggle the Smart Contracts option from within the Local Fabric Ops panel. There you will have the option to install and instantiate our smart contract package. Since we all are very smart, we know that we have to install before instantiating. So do that by clicking on + Install . 5. Installing chaincode is a peer level operation, so we will get a pop-up message asking which peer to install the chaincode on. Simply click on the peer it gives us, in this case it is peer0.org1.example.com . Then it will ask what to install. We will want to install mycontract@0.0.1 onto that peer. Press enter to begin this operation : Peer: peer0.org1.example.com Package: mycontract@0.0.1 6. Once we have it installed, we see the smart contract underneath the Installed section of the Local Fabric Ops panel. Make sure this is there before continuing. 7. To activate the chaincode on the peer, we have to instantiate the chaincode. To do this, simply click on the + Instantiate underneath the Instantiated option. Since instantiation is a channel operation, it will ask what channel to instantiate the chaincode on. You will want to instantiate on mychannel and then the mycontract@0.0.1 as the smart contract. Then it will ask what function we want to pass through. We want to enter instantiate here. Then for the last popup message, simply just press enter and it will begin to instantiate : Channel: mychannel Package: mycontract@0.0.1 # It should say installed to the right of the package Function: instantiate 8. We will know if we successfully instantiated the smart contract when it says so underneath the Instantiated section in the Local Fabric Ops panel.","title":"Section 4: Package, Install and Instantiate our Smart Contract"},{"location":"vscode-part1/#section-5-unit-test-our-smart-contract","text":"In this section, we will test our smart contract to make sure the transactions will work the way they should. This test does not commit any data to the ledger, but rather tests to make sure they work in general. You can say this is a way to make sure your code is working the way you want it to. Later, we will test our transactions that commit data to the ledger. 1. Jump back up to our Explorer perspective at the top left of VSCode. From there naviagate to mycontract/test/my-contract.js and actually click on the my-contract.js file to open it in our VSCode. 2. Once you have the file open, right click on my-contract.js and then select Open in Terminal - this will open this file path directly to our terminal at the bottom of our VSCode 3. From there you will see your terminal go directly to our test folder. We can verify it by entering pwd and observing that we are in the path from where we created our smart contract folder back in section 2. Equally, we can do a ls -l command to verify that we see our my-contract.js file in there. 4. To test our smart contract code, simply enter npm test from the terminal in VSCode : tecadmin@ubuntubase:~/Desktop/mycontract/test$ npm test 5. From there, we will test our smart contract. If we are successful, we will see the following messages below : #instantiate instantiate \u2713 should work #transaction1 transaction1 hello \u2713 should work #transaction2 transaction2 hello world \u2713 should work 3 passing (25ms)","title":"Section 5: Unit Test our Smart Contract"},{"location":"vscode-part1/#section-6-submit-transactions","text":"In this section we will actually submit transactions after knowing that our smart contract is good to go! 1. Enter the following command to see all of our Docker containers running. Please do this from the command line in VSCode : tecadmin@ubuntubase:~/Desktop/mycontract/test$ docker ps -a You should see 5 containers running: peer, cerificate authority, orderer, couchdb and the chaincode container 2. To see the logs of our chaincode container enter the following commmand from your terminal in VSCode. NOTE: scroll to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/test$ docker logs -f fabricvscodelocalfabric-peer0.org1.example.com-mycontract-0.0.1 NOTE: The docker smart contract container name will be different if you named your smart contract something other than mycontract . 3. Navigate to the IBP Extension where we will utilize the third panel on the left - called Fabric Gateways 4. From here, click on Admin@org1.example.com and you will see all the channels in our network, in this case it is just mychannel . Untoggle on mychannel and then mycontract@0.0.1 to see all of our possible transactions: instantiate, transaction1, transaction2 5. Once you have untoggled all the required things, right click on transaction1 and select Submit Transaction . Again there will be a popup in the top middle of VSCode. When it asks for an argument, type in Hello and press enter : Arguments: \"Hello\" 6. Once the transaction has been submitted, you should see the transaction coming through the chaincode container. 7. Equally, you could check the logs of your peer by entering the following command within VSCode. I\\'m grep-ing these logs because there is a lot of output due to the signatures and messages a transaction sends, but I\\'m just wanting to see all the blocks : tecadmin@ubuntubase:~/Desktop/mycontract/test$ docker logs -f fabricvscodelocalfabric_peer0.org1.example.com | grep block 2019-02-21 20:02:09.209 UTC [endorser] callChaincode - INFO 093 [mychannel][c55f59cc] Entry chaincode: name:\"mycontract\" 2019-02-21 20:02:09.213 UTC [endorser] callChaincode - INFO 094 [mychannel][c55f59cc] Exit chaincode: name:\"mycontract\" (4ms) 2019-02-21 20:02:09.213 UTC [comm.grpc.server] 1 - INFO 095 unary call completed {\"grpc.start_time\": \"2019-02-21T20:02:09.207Z\", \"grpc.service\": \"protos.Endorser\", \"grpc.method\": \"ProcessProposal\", \"grpc.peer_address\": \"172.18.0.1:39474\", \"grpc.code\": \"OK\", \"grpc.call_duration\": \"6.3366ms\"} 2019-02-21 20:02:09.945 UTC [endorser] callChaincode - INFO 096 [mychannel][4bb0a014] Entry chaincode: name:\"mycontract\" 2019-02-21 20:02:09.948 UTC [endorser] callChaincode - INFO 097 [mychannel][4bb0a014] Exit chaincode: name:\"mycontract\" (3ms) 2019-02-21 20:02:09.949 UTC [comm.grpc.server] 1 - INFO 098 unary call completed {\"grpc.start_time\": \"2019-02-21T20:02:09.944Z\", \"grpc.service\": \"protos.Endorser\", \"grpc.method\": \"ProcessProposal\", \"grpc.peer_address\": \"172.18.0.1:39474\", \"grpc.code\": \"OK\", \"grpc.call_duration\": \"4.6952ms\"} 2019-02-21 20:09:52.334 UTC [endorser] callChaincode - INFO 099 [mychannel][3015cddc] Entry chaincode: name:\"mycontract\" 2019-02-21 20:09:52.340 UTC [endorser] callChaincode - INFO 09a [mychannel][3015cddc] Exit chaincode: name:\"mycontract\" (6ms) 2019-02-21 20:09:52.340 UTC [comm.grpc.server] 1 - INFO 09b unary call completed {\"grpc.start_time\": \"2019-02-21T20:09:52.333Z\", \"grpc.service\": \"protos.Endorser\", \"grpc.method\": \"ProcessProposal\", \"grpc.peer_address\": \"172.18.0.1:39474\", \"grpc.code\": \"OK\", \"grpc.call_duration\": \"7.2863ms\"} 2019-02-21 20:09:54.435 UTC [gossip.privdata] StoreBlock - INFO 09c [mychannel] Received block [2] from buffer 2019-02-21 20:09:54.437 UTC [committer.txvalidator] Validate - INFO 09d [mychannel] Validated block [2] in 1ms 2019-02-21 20:09:54.698 UTC [kvledger] CommitWithPvtData - INFO 09e [mychannel] Committed block [2] with 1 transaction(s) in 260ms (state_validation=69ms block_commit=92ms state_commit=76ms) Can you guess what Block: #1 was? 8. Feel free to pass in other transactions if you would like!","title":"Section 6: Submit Transactions"},{"location":"vscode-part1/#section-7-generate-smart-contract-test-client","text":"In this section, we will generate a test client for our smart contract as well. This test is different from the unit tests in section 5 due to the fact that we will actually commit a transaction to the ledger with data. 1. From the IBP Extension and within the Fabric Gateways panel, right click on the smart contract - in this case mycontract@0.0.1 . Then click on Generate Smart Contract Tests . 2. When another pop-up opens, select JavaScript as the smart contract language. In VSCode you will see a new file open again. In my case it is called MyContract-mycontract@0.0.1.test.js : SmartContract Language: JavaScript File Name: MyContract-mycontract@0.0.1.test.js NOTE: If we see a little caution box appear in the bottom, right click on the X to close that message. That little booger of a message is as annoying as someone typing @here on a SLACK channel 3. Within that new file, scroll down to where you see transaction1 , in my case it is on line 71, but that could be different for you. A couple of lines down (on 83 for me) you\\'ll see ( NOTE: I realize the picture differs, but with each release of the IBM Blockchain extension, they might add or delete lines with certain files.) const args = ['']; . Now, place some text between those two apostrophes : const args = ['This is test transaction']; We could even do this if we wanted too : const args = [\"I'm going to brag to my friends about my blockchain skillz and not my spelling skills\"]; 4. Before we do anything further, please save (control + s) this file. Now that we have data to put onto the ledger, click on Run Test to submit the transaction and we should see this in the terminal. The Run Test button can be found by placing your cursor just above the transaction1 code. The output below will occur within your VSCode terminal : tecadmin@ubuntubase:~/Desktop/mycontract$ cd /home/tecadmin/Desktop/mycontract tecadmin@ubuntubase:~/Desktop/mycontract$ node_modules/.bin/mocha functionalTests/MyContract-mycontract@0.0.1.test.js --grep=\"transaction1\" MyContract-mycontract@0.0.1 2019-02-21T20:44:28.345Z - info: [TransactionEventHandler]: _strategySuccess: strategy success for transaction \"975a2eaf65a3d6866aeae6e102226c00fefa99395b660869c5fb30d0557e19e2\" \u2713 transaction1 (2453ms) 1 passing (3s) 5. Again, we can check the logs of our chaincode container within your VSCode terminal. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract$ docker logs -f fabricvscodelocalfabric-peer0.org1.example.com-mycontract-0.0.1 mycontract@0.0.1 start /usr/local/src fabric-chaincode-node start \"--peer.address\" \"peer0.org1.example.com:7052\" (node:18) DeprecationWarning: grpc.load: Use the @grpc/proto-loader module with grpc.loadPackageDefinition instead Command succeeded instantiate transaction1 Hello transaction1 6. If we wanted to check the logs of the peer, we can do that as well within your VSCode terminal. You\\'ll see similar output as what is below : tecadmin@ubuntubase:~/Desktop/mycontract$ docker logs -f fabricvscodelocalfabric_peer0.org1.example.com | grep block 2019-02-21 20:29:41.609 UTC [endorser] callChaincode - INFO 09f [mychannel][40cef608] Entry chaincode: name:\"mycontract\" 2019-02-21 20:29:41.615 UTC [endorser] callChaincode - INFO 0a0 [mychannel][40cef608] Exit chaincode: name:\"mycontract\" (7ms) 2019-02-21 20:29:41.616 UTC [comm.grpc.server] 1 - INFO 0a1 unary call completed {\"grpc.start_time\": \"2019-02-21T20:29:41.607Z\", \"grpc.service\": \"protos.Endorser\", \"grpc.method\": \"ProcessProposal\", \"grpc.peer_address\": \"172.18.0.1:39474\", \"grpc.code\": \"OK\", \"grpc.call_duration\": \"8.9484ms\"} 2019-02-21 20:44:16.003 UTC [endorser] callChaincode - INFO 0a2 [mychannel][34444572] Entry chaincode: name:\"cscc\" 2019-02-21 20:44:16.005 UTC [endorser] callChaincode - INFO 0a3 [mychannel][34444572] Exit chaincode: name:\"cscc\" (1ms) 2019-02-21 20:44:16.005 UTC [comm.grpc.server] 1 - INFO 0a4 unary call completed {\"grpc.start_time\": \"2019-02-21T20:44:16.003Z\", \"grpc.service\": \"protos.Endorser\", \"grpc.method\": \"ProcessProposal\", \"grpc.peer_address\": \"172.18.0.1:39632\", \"grpc.code\": \"OK\", \"grpc.call_duration\": \"1.9887ms\"} 2019-02-21 20:44:16.021 UTC [endorser] callChaincode - INFO 0a5 [mychannel][975a2eaf] Entry chaincode: name:\"mycontract\" 2019-02-21 20:44:16.046 UTC [endorser] callChaincode - INFO 0a6 [mychannel][975a2eaf] Exit chaincode: name:\"mycontract\" (25ms) 2019-02-21 20:44:16.046 UTC [comm.grpc.server] 1 - INFO 0a7 unary call completed {\"grpc.start_time\": \"2019-02-21T20:44:16.02Z\", \"grpc.service\": \"protos.Endorser\", \"grpc.method\": \"ProcessProposal\", \"grpc.peer_address\": \"172.18.0.1:39632\", \"grpc.code\": \"OK\", \"grpc.call_duration\": \"26.922ms\"} 2019-02-21 20:44:18.151 UTC [gossip.privdata] StoreBlock - INFO 0a8 [mychannel] Received block [3] from buffer 2019-02-21 20:44:18.154 UTC [committer.txvalidator] Validate - INFO 0a9 [mychannel] Validated block [3] in 2ms 2019-02-21 20:44:18.418 UTC [kvledger] CommitWithPvtData - INFO 0aa [mychannel] Committed block [3] with 1 transaction(s) in 264ms (state_validation=66ms block_commit=93ms state_commit=85ms) 7. To prepare for Part 2: Commercial Paper Tutorial close out of all the tabs in VSCode and exit all log messages in your terminal by pressing control + c . Additionally, you can switch back to the Explorer tab and close the mycontract folder by right clicking on it and selecting Remove Folder from Workplace .","title":"Section 7: Generate Smart Contract Test Client"},{"location":"vscode-part2/","text":"Part 2: Commercial Paper Tutorial Section 1: Overview This tutorial is of a commercial paper (known as PaperNet ) trading network. Commercial paper itself is a type of unsecured lending in the form of a \"promissory note\". The papers are normally issued by large corporations to raise funds to meet short-term financial obligations at a fixed rate of interest. Once issued at a fixed price, for a fixed term, another company or bank will purchase them at a discount to the face value and when the term is up, they will be redeemed for their face value. As an example, if a paper was issued at a face value of 10M USD for a 6-month term at 2% interest then it could be bought for 9.8M USD (10M -- 2%) by another company or bank who are happy to bear the risk that the issuer will not default. Once the term is up, then the paper could be redeemed or sold back to the issuer for their full face value of 10M USD. Between buying and redemption, the paper can be bought or sold between different parties on a commercial paper market. These three key steps of issue, buy and redeem are the main transactions in a simplified commercial paper marketplace, which we will mirror in our lab. We will see a commercial paper issued by a company called MagnetoCorp and once issued on the commercial paper blockchain network, another company called DigiBank will first buy the paper and then redeem it. You'll act as a developer, end user, and administrator, each in different organizations, performing the following steps designed to help you understand what it's like to collaborate as two different organizations working independently, but according to mutually agreed rules in a Hyperledger Fabric network. Below is an image of our PaperNet network. For our lab, we will create Isabella who is with MagnetoCorp. Additionally, we will create Balaji who is with DigiBank. Isabella will issue a paper for the network. The paper will have an ID number, when it was issued, the maturity date, and the face value (\\$). Balaji, from DigiBank, will then buy the paper and then eventually redeem it. Below is the full breakdown of Part 2 of this lab: Setting the Stage: Based off of Part 1, we have started a blockchain network, created a smart contract, created and run tests and then submitted transactions. For Part 2, we need to create a couple more docker containers that will set us up for success for the rest of the lab. One of these containers will just monitor the docker network we are operating in. If you have no idea what a docker network is, I will explain later on. The other continer is fabric-tools , but it is named cliMagnetoCorp which will be how we install and instantiate the first time. Install and Instantiate Smart Contract: Now that we have those new docker containers up and running, we will enter our cliMagnetoCorp container and install and instantiate our smart contract. Since we are connected to the same running local Hyperledger Fabric network, we will see the smart contract show up in VSCode. Issue Identities: In this section, we will issue two identites. One is an end-user named Isabella with MagnetoCorp . She will invoke a transaction that will issue a paper. Then we will issue an identity for DigiBank named Balaji . Balaji will act as the adminstrator for Digibank and will buy and redeem the paper that Isabella issued. Balaji is important in this lab, as we will add a Fabric Gateway connection to connect to his perspective of the network. Upgrade Smart Contract: This section is the longest of the entire lab, but it really exemplifies the power of VSCode and the IBM Blockchain Platform extension. We will update our smart contract code to include one more transaction called getPaper . This transaction will allow us to see the current status of the paper, like who knows it, what is its status and how much is it worth. In addition to modifiying the code, we will update our smart contract so that the network is aware of the new smart contract. Submit Transactions: Now that we have added a transaction to our smart contract, we will then submit various transactions from many different places and perspectives. For example, we will issue a transaction from the command line interface as well as the VSCode user interface. We will also issue another paper from Isabella\\'s perspective and then invoke a series of transactions to buy and redeem the paper from Balaji. Lab Cleanup: This is the most bittersweet part of the entire lab. It means the lab is over and we have to clean up. If you have kids (I don\\'t), I\\'d imagine their faces are sad and full of despair when you (the guardian) tell them to clean up their mess. I\\'d also like to imagine your face is making a similar expression right now. It\\'s okay, more fun is going to be had soon - very soon! Section 2: Setting the Stage NOTE: There are two terminals we can operate in - the actual terminal application and the terminal found in VSCode. Unless I explicitly say, only use the terminal application - meaning do not use the terminal in VSCode. On the chance that we will use the terminal in VSCode, I will specify that. 1. Open your terminal and navigate to your Desktop and then clone the fabric-samples github repository tecadmin@ubuntubase:~/Desktop/mycontract$ ls -l total 0 drwxr-xr-x 16 tecadmin tecadmin 512 Feb 22 12:34 mycontract tecadmin@ubuntubase:~/Desktop/mycontract$ git clone https://github.com/hyperledger/fabric-samples.git Cloning into 'fabric-samples'... remote: Enumerating objects: 85, done. remote: Counting objects: 100% (85/85), done. remote: Compressing objects: 100% (71/71), done. remote: Total 2658 (delta 26), reused 71 (delta 13), pack-reused 2573 Receiving objects: 100% (2658/2658), 927.08 KiB | 0 bytes/s, done. Resolving deltas: 100% (1293/1293), done. tecadmin@ubuntubase:~/Desktop/mycontract$ ls -l total 0 drwxr-xr-x 22 tecadmin tecadmin 704 Feb 22 12:41 fabric-samples drwxr-xr-x 16 tecadmin tecadmin 512 Feb 22 12:34 mycontract 2. We need to know the Docker network that we are currently in so that we can modify some scripts, that will then create more Docker containers for us to use. Enter the command below to see all of our Docker networks tecadmin@ubuntubase:~/Desktop/mycontract$ docker network list NETWORK ID NAME DRIVER SCOPE ad2e1a3e2fc2 bridge bridge local 35837170ae5b fabricvscodelocalfabric_basic bridge local c5e0411b0d34 host host local 42ffa501f2f9 none null local 3. The network we are in is called fabricvscodelocalfabric_basic and we can verify that by doing the following command tecadmin@ubuntubase:~/Desktop/mycontract$ docker network inspect fabricvscodelocalfabric_basic That command will show you all the containers running in this network. In a nutshell, docker networks are natural ways to isolate containers from other containers or other networks. Having containers within a network allows them to immediately communicate with other containers in the network. 4. Within VSCode, go to the Editor perspective and click on File and select Add Folder to Workplace.. - This will allow us to work from an Untitled Workplace , but have the fabric-samples folder in there. 5. Within VSCode, navigate to the folder below within MagnetoCorp commercial paper - organizations - magenetocorp - configuration - cli You should see two files in there. One named docker-compose-yml and another named monitordocker.sh 6. Within the docker-compose.yml file, replace the net_basic with fabricvscodelocalfabric_basic on line 11 and save your file by pressing control + s 7. Now within the monitordocker.sh file, replace basicnetwork_basic with fabricvscodelocalfabric_basic on line 9 and again save by pressing control + s 8. Now from the terminal navigate to the cli directory within MagnetoCorp. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract$ cd fabric-samples/commercial-paper/organization/magnetocorp/configuration/cli/ tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/magnetocorp/configuration/cli/$ ls -l total 16 -rw-r--r-- 1 tecadmin tecadmin 1168 Feb 22 12:41 docker-compose.yml -rwxr-xr-x 1 tecadmin tecadmin 751 Feb 22 12:44 monitordocker.sh 9. Now that we have updated these files to represent the correct Docker network, go ahead run the monitordocker file with the name of our Docker network. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/magnetocorp/configuration/cli/$ ./monitordocker.sh fabricvscodelocalfabric_basic This command will pull down another container that just monitors all of the docker log output from the fabricvscodelocalfabric_basic network. I\\'m going off a hunch, but I think that\\'s why the file is called monitordocker.sh . We will see more messages coming very soon. 10. Since this terminal is occupied with log messages, let\\'s open another terminal tab. We can open a new tab by clicking on File and then either selecting New Tab . 11. When you opened a new tab, you should have been taken to the same file path that you were in on the previous tab. Now that we have a command line ready, go ahead and enter the command below that will create a cliMagnetoCorp container for our docker network to use. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/magnetocorp/configuration/cli/$ docker-compose -f docker-compose.yml up -d cliMagnetoCorp . . # We'll see docker messages . Status: Downloaded newer image for hyperledger/fabric-tools:latest Creating cliMagnetoCorp ... Creating cliMagnetoCorp ... done When we first install the smart contract, we will go through the cliMagnetoCorp container, which is our Administrator Console. This will allow use to use Fabric peer commands. Conveniently, the cliMagnetoCorp container is the hyperledger/fabric-tools image. 12. We can also do a docker ps -a command to see all of our docker containers. We should see two new containers - cliMagnetoCorp and logspout 13. Equally, we could do docker network inspect fabricvscodelocalfabric_basic to see all of our containers together in one network - and no, not in a blockchain network. They are, however, the components that make up our local blockchain network :) Section 3: Install and Instantiate Smart Contract Before we actually install the commercial paper smart contract, let\\'s actually open the file to see what the smart contract is trying to do. 1. From your explorer perspective, navigate from the fabric-samples folder to the contract folder of MagnetoCorp : fabric-samples - commercial-paper - organization - magnetocorp - contract Within the lib folder, you\\'ll see 3 javascript (.js) files in there. Click on the papercontract.js file, which will open it that file within VSCode Let\\'s dissect our papercontract.js file as it is our smart contract. We will only go over the issue transaction, but the other transactions follow pretty closely to this one Below, these 2 lines of code brings into scope two key Hyperledger Fabric classes that will be used extensively by the smart contract -- Contract and Context // Fabric smart contract classes const { Contract, Context } = require('fabric-contract-api'); Below, we define the smart contract class CommercialPaperContract based on the built-in Fabric Contract class. The methods which implement the key transactions to issue, buy and redeem commercial paper are defined within this class /** * Define commercial paper smart contract by extending Fabric Contract class * */ class CommercialPaperContract extends Contract { Below, this method defines the commercial paper issue transaction for commercial paper blockchain network. The parameters that are passed to this method will be used to create the new commercial paper. Locate and examine the buy and redeem transactions within the smart contract /** * Issue commercial paper * * @param {Context} ctx the transaction context * @param {String} issuer commercial paper issuer * @param {Integer} paperNumber paper number for this issuer * @param {String} issueDateTime paper issue date * @param {String} maturityDateTime paper maturity date * @param {Integer} faceValue face value of paper */ async issue(ctx, issuer, paperNumber, issueDateTime, maturityDateTime, faceValue) { Within the issue transaction, this statement creates a new commercial paper in memory using the CommercialPaper class with the supplied transaction inputs. Examine the buy and redeem transactions to see how they similarly use this class below // create an instance of the paper let paper = CommercialPaper.createInstance(issuer, paperNumber, issueDateTime, maturityDateTime, faceValue); Below, this statement adds the new commercial paper to the ledger using ctx.paperList, an instance of a PaperList class that was created when the smart contract context CommercialPaperContext was initialized. Again, examine the buy and redeem methods to see how they use this class // Add the paper to the list of all similar commercial papers in the ledger world state await ctx.paperList.addPaper(paper); Below you will find that this statement returns a binary buffer as response from the issue transaction for processing by the caller of the smart contract // Must return a serialized paper to caller of smart contract return paper.toBuffer(); 2. Now that we have an understanding of the smart contract, let\\'s actually install it on our peer through our terminal. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/magnetocorp/configuration/cli/$ docker exec cliMagnetoCorp peer chaincode install -n papercontract -v 0 -p /opt/gopath/src/github.com/contract -l node 2019-02-22 17:48:23.721 UTC [chaincodeCmd] checkChaincodeCmdParams - INFO 001 Using default escc 2019-02-22 17:48:23.721 UTC [chaincodeCmd] checkChaincodeCmdParams - INFO 002 Using default vscc 2019-02-22 17:48:23.862 UTC [chaincodeCmd] install - INFO 003 Installed remotely response: status:200 payload:\"OK\" A message saying 200 is a great sign to see. If you notice, we are not in the contract folder of our command line interface. Instead, we are entering the cliMagnetoCorp docker container with docker exec cliMagnetoCorp and navigating to the /opt/gopath/src/github.com/contract file path within our container to grab the files we need to install the smart contract. The -n papercontract flag names our smart contract papercontract . The -v 0 gives our smart contract a version of 0. Finally, the -l node tells us that the language of our smart contract is nodejs. The picture below goes into detail, visually, as to how we are actually installing a copy of the commercial paper smart contract on our peer. 3. Since our network is connected to our VSCode instance, you can refresh the Local Fabric Ops panel in VSCode under the IBM Blockchain extension. The refresh button is revealed when you hover your mouse over the Local Fabric Ops panel 4. Since we have installed the smart contract, we should actually make it active by instantiating it. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/magnetocorp/configuration/cli/$ docker exec cliMagnetoCorp peer chaincode instantiate -n papercontract -v 0 -l node -c '{\"Args\":[\"org.papernet.commercialpaper:instantiate\"]}' -C mychannel -P \"\" 2019-02-22 17:50:34.673 UTC [chaincodeCmd] InitCmdFactory - INFO 001 Retrieved channel (mychannel) orderer endpoint: orderer.example.com:7050 2019-02-22 17:50:34.675 UTC [chaincodeCmd] checkChaincodeCmdParams - INFO 002 Using default escc 2019-02-22 17:50:34.675 UTC [chaincodeCmd] checkChaincodeCmdParams - INFO 003 Using default vscc tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/magnetocorp/configuration/cli/$ As you can see in the image below, we are instantiating a copy of the commercial paper smart contract on our MagnetoCorp peer. Similar to the installation of the smart contract, the instantiation goes into the cliMagnetoCorp container. After successfully instantiating the smart contract, there will be a commercial paper smart contract docker image and container. 5. You will know our instantiate command worked when we simply get our command prompt back. You can really verify it worked by going back to the VSCode and refreshing the Local Fabric Ops panel and you should see it under the instantiate section. Section 4: Issue Identities Now that we have a ready-to-use smart contract, let\\'s issue some identities so that those identities can invoke and query transactions. 1. You should be within the cli folder of the MagnetoCorp folder. You can confirm this by issuing the command below. NOTE: scroll over to see the entire command below tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/magnetocorp/configuration/cli/$ pwd /Users/home/Desktop/fabric-samples/commercial-paper/organization/magnetocorp/configuration/cli This is a good sign. Issue the following command below to get to the application folder within MagnetoCorp. NOTE: scroll over to see the entire command below tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/magnetocorp/configuration/cli/$ cd ../../application/ tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/magnetocorp/application$ 2. From the Explorer perspective within VSCode, navigate to the same folder. That is, the application folder within MagnetoCorp . You should see 4 files in there: .eslintrc.js, addToWallet.js, issue.js , and package.json 3. Click on issue.js , which will open the file within VSCode. Let\\'s discuss what the file is trying to do. Below we bring in two key Hyperledger Fabric SDK classes into scope -- Wallet and Gateway . Because Isabella's X.509 certificate is in the local file system, the application uses FileSystemWallet // Bring key classes into scope, most importantly Fabric SDK network class const { FileSystemWallet, Gateway } = require('fabric-network'); Below, this statement identifies that the application will use Isabella\\'s wallet when it connects to the blockchain network channel. The application will select a particular identity within Isabell\\'s wallet. (The wallet must have been loaded with Isabella's X.509 certificate -- that's what addToWallet.js does.) // A wallet stores a collection of identities for use const wallet = new FileSystemWallet('../identity/user/isabella/wallet'); This line of code, below, connects to the network using the gateway identified by connectionProfile , using the identity referred to in ConnectionOptions . See how ../gateway/networkConnection.yaml and User1@org1.example.com are used for these values respectively // Connect to gateway using application specified parameters await gateway.connect(connectionProfile, connectionOptions); Below in the couple lines of code, connects the application to the network channel mychannel , where the papercontract was previously instantiated. If you had a different channel name, you would have to modify this line of code // Access commercial paper network const network = await gateway.getNetwork('mychannel'); Below, this statement gives the application addressability to the smart contract defined by the namespace org.papernet.commercialpaper within papercontract. Once an application has issued getContract, it can submit any transaction implemented within it // Get addressability to commercial paper contract const contract = await network.getContract('papercontract', 'org.papernet.comm...'); Below, these lines of code submits a transaction to the network using the issue transaction defined within the smart contract. MagnetoCorp, 00001 are the values to be used by the issue transaction to create a new commercial paper // issue commercial paper const issueResponse = await contract.submitTransaction('issue','MagnetoCorp', '00001', '2020-05-31', '2020-11-30','5000000'); This statement, below, processes the response from the issue transaction. The response needs to be deserialized from a buffer into paper, a CommercialPaper object which can be interpreted correctly by the application // process response let paper = CommercialPaper.fromBuffer(issueResponse); 4. Since we know our issue.js file is looking at the ../gateway/networkConnection.yaml , we need to modify this file to represent our connection profile. We can do this by opening the networkConnection.yaml file in VSCode and then modifying the ports of our Orderer (line 91), Peer (line 105) and CA (117). You can find these ports by doing the following command from your terminal application. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/magnetocorp/application$ docker ps -a Once you have modified the file, please save it (control + s) . 5. Enter the following command below to install the needed packages from the package.json file. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/magnetocorp/application$ npm install . . # A bunch of output, with some of the output repeating . node-pre-gyp WARN Using request for node-pre-gyp https download [grpc] Success: \"/home/tecadmin/Desktop/fabric-samples/commercial-paper/organization/magnetocorp/application/node_modules/grpc/src/node/extension_binary/node-v57-darwin-x64-unknown/grpc_node.node\" is installed via remote npm notice created a lockfile as package-lock.json. You should commit this file. npm WARN nodejs@1.0.0 No description npm WARN nodejs@1.0.0 No repository field. added 318 packages in 36.994s 6. Since we are in our command line, let\\'s issue the following command that will create Isabella. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/magnetocorp/application$ node addToWallet.js done 7. We will know it worked if we can execute the following command below successfully. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/magnetocorp/application$ ls -l ../identity/user/isabella/wallet/ total 0 drwxr-xr-x 5 tecadmin tecadmin 160 Feb 22 12:53 User1@org1.example.com tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/magnetocorp/application$ ls -l ../identity/user/isabella/wallet/User1\\@org1.example.com/ total 24 -rw-r--r-- 1 tecadmin tecadmin 1037 Feb 22 12:53 User1@org1.example.com -rw-r--r-- 1 tecadmin tecadmin 246 Feb 22 12:53 c75bd6911aca808941c3557ee7c97e90f3952e379497dc55eb903f31b50abc83-priv -rw-r--r-- 1 tecadmin tecadmin 182 Feb 22 12:53 c75bd6911aca808941c3557ee7c97e90f3952e379497dc55eb903f31b50abc83-pub Keys are vital to understanding how transactions and identity work within a blockchain network. Below is a break down of the keys and certificate used in this example a private key c75bd6911a...-priv used to sign transactions on Isabella's behalf, but not distributed outside of her immediate control a public key c75bd6911a...-pub which is cryptographically linked to Isabella's private key. This is wholly contained within Isabella's X.509 certificate a certificate User1@org.example.com which contains Isabella's public key and other X.509 attributes added by the Certificate Authority at certificate creation. This certificate is distributed to the network so that different actors at different times can cryptographically verify information signed by Isabella's private key 8. Now that we have Isabella from MagnetoCorp, let\\'s pass through the issue transaction from our terminal. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/magnetocorp/application$ node issue.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper issue transaction. 2019-02-22T17:55:20.631Z - info: [TransactionEventHandler]: _strategySuccess: strategy success for transaction \"f8e124886d6cb84434cb6a996f4889145c0541199c88bab7d4d85ae41266e51e\" Process issue transaction response. MagnetoCorp commercial paper : 00001 successfully issued for value 5000000 Transaction complete. Disconnect from Fabric gateway. Issue program complete. This successfully committed a transaction to the ledger. See how it outputted a transaction hash for us. As you can see in the image below, we are using the certificate belonging to Isabella to submit our paper issue transaction. Once we verify that Isabella can submit a transaction (via her certificate), the gateway allows the application to focus on transaction generation, submission and response. It coordinates the transaction proposal, ordering and notification processing between the different network components. 9. Since we have created an identity for MagnetoCorp, let\\'s also create Balaji from DigiBank. To do so, we will need a third command line tab. We can add another command line tab by clicking on File - New Tab . This will create a new tab in the terminal from the exact folder directory we were in from our second command line tab. This third tab will act as DigiBank. 10. We now need to switch to a new directory, specifically the application folder of DigiBank. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/magnetocorp/application$ cd ../../digibank/application/ tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/digibank/application$ 11. Navigate to the the application folder of DigiBank in the editior perspective in VSCode : fabric-samples - commercial paper - organization - digibank - application You should see 5 files here: .eslintrc.js, addtowallet.js, buy.js, redeem.js and package.json 12. Go ahead and click on buy.js and scroll through the file. You will notice on line 40 that it is looking at the ../gateway/networkConnection.yaml file. We need to modify the networkConnection.yaml file to represent our network - very similar to step 4 of this section. 13. We need to modify the ports of our Orderer (line 91), Peer (line 105) and CA (117). We can find these ports by doing the following command from our terminal. If you are confused as to where to modify your port numbers, look at the picture on step 4 to get a sense as to where we are grabbing our ports from. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/digibank/application$ docker ps -a Once we have modified the file, please save it (control + s). NOTE: If you don\\'t do this step, the rest of the lab will not work. 14. Back in our terminal and using our DigiBank tab, we can run the next command to install some required packages. NOTE: You will have to scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/digibank/application$ npm install . . . node-pre-gyp WARN Using request for node-pre-gyp https download [grpc] Success: \"/home/tecadmin/Desktop/fabric-samples/commercial-paper/organization/digibank/application/node_modules/grpc/src/node/extension_binary/node-v57-darwin-x64-unknown/grpc_node.node\" is installed via remote npm notice created a lockfile as package-lock.json. You should commit this file. npm WARN nodejs@1.0.0 No description npm WARN nodejs@1.0.0 No repository field. added 318 packages in 27.138s 15. Now, let\\'s add an Balaji from DigiBank . NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/digibank/application$ node addToWallet.js done 16. We can confirm that we actually created an identity by viewing its public/private key below. NOTE: scroll over to see the entire command : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/digibank/application$ ls -l ../identity/user/balaji/wallet/ total 0 drwxr-xr-x 5 tecadmin tecadmin 160 Feb 22 12:57 Admin@org1.example.com tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/digibank/application$ ls -l ../identity/user/balaji/wallet/Admin\\@org1.example.com/ total 24 -rw-r--r-- 1 tecadmin tecadmin 1033 Feb 22 12:57 Admin@org1.example.com -rw-r--r-- 1 tecadmin tecadmin 246 Feb 22 12:57 cd96d5260ad4757551ed4a5a991e62130f8008a0bf996e4e4b84cd097a747fec-priv -rw-r--r-- 1 tecadmin tecadmin 182 Feb 22 12:57 cd96d5260ad4757551ed4a5a991e62130f8008a0bf996e4e4b84cd097a747fec-pub In the next section, we will actually upgrade our smart contract before submitting transactions. We are upgrading our smart contract because we can add in a query to get the status of our paper. Based on the picture below, we now have 2 participants in this network. Obviously, this is MagnetoCorp (Isabella) and DigiBank (Balaji). Both participants are allowed to interact with the commercial paper blockchain network through their application. Section 5: Upgrade Smart Contract 1. From our Explorer perspective, navigate to the contract/lib folder of DigiBank : fabric-samples - commercial-paper - organization - digibank - contract - lib 2. Within the papercontract.js file, scroll down to line number 54 and enter the following lines of code below : /** * Get commercial paper * @param {Context} ctx the transaction context * @param {String} issuer commercial paper issuer * @param {Integer} paperNumber paper number for this issuer */ async getPaper(ctx, issuer, paperNumber) { try { console.log(\"getPaper for: \" + issuer + \" \" + paperNumber); let paperKey = CommercialPaper.makeKey([issuer, paperNumber]); let paper = await ctx.paperList.getPaper(paperKey); return paper.toBuffer(); } catch(e) { throw new Error('Paper does not exist' + issuer + paperNumber); } } 3. From the terminal in our digibank tab , add a file below that will execute a query that we just added to our smart contract. NOTE: scroll over to see the entire command and file below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/digibank/application$ touch getPaper.js tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/digibank/application$ vi getPaper.js --- type the letter \"i\" to go into insert mode and paste in the following lines of code below --- /* SPDX-License-Identifier: Apache-2.0 */ /* * This application has 6 basic steps: * 1. Select an identity from a wallet * 2. Connect to network gateway * 3. Access PaperNet network * 4. Construct request to issue commercial paper * 5. Submit transaction * 6. Process response */ 'use strict'; // Bring key classes into scope, most importantly Fabric SDK network class const fs = require('fs'); const yaml = require('js-yaml'); const { FileSystemWallet, Gateway } = require('fabric-network'); const CommercialPaper = require('../contract/lib/paper.js'); // A wallet stores a collection of identities for use //const wallet = new FileSystemWallet('../../../connection-local-fabric'); const wallet = new FileSystemWallet('../identity/user/balaji/wallet'); // Main program function async function main() { // A gateway defines the peers used to access Fabric networks const gateway = new Gateway(); // Main try/catch block try { // Specify userName for network access // const userName = 'isabella.issuer@magnetocorp.com'; const userName = 'Admin@org1.example.com'; // Load connection profile; will be used to locate a gateway let connectionProfile = yaml.safeLoad(fs.readFileSync('../gateway/networkConnection.yaml', 'utf8')); // Set connection options; identity and wallet let connectionOptions = { identity: userName, wallet: wallet, discovery: { enabled: false, asLocalhost: true } }; // Connect to gateway using application specified parameters console.log('Connect to Fabric gateway.'); await gateway.connect(connectionProfile, connectionOptions); // Access PaperNet network console.log('Use network channel: mychannel.'); const network = await gateway.getNetwork('mychannel'); // Get addressability to commercial paper contract console.log('Use org.papernet.commercialpaper smart contract.'); const contract = await network.getContract('papercontract', 'org.papernet.commercialpaper'); // get commercial paper console.log('Submit commercial paper getPaper transaction.'); const getPaperResponse = await contract.evaluateTransaction('getPaper', 'MagnetoCorp', '00001'); // process response console.log('Process getPaper transaction response.'); let paper = CommercialPaper.fromBuffer(getPaperResponse); let paperState = \"Unknown\"; if (paper.isIssued()) { paperState = \"ISSUED\"; } else if (paper.isTrading()) { paperState = \"TRADING\"; } else if (paper.isRedeemed()) { paperState = \"REDEEMED\"; } console.log(` +--------- Paper Retrieved ---------+ `); console.log(` | Paper number: \"${paper.paperNumber}\"`); console.log(` | Paper is owned by: \"${paper.owner}\"`); console.log(` | Paper is currently: \"${paperState}\"`); console.log(` | Paper face value: \"${paper.faceValue}\"`); console.log(` | Paper is issued by: \"${paper.issuer}\"`); console.log(` | Paper issue on: \"${paper.issueDateTime}\"`); console.log(` | Paper matures on: \"${paper.maturityDateTime}\"`); console.log(` +-----------------------------------+ `); console.log('Transaction complete.'); } catch (error) { console.log(`Error processing transaction. ${error}`); console.log(error.stack); } finally { // Disconnect from the gateway console.log('Disconnect from Fabric gateway.') gateway.disconnect(); } } main().then(() = { console.log('getPaper program complete.'); }).catch((e) = { console.log('getPaper program exception.'); console.log(e); console.log(e.stack); process.exit(-1); }); --- To get out of vi, hit the \"ESC\" button. Then type in \":wq\" and then press enter to save the file Who knew you would learn VSCode and vi ! Send your hate mail to :) 4. We now have a new file ( getPaper.js ) and then it is in our papercontract.js smart contract. This doesn\\'t mean we can execute a getPaper query because, if you remember, we have to install and instantiate this update onto our peer. Then - and only then - can we actually submit the getPaper query. The next few steps will walk us through how to do that. It would be helpful to understand what we just added to our soon-to-be-updated smart contract. The getPaper query is being submitted by Balaji from DigiBank and it allows him to get the current status of the paper within the network. For example, it prints out the paper\\'s identification number, paper\\'s cost, paper\\'s state (trading, redeemed, issued), paper\\'s issue date and a few other key details. Here is a further breakdown of the query Below, this statement brings two key Hyperledger Fabric SDK classes into scope -- Wallet and Gateway. Because Balaji\u2019s X.509 certificate is in the local file system, the application uses FileSystemWallet // Bring key classes into scope, most importantly Fabric SDK network class const { FileSystemWallet, Gateway } = require('fabric-network'); Below, this statement identifies that the application will use Balaji's wallet when it connects to the blockchain network channel. The application will select a particular identity within Balaji's wallet. (The wallet must have been loaded with Balaji's X.509 certificate -- that's what addToWallet.js does.) // A wallet stores a collection of identities for use const wallet = new FileSystemWallet('../identity/user/balaji/wallet'); Below, this line of code connects to the network using the gateway identified by connectionProfile, using the identity referred to in connectionOptions. See how ../gateway/networkConnection.yaml and Admin@org1.example.com are used for these values respectively // Connect to gateway using application specified parameters await gateway.connect(connectionProfile, connectionOptions); Below, this connects the application to the network channel mychannel, where the papercontract was previously instantiated. If you had a different channel name, you would have to modify this line of code // Access commercial paper network const network = await gateway.getNetwork('mychannel'); Below, this statement gives the application addressability to smart contract defined by the namespace org.papernet.commercialpaper within papercontract. Once an application has issued getContract, it can submit any transaction/query implemented within it // Get addressability to commercial paper contract const contract = await network.getContract('papercontract','org.papernet.commercialpaper'); This series of log output is what the query prints out for us. Based on the defined variables in the papercontract.js we are able to query for pretty specific bits of data to get an overview of our paper. You can look above and see how we are grabbing our paperState console.log(` +--------- Paper Retrieved ---------+ `); console.log(` | Paper number: \"${paper.paperNumber}\"`); console.log(` | Paper is owned by: \"${paper.owner}\"`); console.log(` | Paper is currently: \"${paperState}\"`); console.log(` | Paper face value: \"${paper.faceValue}\"`); console.log(` | Paper is issued by: \"${paper.issuer}\"`); console.log(` | Paper issue on: \"${paper.issueDateTime}\"`); console.log(` | Paper matures on: \"${paper.maturityDateTime}\"`); console.log(` +-----------------------------------+ `); console.log('Transaction complete.'); Below, this part of the code looks at the let paper = CommercialPaper.fromBuffer(getPaperResponse); message and then defines what the current status of the paper is. There for 4 options, UNKNOWN, ISSUED, TRADING, and REDEEMED let paper = CommercialPaper.fromBuffer(getPaperResponse); let paperState = \"Unknown\"; if (paper.isIssued()) { paperState = \"ISSUED\"; } else if (paper.isTrading()) { paperState = \"TRADING\"; } else if (paper.isRedeemed()) { paperState = \"REDEEMED\"; } Below, this chunk of code simply leaves the gateway it is connected to, thus ending the query. No matter if our query was successful or if there was an error, we\\'ll be disconnected from the gateway // Disconnect from the gateway console.log('Disconnect from Fabric gateway.') gateway.disconnect(); 5. In order to upgrade our smart contract, we need to add a fabric gateway to our IBM Blockchain extension. To do that, switch back to the IBM Blockchain extension within VSCode and click on the gear icon in the bottom left. Then, click on Command Palette 6 To add a Fabric Gateway, type this in the search bar of our list of commands to execute : IBM Blockchain Platform: Add Gateway Fabric gateways are ways for us to connect to a blockchain network from a perspective. In this case, we are acting as Balaji from DigiBank in this commercial paper network. If there were more actors, you could envision more gateways being incorportated here 7. For the name of the gateway, enter papercontract 8. When it asks for a file path to a connection profile , select Browse 9. Then navigate to the networkConnection.yaml file within Digibank to grab the connection profile 10. It will then ask us if we would like to use an existing wallet or create a new wallet. We want to choose Use an existing wallet on my file system 11. When it asks for a file path to a wallet directory , select Browse 12. Then, we will navigate to our user\\'s, Balaji , wallet. Click on Select once you have clicked and highlighted on wallet 13. We will then see a new Fabric Gateway within the IBM Blockchain extension as well as successful messages from the output 14. We can then click on Admin@org1.example.com and then it will show all of our channels. Furthermore, it will show all the smart contracts available on the channel. You\\'ll see we have mycontract@0.0.1 and papercontract@0 . Even further, we can see all the available transactions/queries based on the smart contract. All of these are available if we untoggle the channels and smart contracts. Even though we have added the new fabric gateway, we still haven\\'t updated our smart contract to include the getPaper query. We will do that in the next series of commands. 15. Switch back to the Explorer perspective and toggle the fabric-samples to hide all of the folders and files. Then click on File and select Add Folder to Workplace to add a new folder to the workspace 16. Once it gives us a pop-up of the folder directory, navigate to the contract folder of Digibank . Click on or highlight the contract folder : fabric-samples - commercial-paper - organization - digibank - contract 17. Here we will name the smart contract papercontract and give it version 0.0.2 . First, untoggle the contract folder and click on the package.json file to open it. Within that file, change lines 2 and 3 to look like this below : \"name\": \"papercontract\", \"version\": \"0.0.2\", 18. Switch back to the IBM Blockchain extension. From there click on the gear in the bottom left and select Command Palette . When the search bar of available commands appears, type in the following below : IBM Blockchain Platform: Package a Smart Contract Project 22. When it asks for a workplace folder to package choose contract . Then it will pull in the folder and name it papercontract@0.0.2 based on our modifications to the package.json file 23. Now that we have our packaged smart contract, let\\'s upgrade our current smart contract. To do so, within the Local Fabric Ops pane, untoggle the Channels and right click on mychannel . Then select Upgrade Smart Contract 24. It will then ask which current smart contract we want to upgrade. We want to select papercontract@0 to upgrade. Then it will ask which smart contract version to preform an upgrade with , we want to select papercontract@0.0.2 . Since we have to install our upgraded contract on a peer, select peer0.org1.example.com to install the smart contract on. When it asks for any arguments, do not enter anything here, but rather - simply - press enter to execute our upgrade. You will know this was successful if we click on Admin@org1.example.com under the papercontract gateway. Further, untoggle the papercontract@0.0.2 smart contract to see all the available transactions and queries. Now, we have successfully upgraded our smart contract to include the getPaper query. Now, lets have some fun and make some transactions and queries! Section 6: Submit Transactions 1. If you remember, we already did an issue transaction back before upgrading our smart contract. Since we have added the getPaper query to our smart contract, let\\'s do that from the digibank perspective using getPaper.js . As you already know, the getPaper query will get the current status of the paper on top of other bits of information, like price. 2. From the digibank perspective in your terminal (your 3rd terminal) enter this command. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/digibank/application$ node getPaper.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper getPaper transaction. Process getPaper transaction response. +--------- Paper Retrieved ---------+ | Paper number: \"00001\" | Paper is owned by: \"MagnetoCorp\" | Paper is currently: \"ISSUED\" | Paper face value: \"5000000\" | Paper is issued by: \"MagnetoCorp\" | Paper issue on: \"2020-05-31\" | Paper matures on: \"2020-11-30\" +-----------------------------------+ Transaction complete. Disconnect from Fabric gateway. getPaper program complete. 3. Now that we know the status of our paper, let\\'s actually buy the paper. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/digibank/application$ node buy.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper buy transaction. 2019-02-28T19:52:17.372Z - info: [TransactionEventHandler]: _strategySuccess: strategy success for transaction \"871e7743c58e406575d4e553330faae3711c0a65a2f677b6e6d398650069d81a\" Process buy transaction response. MagnetoCorp commercial paper : 00001 successfully purchased by DigiBank Transaction complete. Disconnect from Fabric gateway. Buy program complete. 4. Let\\'s observe the currect status of the paper. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/digibank/application$ node getPaper.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper getPaper transaction. Process getPaper transaction response. +--------- Paper Retrieved ---------+ | Paper number: \"00001\" | Paper is owned by: \"DigiBank\" | Paper is currently: \"TRADING\" | Paper face value: \"5000000\" | Paper is issued by: \"MagnetoCorp\" | Paper issue on: \"2020-05-31\" | Paper matures on: \"2020-11-30\" +-----------------------------------+ Transaction complete. Disconnect from Fabric gateway. getPaper program complete. 5. Let\\'s pretend the maturity date has been reached, we can now redeem this paper. Lets do that now. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/digibank/application$ node redeem.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper redeem transaction. 2019-02-28T19:52:46.452Z - info: [TransactionEventHandler]: _strategySuccess: strategy success for transaction \"c26ecbf1077d99a5ea025c339ffabd88eb22cf4e6ac5ff8d9b570cd6c38eb531\" Process redeem transaction response. MagnetoCorp commercial paper : 00001 successfully redeemed with MagnetoCorp Transaction complete. Disconnect from Fabric gateway. Redeem program complete. 6. Once again, let\\'s get the status of the paper. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/digibank/application$ node getPaper.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper getPaper transaction. Process getPaper transaction response. +--------- Paper Retrieved ---------+ | Paper number: \"00001\" | Paper is owned by: \"MagnetoCorp\" | Paper is currently: \"REDEEMED\" | Paper face value: \"5000000\" | Paper is issued by: \"MagnetoCorp\" | Paper issue on: \"2020-05-31\" | Paper matures on: \"2020-11-30\" +-----------------------------------+ Transaction complete. Disconnect from Fabric gateway. getPaper program complete. 7. We have successfully run a few transactions and queries with 1 paper and all from our terminal. Now, let\\'s make a 2nd paper and mix up the method of how we do the transactions and queries. To do this, go back to VSCode and into the Explorer perspective. From there, navigate to the issue.js file within MagnetoCorp : fabric-samples - commercial-paper - organization - magnetocorp - application - issue.js 8. On what should be line 68 , change the issue transaction code to what is below. NOTE: scroll over to see the line of code change below : Take this.. const issueResponse = await contract.submitTransaction('issue', 'MagnetoCorp', '00001', '2020-05-31', '2020-11-30', '5000000'); ..and change to const issueResponse = await contract.submitTransaction('issue', 'MagnetoCorp', '00002', '2019-06-31', '2019-12-30', '6000000'); That line of code is creating a new paper. Go ahead and save this file (control + s) . 9. Equally, navigate to the getPaper.js file within digibank and change the key below to look for a paper with an id of 00002 on line 68 : fabric-samples - commercial-paper - organization - digibank - application - getPaper.js --- Take this.. const getPaperResponse = await contract.evaluateTransaction('getPaper', 'MagnetoCorp', '00001'); .. and change to const getPaperResponse = await contract.evaluateTransaction('getPaper', 'MagnetoCorp', '00002'); That line of code is changing the getPaper.js file to look for the paper with an ID of 00002 . Go ahead and save this file (control + s) . 10. Now that we have modified our code, let\\'s go ahead and issue a new paper from our terminal. To do this, we have to be in our MagnetoCorp perspective (our 2nd terminal tab). Within that command line, enter this. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/magnetocorp/application$ node issue.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper issue transaction. 2019-02-28T19:54:09.436Z - info: [TransactionEventHandler]: _strategySuccess: strategy success for transaction \"bec2e62e6c440d214cd61336fd3b38a1024e590afa58c5f90421e6db19cc410c\" Process issue transaction response. MagnetoCorp commercial paper : 00002 successfully issued for value 6000000 Transaction complete. Disconnect from Fabric gateway. Issue program complete. 11. Now, switch to Digibank's perspective in our terminal (our 3rd terminal tab) and do a getPaper query using getPaper.js . NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/digibank/application$ node getPaper.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper getPaper transaction. Process getPaper transaction response. +--------- Paper Retrieved ---------+ | Paper number: \"00002\" | Paper is owned by: \"MagnetoCorp\" | Paper is currently: \"ISSUED\" | Paper face value: \"6000000\" | Paper is issued by: \"MagnetoCorp\" | Paper issue on: \"2019-06-31\" | Paper matures on: \"2019-12-30\" +-----------------------------------+ Transaction complete. Disconnect from Fabric gateway. getPaper program complete. 12. That\\'s enough command line for right now, let\\'s jump to VSCode and buy our new paper there. Within the IBM Blockchain extension, go to the Fabric Gateway and click on the papercontect gateway. From there, click on Admin@org1.example.com and untoggle to the transactions and query. Then, right click on the buy transaction and select Submit Transaction When it asks for some arguments to pass in with the buy transaction, enter this below : MagnetoCorp,00002,MagnetoCorp,DigiBank,5900000,2019-07-31 13. We will see that transaction was successful from the output it generated in VSCode. We can confirm that by doing a getPaper.js query again in our terminal (3rd terminal tab). NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/digibank/application$ node getPaper.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper getPaper transaction. Process getPaper transaction response. +--------- Paper Retrieved ---------+ | Paper number: \"00002\" | Paper is owned by: \"DigiBank\" | Paper is currently: \"TRADING\" | Paper face value: \"6000000\" | Paper is issued by: \"MagnetoCorp\" | Paper issue on: \"2019-06-31\" | Paper matures on: \"2019-12-30\" +-----------------------------------+ Transaction complete. Disconnect from Fabric gateway. getPaper program complete. 14. We are going to repeat the previous 2 steps, but this time we are going to do a redeem transaction from the IBM Blockchain extension. To do this, go to the Fabric Gateway pane and click on the papercontract gateway. From there, click on Admin@org1.example.com and untoggle to the transactions and query. Then, right click on redeem and select Submit Transaction When it asks for some arguments to pass through, enter this below : MagnetoCorp,00002,DigiBank,2019-12-30 15. What do you think the next action will be? If you\\'re thinking the getPaper query, you were right. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/digibank/application$ node getPaper.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper getPaper transaction. Process getPaper transaction response. +--------- Paper Retrieved ---------+ | Paper number: \"00002\" | Paper is owned by: \"MagnetoCorp\" | Paper is currently: \"REDEEMED\" | Paper face value: \"6000000\" | Paper is issued by: \"MagnetoCorp\" | Paper issue on: \"2019-06-31\" | Paper matures on: \"2019-12-30\" +-----------------------------------+ Transaction complete. Disconnect from Fabric gateway. getPaper program complete. Feel free to continue to make and trade more papers by submitting various transactions and queries. If you do not want to make more papers, please continue to last section, which will simply clean up the lab environment. Section 7: Lab Cleanup 1. To clean up the lab environment, please enter this in your terminal below : docker stop $(docker ps -q) # to stop all of your running docker containers docker rm $(docker ps -aq) # to remove all of your docker containers docker rmi -f $(docker images -q) # to remove all of your docker images 2. Finally, go back to your Explorer perspective and right click on all of your folders and select Remove Folder from Workplace . This will get rid of all of your folders. END OF LAB!","title":"Part 2"},{"location":"vscode-part2/#part-2-commercial-paper-tutorial","text":"","title":"Part 2: Commercial Paper Tutorial"},{"location":"vscode-part2/#section-1-overview","text":"This tutorial is of a commercial paper (known as PaperNet ) trading network. Commercial paper itself is a type of unsecured lending in the form of a \"promissory note\". The papers are normally issued by large corporations to raise funds to meet short-term financial obligations at a fixed rate of interest. Once issued at a fixed price, for a fixed term, another company or bank will purchase them at a discount to the face value and when the term is up, they will be redeemed for their face value. As an example, if a paper was issued at a face value of 10M USD for a 6-month term at 2% interest then it could be bought for 9.8M USD (10M -- 2%) by another company or bank who are happy to bear the risk that the issuer will not default. Once the term is up, then the paper could be redeemed or sold back to the issuer for their full face value of 10M USD. Between buying and redemption, the paper can be bought or sold between different parties on a commercial paper market. These three key steps of issue, buy and redeem are the main transactions in a simplified commercial paper marketplace, which we will mirror in our lab. We will see a commercial paper issued by a company called MagnetoCorp and once issued on the commercial paper blockchain network, another company called DigiBank will first buy the paper and then redeem it. You'll act as a developer, end user, and administrator, each in different organizations, performing the following steps designed to help you understand what it's like to collaborate as two different organizations working independently, but according to mutually agreed rules in a Hyperledger Fabric network. Below is an image of our PaperNet network. For our lab, we will create Isabella who is with MagnetoCorp. Additionally, we will create Balaji who is with DigiBank. Isabella will issue a paper for the network. The paper will have an ID number, when it was issued, the maturity date, and the face value (\\$). Balaji, from DigiBank, will then buy the paper and then eventually redeem it. Below is the full breakdown of Part 2 of this lab: Setting the Stage: Based off of Part 1, we have started a blockchain network, created a smart contract, created and run tests and then submitted transactions. For Part 2, we need to create a couple more docker containers that will set us up for success for the rest of the lab. One of these containers will just monitor the docker network we are operating in. If you have no idea what a docker network is, I will explain later on. The other continer is fabric-tools , but it is named cliMagnetoCorp which will be how we install and instantiate the first time. Install and Instantiate Smart Contract: Now that we have those new docker containers up and running, we will enter our cliMagnetoCorp container and install and instantiate our smart contract. Since we are connected to the same running local Hyperledger Fabric network, we will see the smart contract show up in VSCode. Issue Identities: In this section, we will issue two identites. One is an end-user named Isabella with MagnetoCorp . She will invoke a transaction that will issue a paper. Then we will issue an identity for DigiBank named Balaji . Balaji will act as the adminstrator for Digibank and will buy and redeem the paper that Isabella issued. Balaji is important in this lab, as we will add a Fabric Gateway connection to connect to his perspective of the network. Upgrade Smart Contract: This section is the longest of the entire lab, but it really exemplifies the power of VSCode and the IBM Blockchain Platform extension. We will update our smart contract code to include one more transaction called getPaper . This transaction will allow us to see the current status of the paper, like who knows it, what is its status and how much is it worth. In addition to modifiying the code, we will update our smart contract so that the network is aware of the new smart contract. Submit Transactions: Now that we have added a transaction to our smart contract, we will then submit various transactions from many different places and perspectives. For example, we will issue a transaction from the command line interface as well as the VSCode user interface. We will also issue another paper from Isabella\\'s perspective and then invoke a series of transactions to buy and redeem the paper from Balaji. Lab Cleanup: This is the most bittersweet part of the entire lab. It means the lab is over and we have to clean up. If you have kids (I don\\'t), I\\'d imagine their faces are sad and full of despair when you (the guardian) tell them to clean up their mess. I\\'d also like to imagine your face is making a similar expression right now. It\\'s okay, more fun is going to be had soon - very soon!","title":"Section 1: Overview"},{"location":"vscode-part2/#section-2-setting-the-stage","text":"NOTE: There are two terminals we can operate in - the actual terminal application and the terminal found in VSCode. Unless I explicitly say, only use the terminal application - meaning do not use the terminal in VSCode. On the chance that we will use the terminal in VSCode, I will specify that. 1. Open your terminal and navigate to your Desktop and then clone the fabric-samples github repository tecadmin@ubuntubase:~/Desktop/mycontract$ ls -l total 0 drwxr-xr-x 16 tecadmin tecadmin 512 Feb 22 12:34 mycontract tecadmin@ubuntubase:~/Desktop/mycontract$ git clone https://github.com/hyperledger/fabric-samples.git Cloning into 'fabric-samples'... remote: Enumerating objects: 85, done. remote: Counting objects: 100% (85/85), done. remote: Compressing objects: 100% (71/71), done. remote: Total 2658 (delta 26), reused 71 (delta 13), pack-reused 2573 Receiving objects: 100% (2658/2658), 927.08 KiB | 0 bytes/s, done. Resolving deltas: 100% (1293/1293), done. tecadmin@ubuntubase:~/Desktop/mycontract$ ls -l total 0 drwxr-xr-x 22 tecadmin tecadmin 704 Feb 22 12:41 fabric-samples drwxr-xr-x 16 tecadmin tecadmin 512 Feb 22 12:34 mycontract 2. We need to know the Docker network that we are currently in so that we can modify some scripts, that will then create more Docker containers for us to use. Enter the command below to see all of our Docker networks tecadmin@ubuntubase:~/Desktop/mycontract$ docker network list NETWORK ID NAME DRIVER SCOPE ad2e1a3e2fc2 bridge bridge local 35837170ae5b fabricvscodelocalfabric_basic bridge local c5e0411b0d34 host host local 42ffa501f2f9 none null local 3. The network we are in is called fabricvscodelocalfabric_basic and we can verify that by doing the following command tecadmin@ubuntubase:~/Desktop/mycontract$ docker network inspect fabricvscodelocalfabric_basic That command will show you all the containers running in this network. In a nutshell, docker networks are natural ways to isolate containers from other containers or other networks. Having containers within a network allows them to immediately communicate with other containers in the network. 4. Within VSCode, go to the Editor perspective and click on File and select Add Folder to Workplace.. - This will allow us to work from an Untitled Workplace , but have the fabric-samples folder in there. 5. Within VSCode, navigate to the folder below within MagnetoCorp commercial paper - organizations - magenetocorp - configuration - cli You should see two files in there. One named docker-compose-yml and another named monitordocker.sh 6. Within the docker-compose.yml file, replace the net_basic with fabricvscodelocalfabric_basic on line 11 and save your file by pressing control + s 7. Now within the monitordocker.sh file, replace basicnetwork_basic with fabricvscodelocalfabric_basic on line 9 and again save by pressing control + s 8. Now from the terminal navigate to the cli directory within MagnetoCorp. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract$ cd fabric-samples/commercial-paper/organization/magnetocorp/configuration/cli/ tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/magnetocorp/configuration/cli/$ ls -l total 16 -rw-r--r-- 1 tecadmin tecadmin 1168 Feb 22 12:41 docker-compose.yml -rwxr-xr-x 1 tecadmin tecadmin 751 Feb 22 12:44 monitordocker.sh 9. Now that we have updated these files to represent the correct Docker network, go ahead run the monitordocker file with the name of our Docker network. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/magnetocorp/configuration/cli/$ ./monitordocker.sh fabricvscodelocalfabric_basic This command will pull down another container that just monitors all of the docker log output from the fabricvscodelocalfabric_basic network. I\\'m going off a hunch, but I think that\\'s why the file is called monitordocker.sh . We will see more messages coming very soon. 10. Since this terminal is occupied with log messages, let\\'s open another terminal tab. We can open a new tab by clicking on File and then either selecting New Tab . 11. When you opened a new tab, you should have been taken to the same file path that you were in on the previous tab. Now that we have a command line ready, go ahead and enter the command below that will create a cliMagnetoCorp container for our docker network to use. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/magnetocorp/configuration/cli/$ docker-compose -f docker-compose.yml up -d cliMagnetoCorp . . # We'll see docker messages . Status: Downloaded newer image for hyperledger/fabric-tools:latest Creating cliMagnetoCorp ... Creating cliMagnetoCorp ... done When we first install the smart contract, we will go through the cliMagnetoCorp container, which is our Administrator Console. This will allow use to use Fabric peer commands. Conveniently, the cliMagnetoCorp container is the hyperledger/fabric-tools image. 12. We can also do a docker ps -a command to see all of our docker containers. We should see two new containers - cliMagnetoCorp and logspout 13. Equally, we could do docker network inspect fabricvscodelocalfabric_basic to see all of our containers together in one network - and no, not in a blockchain network. They are, however, the components that make up our local blockchain network :)","title":"Section 2: Setting the Stage"},{"location":"vscode-part2/#section-3-install-and-instantiate-smart-contract","text":"Before we actually install the commercial paper smart contract, let\\'s actually open the file to see what the smart contract is trying to do. 1. From your explorer perspective, navigate from the fabric-samples folder to the contract folder of MagnetoCorp : fabric-samples - commercial-paper - organization - magnetocorp - contract Within the lib folder, you\\'ll see 3 javascript (.js) files in there. Click on the papercontract.js file, which will open it that file within VSCode Let\\'s dissect our papercontract.js file as it is our smart contract. We will only go over the issue transaction, but the other transactions follow pretty closely to this one Below, these 2 lines of code brings into scope two key Hyperledger Fabric classes that will be used extensively by the smart contract -- Contract and Context // Fabric smart contract classes const { Contract, Context } = require('fabric-contract-api'); Below, we define the smart contract class CommercialPaperContract based on the built-in Fabric Contract class. The methods which implement the key transactions to issue, buy and redeem commercial paper are defined within this class /** * Define commercial paper smart contract by extending Fabric Contract class * */ class CommercialPaperContract extends Contract { Below, this method defines the commercial paper issue transaction for commercial paper blockchain network. The parameters that are passed to this method will be used to create the new commercial paper. Locate and examine the buy and redeem transactions within the smart contract /** * Issue commercial paper * * @param {Context} ctx the transaction context * @param {String} issuer commercial paper issuer * @param {Integer} paperNumber paper number for this issuer * @param {String} issueDateTime paper issue date * @param {String} maturityDateTime paper maturity date * @param {Integer} faceValue face value of paper */ async issue(ctx, issuer, paperNumber, issueDateTime, maturityDateTime, faceValue) { Within the issue transaction, this statement creates a new commercial paper in memory using the CommercialPaper class with the supplied transaction inputs. Examine the buy and redeem transactions to see how they similarly use this class below // create an instance of the paper let paper = CommercialPaper.createInstance(issuer, paperNumber, issueDateTime, maturityDateTime, faceValue); Below, this statement adds the new commercial paper to the ledger using ctx.paperList, an instance of a PaperList class that was created when the smart contract context CommercialPaperContext was initialized. Again, examine the buy and redeem methods to see how they use this class // Add the paper to the list of all similar commercial papers in the ledger world state await ctx.paperList.addPaper(paper); Below you will find that this statement returns a binary buffer as response from the issue transaction for processing by the caller of the smart contract // Must return a serialized paper to caller of smart contract return paper.toBuffer(); 2. Now that we have an understanding of the smart contract, let\\'s actually install it on our peer through our terminal. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/magnetocorp/configuration/cli/$ docker exec cliMagnetoCorp peer chaincode install -n papercontract -v 0 -p /opt/gopath/src/github.com/contract -l node 2019-02-22 17:48:23.721 UTC [chaincodeCmd] checkChaincodeCmdParams - INFO 001 Using default escc 2019-02-22 17:48:23.721 UTC [chaincodeCmd] checkChaincodeCmdParams - INFO 002 Using default vscc 2019-02-22 17:48:23.862 UTC [chaincodeCmd] install - INFO 003 Installed remotely response: status:200 payload:\"OK\" A message saying 200 is a great sign to see. If you notice, we are not in the contract folder of our command line interface. Instead, we are entering the cliMagnetoCorp docker container with docker exec cliMagnetoCorp and navigating to the /opt/gopath/src/github.com/contract file path within our container to grab the files we need to install the smart contract. The -n papercontract flag names our smart contract papercontract . The -v 0 gives our smart contract a version of 0. Finally, the -l node tells us that the language of our smart contract is nodejs. The picture below goes into detail, visually, as to how we are actually installing a copy of the commercial paper smart contract on our peer. 3. Since our network is connected to our VSCode instance, you can refresh the Local Fabric Ops panel in VSCode under the IBM Blockchain extension. The refresh button is revealed when you hover your mouse over the Local Fabric Ops panel 4. Since we have installed the smart contract, we should actually make it active by instantiating it. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/magnetocorp/configuration/cli/$ docker exec cliMagnetoCorp peer chaincode instantiate -n papercontract -v 0 -l node -c '{\"Args\":[\"org.papernet.commercialpaper:instantiate\"]}' -C mychannel -P \"\" 2019-02-22 17:50:34.673 UTC [chaincodeCmd] InitCmdFactory - INFO 001 Retrieved channel (mychannel) orderer endpoint: orderer.example.com:7050 2019-02-22 17:50:34.675 UTC [chaincodeCmd] checkChaincodeCmdParams - INFO 002 Using default escc 2019-02-22 17:50:34.675 UTC [chaincodeCmd] checkChaincodeCmdParams - INFO 003 Using default vscc tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/magnetocorp/configuration/cli/$ As you can see in the image below, we are instantiating a copy of the commercial paper smart contract on our MagnetoCorp peer. Similar to the installation of the smart contract, the instantiation goes into the cliMagnetoCorp container. After successfully instantiating the smart contract, there will be a commercial paper smart contract docker image and container. 5. You will know our instantiate command worked when we simply get our command prompt back. You can really verify it worked by going back to the VSCode and refreshing the Local Fabric Ops panel and you should see it under the instantiate section.","title":"Section 3: Install and Instantiate Smart Contract"},{"location":"vscode-part2/#section-4-issue-identities","text":"Now that we have a ready-to-use smart contract, let\\'s issue some identities so that those identities can invoke and query transactions. 1. You should be within the cli folder of the MagnetoCorp folder. You can confirm this by issuing the command below. NOTE: scroll over to see the entire command below tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/magnetocorp/configuration/cli/$ pwd /Users/home/Desktop/fabric-samples/commercial-paper/organization/magnetocorp/configuration/cli This is a good sign. Issue the following command below to get to the application folder within MagnetoCorp. NOTE: scroll over to see the entire command below tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/magnetocorp/configuration/cli/$ cd ../../application/ tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/magnetocorp/application$ 2. From the Explorer perspective within VSCode, navigate to the same folder. That is, the application folder within MagnetoCorp . You should see 4 files in there: .eslintrc.js, addToWallet.js, issue.js , and package.json 3. Click on issue.js , which will open the file within VSCode. Let\\'s discuss what the file is trying to do. Below we bring in two key Hyperledger Fabric SDK classes into scope -- Wallet and Gateway . Because Isabella's X.509 certificate is in the local file system, the application uses FileSystemWallet // Bring key classes into scope, most importantly Fabric SDK network class const { FileSystemWallet, Gateway } = require('fabric-network'); Below, this statement identifies that the application will use Isabella\\'s wallet when it connects to the blockchain network channel. The application will select a particular identity within Isabell\\'s wallet. (The wallet must have been loaded with Isabella's X.509 certificate -- that's what addToWallet.js does.) // A wallet stores a collection of identities for use const wallet = new FileSystemWallet('../identity/user/isabella/wallet'); This line of code, below, connects to the network using the gateway identified by connectionProfile , using the identity referred to in ConnectionOptions . See how ../gateway/networkConnection.yaml and User1@org1.example.com are used for these values respectively // Connect to gateway using application specified parameters await gateway.connect(connectionProfile, connectionOptions); Below in the couple lines of code, connects the application to the network channel mychannel , where the papercontract was previously instantiated. If you had a different channel name, you would have to modify this line of code // Access commercial paper network const network = await gateway.getNetwork('mychannel'); Below, this statement gives the application addressability to the smart contract defined by the namespace org.papernet.commercialpaper within papercontract. Once an application has issued getContract, it can submit any transaction implemented within it // Get addressability to commercial paper contract const contract = await network.getContract('papercontract', 'org.papernet.comm...'); Below, these lines of code submits a transaction to the network using the issue transaction defined within the smart contract. MagnetoCorp, 00001 are the values to be used by the issue transaction to create a new commercial paper // issue commercial paper const issueResponse = await contract.submitTransaction('issue','MagnetoCorp', '00001', '2020-05-31', '2020-11-30','5000000'); This statement, below, processes the response from the issue transaction. The response needs to be deserialized from a buffer into paper, a CommercialPaper object which can be interpreted correctly by the application // process response let paper = CommercialPaper.fromBuffer(issueResponse); 4. Since we know our issue.js file is looking at the ../gateway/networkConnection.yaml , we need to modify this file to represent our connection profile. We can do this by opening the networkConnection.yaml file in VSCode and then modifying the ports of our Orderer (line 91), Peer (line 105) and CA (117). You can find these ports by doing the following command from your terminal application. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/magnetocorp/application$ docker ps -a Once you have modified the file, please save it (control + s) . 5. Enter the following command below to install the needed packages from the package.json file. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/magnetocorp/application$ npm install . . # A bunch of output, with some of the output repeating . node-pre-gyp WARN Using request for node-pre-gyp https download [grpc] Success: \"/home/tecadmin/Desktop/fabric-samples/commercial-paper/organization/magnetocorp/application/node_modules/grpc/src/node/extension_binary/node-v57-darwin-x64-unknown/grpc_node.node\" is installed via remote npm notice created a lockfile as package-lock.json. You should commit this file. npm WARN nodejs@1.0.0 No description npm WARN nodejs@1.0.0 No repository field. added 318 packages in 36.994s 6. Since we are in our command line, let\\'s issue the following command that will create Isabella. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/magnetocorp/application$ node addToWallet.js done 7. We will know it worked if we can execute the following command below successfully. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/magnetocorp/application$ ls -l ../identity/user/isabella/wallet/ total 0 drwxr-xr-x 5 tecadmin tecadmin 160 Feb 22 12:53 User1@org1.example.com tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/magnetocorp/application$ ls -l ../identity/user/isabella/wallet/User1\\@org1.example.com/ total 24 -rw-r--r-- 1 tecadmin tecadmin 1037 Feb 22 12:53 User1@org1.example.com -rw-r--r-- 1 tecadmin tecadmin 246 Feb 22 12:53 c75bd6911aca808941c3557ee7c97e90f3952e379497dc55eb903f31b50abc83-priv -rw-r--r-- 1 tecadmin tecadmin 182 Feb 22 12:53 c75bd6911aca808941c3557ee7c97e90f3952e379497dc55eb903f31b50abc83-pub Keys are vital to understanding how transactions and identity work within a blockchain network. Below is a break down of the keys and certificate used in this example a private key c75bd6911a...-priv used to sign transactions on Isabella's behalf, but not distributed outside of her immediate control a public key c75bd6911a...-pub which is cryptographically linked to Isabella's private key. This is wholly contained within Isabella's X.509 certificate a certificate User1@org.example.com which contains Isabella's public key and other X.509 attributes added by the Certificate Authority at certificate creation. This certificate is distributed to the network so that different actors at different times can cryptographically verify information signed by Isabella's private key 8. Now that we have Isabella from MagnetoCorp, let\\'s pass through the issue transaction from our terminal. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/magnetocorp/application$ node issue.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper issue transaction. 2019-02-22T17:55:20.631Z - info: [TransactionEventHandler]: _strategySuccess: strategy success for transaction \"f8e124886d6cb84434cb6a996f4889145c0541199c88bab7d4d85ae41266e51e\" Process issue transaction response. MagnetoCorp commercial paper : 00001 successfully issued for value 5000000 Transaction complete. Disconnect from Fabric gateway. Issue program complete. This successfully committed a transaction to the ledger. See how it outputted a transaction hash for us. As you can see in the image below, we are using the certificate belonging to Isabella to submit our paper issue transaction. Once we verify that Isabella can submit a transaction (via her certificate), the gateway allows the application to focus on transaction generation, submission and response. It coordinates the transaction proposal, ordering and notification processing between the different network components. 9. Since we have created an identity for MagnetoCorp, let\\'s also create Balaji from DigiBank. To do so, we will need a third command line tab. We can add another command line tab by clicking on File - New Tab . This will create a new tab in the terminal from the exact folder directory we were in from our second command line tab. This third tab will act as DigiBank. 10. We now need to switch to a new directory, specifically the application folder of DigiBank. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/magnetocorp/application$ cd ../../digibank/application/ tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/digibank/application$ 11. Navigate to the the application folder of DigiBank in the editior perspective in VSCode : fabric-samples - commercial paper - organization - digibank - application You should see 5 files here: .eslintrc.js, addtowallet.js, buy.js, redeem.js and package.json 12. Go ahead and click on buy.js and scroll through the file. You will notice on line 40 that it is looking at the ../gateway/networkConnection.yaml file. We need to modify the networkConnection.yaml file to represent our network - very similar to step 4 of this section. 13. We need to modify the ports of our Orderer (line 91), Peer (line 105) and CA (117). We can find these ports by doing the following command from our terminal. If you are confused as to where to modify your port numbers, look at the picture on step 4 to get a sense as to where we are grabbing our ports from. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/digibank/application$ docker ps -a Once we have modified the file, please save it (control + s). NOTE: If you don\\'t do this step, the rest of the lab will not work. 14. Back in our terminal and using our DigiBank tab, we can run the next command to install some required packages. NOTE: You will have to scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/digibank/application$ npm install . . . node-pre-gyp WARN Using request for node-pre-gyp https download [grpc] Success: \"/home/tecadmin/Desktop/fabric-samples/commercial-paper/organization/digibank/application/node_modules/grpc/src/node/extension_binary/node-v57-darwin-x64-unknown/grpc_node.node\" is installed via remote npm notice created a lockfile as package-lock.json. You should commit this file. npm WARN nodejs@1.0.0 No description npm WARN nodejs@1.0.0 No repository field. added 318 packages in 27.138s 15. Now, let\\'s add an Balaji from DigiBank . NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/digibank/application$ node addToWallet.js done 16. We can confirm that we actually created an identity by viewing its public/private key below. NOTE: scroll over to see the entire command : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/digibank/application$ ls -l ../identity/user/balaji/wallet/ total 0 drwxr-xr-x 5 tecadmin tecadmin 160 Feb 22 12:57 Admin@org1.example.com tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/digibank/application$ ls -l ../identity/user/balaji/wallet/Admin\\@org1.example.com/ total 24 -rw-r--r-- 1 tecadmin tecadmin 1033 Feb 22 12:57 Admin@org1.example.com -rw-r--r-- 1 tecadmin tecadmin 246 Feb 22 12:57 cd96d5260ad4757551ed4a5a991e62130f8008a0bf996e4e4b84cd097a747fec-priv -rw-r--r-- 1 tecadmin tecadmin 182 Feb 22 12:57 cd96d5260ad4757551ed4a5a991e62130f8008a0bf996e4e4b84cd097a747fec-pub In the next section, we will actually upgrade our smart contract before submitting transactions. We are upgrading our smart contract because we can add in a query to get the status of our paper. Based on the picture below, we now have 2 participants in this network. Obviously, this is MagnetoCorp (Isabella) and DigiBank (Balaji). Both participants are allowed to interact with the commercial paper blockchain network through their application.","title":"Section 4: Issue Identities"},{"location":"vscode-part2/#section-5-upgrade-smart-contract","text":"1. From our Explorer perspective, navigate to the contract/lib folder of DigiBank : fabric-samples - commercial-paper - organization - digibank - contract - lib 2. Within the papercontract.js file, scroll down to line number 54 and enter the following lines of code below : /** * Get commercial paper * @param {Context} ctx the transaction context * @param {String} issuer commercial paper issuer * @param {Integer} paperNumber paper number for this issuer */ async getPaper(ctx, issuer, paperNumber) { try { console.log(\"getPaper for: \" + issuer + \" \" + paperNumber); let paperKey = CommercialPaper.makeKey([issuer, paperNumber]); let paper = await ctx.paperList.getPaper(paperKey); return paper.toBuffer(); } catch(e) { throw new Error('Paper does not exist' + issuer + paperNumber); } } 3. From the terminal in our digibank tab , add a file below that will execute a query that we just added to our smart contract. NOTE: scroll over to see the entire command and file below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/digibank/application$ touch getPaper.js tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/digibank/application$ vi getPaper.js --- type the letter \"i\" to go into insert mode and paste in the following lines of code below --- /* SPDX-License-Identifier: Apache-2.0 */ /* * This application has 6 basic steps: * 1. Select an identity from a wallet * 2. Connect to network gateway * 3. Access PaperNet network * 4. Construct request to issue commercial paper * 5. Submit transaction * 6. Process response */ 'use strict'; // Bring key classes into scope, most importantly Fabric SDK network class const fs = require('fs'); const yaml = require('js-yaml'); const { FileSystemWallet, Gateway } = require('fabric-network'); const CommercialPaper = require('../contract/lib/paper.js'); // A wallet stores a collection of identities for use //const wallet = new FileSystemWallet('../../../connection-local-fabric'); const wallet = new FileSystemWallet('../identity/user/balaji/wallet'); // Main program function async function main() { // A gateway defines the peers used to access Fabric networks const gateway = new Gateway(); // Main try/catch block try { // Specify userName for network access // const userName = 'isabella.issuer@magnetocorp.com'; const userName = 'Admin@org1.example.com'; // Load connection profile; will be used to locate a gateway let connectionProfile = yaml.safeLoad(fs.readFileSync('../gateway/networkConnection.yaml', 'utf8')); // Set connection options; identity and wallet let connectionOptions = { identity: userName, wallet: wallet, discovery: { enabled: false, asLocalhost: true } }; // Connect to gateway using application specified parameters console.log('Connect to Fabric gateway.'); await gateway.connect(connectionProfile, connectionOptions); // Access PaperNet network console.log('Use network channel: mychannel.'); const network = await gateway.getNetwork('mychannel'); // Get addressability to commercial paper contract console.log('Use org.papernet.commercialpaper smart contract.'); const contract = await network.getContract('papercontract', 'org.papernet.commercialpaper'); // get commercial paper console.log('Submit commercial paper getPaper transaction.'); const getPaperResponse = await contract.evaluateTransaction('getPaper', 'MagnetoCorp', '00001'); // process response console.log('Process getPaper transaction response.'); let paper = CommercialPaper.fromBuffer(getPaperResponse); let paperState = \"Unknown\"; if (paper.isIssued()) { paperState = \"ISSUED\"; } else if (paper.isTrading()) { paperState = \"TRADING\"; } else if (paper.isRedeemed()) { paperState = \"REDEEMED\"; } console.log(` +--------- Paper Retrieved ---------+ `); console.log(` | Paper number: \"${paper.paperNumber}\"`); console.log(` | Paper is owned by: \"${paper.owner}\"`); console.log(` | Paper is currently: \"${paperState}\"`); console.log(` | Paper face value: \"${paper.faceValue}\"`); console.log(` | Paper is issued by: \"${paper.issuer}\"`); console.log(` | Paper issue on: \"${paper.issueDateTime}\"`); console.log(` | Paper matures on: \"${paper.maturityDateTime}\"`); console.log(` +-----------------------------------+ `); console.log('Transaction complete.'); } catch (error) { console.log(`Error processing transaction. ${error}`); console.log(error.stack); } finally { // Disconnect from the gateway console.log('Disconnect from Fabric gateway.') gateway.disconnect(); } } main().then(() = { console.log('getPaper program complete.'); }).catch((e) = { console.log('getPaper program exception.'); console.log(e); console.log(e.stack); process.exit(-1); }); --- To get out of vi, hit the \"ESC\" button. Then type in \":wq\" and then press enter to save the file Who knew you would learn VSCode and vi ! Send your hate mail to :) 4. We now have a new file ( getPaper.js ) and then it is in our papercontract.js smart contract. This doesn\\'t mean we can execute a getPaper query because, if you remember, we have to install and instantiate this update onto our peer. Then - and only then - can we actually submit the getPaper query. The next few steps will walk us through how to do that. It would be helpful to understand what we just added to our soon-to-be-updated smart contract. The getPaper query is being submitted by Balaji from DigiBank and it allows him to get the current status of the paper within the network. For example, it prints out the paper\\'s identification number, paper\\'s cost, paper\\'s state (trading, redeemed, issued), paper\\'s issue date and a few other key details. Here is a further breakdown of the query Below, this statement brings two key Hyperledger Fabric SDK classes into scope -- Wallet and Gateway. Because Balaji\u2019s X.509 certificate is in the local file system, the application uses FileSystemWallet // Bring key classes into scope, most importantly Fabric SDK network class const { FileSystemWallet, Gateway } = require('fabric-network'); Below, this statement identifies that the application will use Balaji's wallet when it connects to the blockchain network channel. The application will select a particular identity within Balaji's wallet. (The wallet must have been loaded with Balaji's X.509 certificate -- that's what addToWallet.js does.) // A wallet stores a collection of identities for use const wallet = new FileSystemWallet('../identity/user/balaji/wallet'); Below, this line of code connects to the network using the gateway identified by connectionProfile, using the identity referred to in connectionOptions. See how ../gateway/networkConnection.yaml and Admin@org1.example.com are used for these values respectively // Connect to gateway using application specified parameters await gateway.connect(connectionProfile, connectionOptions); Below, this connects the application to the network channel mychannel, where the papercontract was previously instantiated. If you had a different channel name, you would have to modify this line of code // Access commercial paper network const network = await gateway.getNetwork('mychannel'); Below, this statement gives the application addressability to smart contract defined by the namespace org.papernet.commercialpaper within papercontract. Once an application has issued getContract, it can submit any transaction/query implemented within it // Get addressability to commercial paper contract const contract = await network.getContract('papercontract','org.papernet.commercialpaper'); This series of log output is what the query prints out for us. Based on the defined variables in the papercontract.js we are able to query for pretty specific bits of data to get an overview of our paper. You can look above and see how we are grabbing our paperState console.log(` +--------- Paper Retrieved ---------+ `); console.log(` | Paper number: \"${paper.paperNumber}\"`); console.log(` | Paper is owned by: \"${paper.owner}\"`); console.log(` | Paper is currently: \"${paperState}\"`); console.log(` | Paper face value: \"${paper.faceValue}\"`); console.log(` | Paper is issued by: \"${paper.issuer}\"`); console.log(` | Paper issue on: \"${paper.issueDateTime}\"`); console.log(` | Paper matures on: \"${paper.maturityDateTime}\"`); console.log(` +-----------------------------------+ `); console.log('Transaction complete.'); Below, this part of the code looks at the let paper = CommercialPaper.fromBuffer(getPaperResponse); message and then defines what the current status of the paper is. There for 4 options, UNKNOWN, ISSUED, TRADING, and REDEEMED let paper = CommercialPaper.fromBuffer(getPaperResponse); let paperState = \"Unknown\"; if (paper.isIssued()) { paperState = \"ISSUED\"; } else if (paper.isTrading()) { paperState = \"TRADING\"; } else if (paper.isRedeemed()) { paperState = \"REDEEMED\"; } Below, this chunk of code simply leaves the gateway it is connected to, thus ending the query. No matter if our query was successful or if there was an error, we\\'ll be disconnected from the gateway // Disconnect from the gateway console.log('Disconnect from Fabric gateway.') gateway.disconnect(); 5. In order to upgrade our smart contract, we need to add a fabric gateway to our IBM Blockchain extension. To do that, switch back to the IBM Blockchain extension within VSCode and click on the gear icon in the bottom left. Then, click on Command Palette 6 To add a Fabric Gateway, type this in the search bar of our list of commands to execute : IBM Blockchain Platform: Add Gateway Fabric gateways are ways for us to connect to a blockchain network from a perspective. In this case, we are acting as Balaji from DigiBank in this commercial paper network. If there were more actors, you could envision more gateways being incorportated here 7. For the name of the gateway, enter papercontract 8. When it asks for a file path to a connection profile , select Browse 9. Then navigate to the networkConnection.yaml file within Digibank to grab the connection profile 10. It will then ask us if we would like to use an existing wallet or create a new wallet. We want to choose Use an existing wallet on my file system 11. When it asks for a file path to a wallet directory , select Browse 12. Then, we will navigate to our user\\'s, Balaji , wallet. Click on Select once you have clicked and highlighted on wallet 13. We will then see a new Fabric Gateway within the IBM Blockchain extension as well as successful messages from the output 14. We can then click on Admin@org1.example.com and then it will show all of our channels. Furthermore, it will show all the smart contracts available on the channel. You\\'ll see we have mycontract@0.0.1 and papercontract@0 . Even further, we can see all the available transactions/queries based on the smart contract. All of these are available if we untoggle the channels and smart contracts. Even though we have added the new fabric gateway, we still haven\\'t updated our smart contract to include the getPaper query. We will do that in the next series of commands. 15. Switch back to the Explorer perspective and toggle the fabric-samples to hide all of the folders and files. Then click on File and select Add Folder to Workplace to add a new folder to the workspace 16. Once it gives us a pop-up of the folder directory, navigate to the contract folder of Digibank . Click on or highlight the contract folder : fabric-samples - commercial-paper - organization - digibank - contract 17. Here we will name the smart contract papercontract and give it version 0.0.2 . First, untoggle the contract folder and click on the package.json file to open it. Within that file, change lines 2 and 3 to look like this below : \"name\": \"papercontract\", \"version\": \"0.0.2\", 18. Switch back to the IBM Blockchain extension. From there click on the gear in the bottom left and select Command Palette . When the search bar of available commands appears, type in the following below : IBM Blockchain Platform: Package a Smart Contract Project 22. When it asks for a workplace folder to package choose contract . Then it will pull in the folder and name it papercontract@0.0.2 based on our modifications to the package.json file 23. Now that we have our packaged smart contract, let\\'s upgrade our current smart contract. To do so, within the Local Fabric Ops pane, untoggle the Channels and right click on mychannel . Then select Upgrade Smart Contract 24. It will then ask which current smart contract we want to upgrade. We want to select papercontract@0 to upgrade. Then it will ask which smart contract version to preform an upgrade with , we want to select papercontract@0.0.2 . Since we have to install our upgraded contract on a peer, select peer0.org1.example.com to install the smart contract on. When it asks for any arguments, do not enter anything here, but rather - simply - press enter to execute our upgrade. You will know this was successful if we click on Admin@org1.example.com under the papercontract gateway. Further, untoggle the papercontract@0.0.2 smart contract to see all the available transactions and queries. Now, we have successfully upgraded our smart contract to include the getPaper query. Now, lets have some fun and make some transactions and queries!","title":"Section 5: Upgrade Smart Contract"},{"location":"vscode-part2/#section-6-submit-transactions","text":"1. If you remember, we already did an issue transaction back before upgrading our smart contract. Since we have added the getPaper query to our smart contract, let\\'s do that from the digibank perspective using getPaper.js . As you already know, the getPaper query will get the current status of the paper on top of other bits of information, like price. 2. From the digibank perspective in your terminal (your 3rd terminal) enter this command. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/digibank/application$ node getPaper.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper getPaper transaction. Process getPaper transaction response. +--------- Paper Retrieved ---------+ | Paper number: \"00001\" | Paper is owned by: \"MagnetoCorp\" | Paper is currently: \"ISSUED\" | Paper face value: \"5000000\" | Paper is issued by: \"MagnetoCorp\" | Paper issue on: \"2020-05-31\" | Paper matures on: \"2020-11-30\" +-----------------------------------+ Transaction complete. Disconnect from Fabric gateway. getPaper program complete. 3. Now that we know the status of our paper, let\\'s actually buy the paper. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/digibank/application$ node buy.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper buy transaction. 2019-02-28T19:52:17.372Z - info: [TransactionEventHandler]: _strategySuccess: strategy success for transaction \"871e7743c58e406575d4e553330faae3711c0a65a2f677b6e6d398650069d81a\" Process buy transaction response. MagnetoCorp commercial paper : 00001 successfully purchased by DigiBank Transaction complete. Disconnect from Fabric gateway. Buy program complete. 4. Let\\'s observe the currect status of the paper. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/digibank/application$ node getPaper.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper getPaper transaction. Process getPaper transaction response. +--------- Paper Retrieved ---------+ | Paper number: \"00001\" | Paper is owned by: \"DigiBank\" | Paper is currently: \"TRADING\" | Paper face value: \"5000000\" | Paper is issued by: \"MagnetoCorp\" | Paper issue on: \"2020-05-31\" | Paper matures on: \"2020-11-30\" +-----------------------------------+ Transaction complete. Disconnect from Fabric gateway. getPaper program complete. 5. Let\\'s pretend the maturity date has been reached, we can now redeem this paper. Lets do that now. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/digibank/application$ node redeem.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper redeem transaction. 2019-02-28T19:52:46.452Z - info: [TransactionEventHandler]: _strategySuccess: strategy success for transaction \"c26ecbf1077d99a5ea025c339ffabd88eb22cf4e6ac5ff8d9b570cd6c38eb531\" Process redeem transaction response. MagnetoCorp commercial paper : 00001 successfully redeemed with MagnetoCorp Transaction complete. Disconnect from Fabric gateway. Redeem program complete. 6. Once again, let\\'s get the status of the paper. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/digibank/application$ node getPaper.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper getPaper transaction. Process getPaper transaction response. +--------- Paper Retrieved ---------+ | Paper number: \"00001\" | Paper is owned by: \"MagnetoCorp\" | Paper is currently: \"REDEEMED\" | Paper face value: \"5000000\" | Paper is issued by: \"MagnetoCorp\" | Paper issue on: \"2020-05-31\" | Paper matures on: \"2020-11-30\" +-----------------------------------+ Transaction complete. Disconnect from Fabric gateway. getPaper program complete. 7. We have successfully run a few transactions and queries with 1 paper and all from our terminal. Now, let\\'s make a 2nd paper and mix up the method of how we do the transactions and queries. To do this, go back to VSCode and into the Explorer perspective. From there, navigate to the issue.js file within MagnetoCorp : fabric-samples - commercial-paper - organization - magnetocorp - application - issue.js 8. On what should be line 68 , change the issue transaction code to what is below. NOTE: scroll over to see the line of code change below : Take this.. const issueResponse = await contract.submitTransaction('issue', 'MagnetoCorp', '00001', '2020-05-31', '2020-11-30', '5000000'); ..and change to const issueResponse = await contract.submitTransaction('issue', 'MagnetoCorp', '00002', '2019-06-31', '2019-12-30', '6000000'); That line of code is creating a new paper. Go ahead and save this file (control + s) . 9. Equally, navigate to the getPaper.js file within digibank and change the key below to look for a paper with an id of 00002 on line 68 : fabric-samples - commercial-paper - organization - digibank - application - getPaper.js --- Take this.. const getPaperResponse = await contract.evaluateTransaction('getPaper', 'MagnetoCorp', '00001'); .. and change to const getPaperResponse = await contract.evaluateTransaction('getPaper', 'MagnetoCorp', '00002'); That line of code is changing the getPaper.js file to look for the paper with an ID of 00002 . Go ahead and save this file (control + s) . 10. Now that we have modified our code, let\\'s go ahead and issue a new paper from our terminal. To do this, we have to be in our MagnetoCorp perspective (our 2nd terminal tab). Within that command line, enter this. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/magnetocorp/application$ node issue.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper issue transaction. 2019-02-28T19:54:09.436Z - info: [TransactionEventHandler]: _strategySuccess: strategy success for transaction \"bec2e62e6c440d214cd61336fd3b38a1024e590afa58c5f90421e6db19cc410c\" Process issue transaction response. MagnetoCorp commercial paper : 00002 successfully issued for value 6000000 Transaction complete. Disconnect from Fabric gateway. Issue program complete. 11. Now, switch to Digibank's perspective in our terminal (our 3rd terminal tab) and do a getPaper query using getPaper.js . NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/digibank/application$ node getPaper.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper getPaper transaction. Process getPaper transaction response. +--------- Paper Retrieved ---------+ | Paper number: \"00002\" | Paper is owned by: \"MagnetoCorp\" | Paper is currently: \"ISSUED\" | Paper face value: \"6000000\" | Paper is issued by: \"MagnetoCorp\" | Paper issue on: \"2019-06-31\" | Paper matures on: \"2019-12-30\" +-----------------------------------+ Transaction complete. Disconnect from Fabric gateway. getPaper program complete. 12. That\\'s enough command line for right now, let\\'s jump to VSCode and buy our new paper there. Within the IBM Blockchain extension, go to the Fabric Gateway and click on the papercontect gateway. From there, click on Admin@org1.example.com and untoggle to the transactions and query. Then, right click on the buy transaction and select Submit Transaction When it asks for some arguments to pass in with the buy transaction, enter this below : MagnetoCorp,00002,MagnetoCorp,DigiBank,5900000,2019-07-31 13. We will see that transaction was successful from the output it generated in VSCode. We can confirm that by doing a getPaper.js query again in our terminal (3rd terminal tab). NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/digibank/application$ node getPaper.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper getPaper transaction. Process getPaper transaction response. +--------- Paper Retrieved ---------+ | Paper number: \"00002\" | Paper is owned by: \"DigiBank\" | Paper is currently: \"TRADING\" | Paper face value: \"6000000\" | Paper is issued by: \"MagnetoCorp\" | Paper issue on: \"2019-06-31\" | Paper matures on: \"2019-12-30\" +-----------------------------------+ Transaction complete. Disconnect from Fabric gateway. getPaper program complete. 14. We are going to repeat the previous 2 steps, but this time we are going to do a redeem transaction from the IBM Blockchain extension. To do this, go to the Fabric Gateway pane and click on the papercontract gateway. From there, click on Admin@org1.example.com and untoggle to the transactions and query. Then, right click on redeem and select Submit Transaction When it asks for some arguments to pass through, enter this below : MagnetoCorp,00002,DigiBank,2019-12-30 15. What do you think the next action will be? If you\\'re thinking the getPaper query, you were right. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/mycontract/fabric-samples/commercial-paper/organization/digibank/application$ node getPaper.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper getPaper transaction. Process getPaper transaction response. +--------- Paper Retrieved ---------+ | Paper number: \"00002\" | Paper is owned by: \"MagnetoCorp\" | Paper is currently: \"REDEEMED\" | Paper face value: \"6000000\" | Paper is issued by: \"MagnetoCorp\" | Paper issue on: \"2019-06-31\" | Paper matures on: \"2019-12-30\" +-----------------------------------+ Transaction complete. Disconnect from Fabric gateway. getPaper program complete. Feel free to continue to make and trade more papers by submitting various transactions and queries. If you do not want to make more papers, please continue to last section, which will simply clean up the lab environment.","title":"Section 6: Submit Transactions"},{"location":"vscode-part2/#section-7-lab-cleanup","text":"1. To clean up the lab environment, please enter this in your terminal below : docker stop $(docker ps -q) # to stop all of your running docker containers docker rm $(docker ps -aq) # to remove all of your docker containers docker rmi -f $(docker images -q) # to remove all of your docker images 2. Finally, go back to your Explorer perspective and right click on all of your folders and select Remove Folder from Workplace . This will get rid of all of your folders. END OF LAB!","title":"Section 7: Lab Cleanup"}]}