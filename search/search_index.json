{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Blockchain Immersion Wildfire Workshop Welcome! This virtual workshop combines lectures and hands-on labs to teach you the fundamentals of blockchain for business. We provide an overview of Enterprise Blockchain that is based on the open source framework called Hyperledger Fabric. You have the opportunity to go through labs from a blockchain developer perspective and a blockchain network operator perspective. Additionally, you will learn about the IBM-specific offerings that leverage Hyperledger Fabric, and how our unique combination of expertise, governance and operations tooling, and infrastructure capabilities with Linux on Z can help you achieve business results faster and more securely. Agenda April 21 Workshop Kickoff and Introductions Introduction to Enterprise Blockchain Demo: Vehicle Lifecycle Demo Vehicle Lifecycle Github Repo Demo: IMMUNIChain Introduction IMMUNIChain Walk-through Blockchain Use Cases April 22 Developer lab kickoff Lab: Developer Journey Part 1 - Create Smart Contract Package Lab: Developer Journey Part 2 - Using an Existing Contract Lab: Developer Journey Part 3 - Commercial Paper Lab errata and notes April 23 IBM Blockchain Platform and LinuxONE Kubernetes Explained Next Steps April 24 IBM Blockchain Platform lab kickoff Lab: IBM Blockchain Platform Part 1 - Deploy Network Lab: IBM Blockchain Platform Part 2 - Deploy Smart Contract Acknowledgements Thanks to the following people who helped us test out the labs: Elvin Galarza, Kevin Breitenother, Victoria Coates, Brandon Nguyen Thanks to Matt Lucas, Matthew Golby-kirk and David Gorman for the workshop materials Authors Austin Grice Barry Silliman Garrett Woodworth Jin VanStee","title":"Home"},{"location":"#blockchain-immersion-wildfire-workshop","text":"Welcome! This virtual workshop combines lectures and hands-on labs to teach you the fundamentals of blockchain for business. We provide an overview of Enterprise Blockchain that is based on the open source framework called Hyperledger Fabric. You have the opportunity to go through labs from a blockchain developer perspective and a blockchain network operator perspective. Additionally, you will learn about the IBM-specific offerings that leverage Hyperledger Fabric, and how our unique combination of expertise, governance and operations tooling, and infrastructure capabilities with Linux on Z can help you achieve business results faster and more securely.","title":"Blockchain Immersion Wildfire Workshop"},{"location":"#agenda","text":"","title":"Agenda"},{"location":"#april-21","text":"Workshop Kickoff and Introductions Introduction to Enterprise Blockchain Demo: Vehicle Lifecycle Demo Vehicle Lifecycle Github Repo Demo: IMMUNIChain Introduction IMMUNIChain Walk-through Blockchain Use Cases","title":"April 21"},{"location":"#april-22","text":"Developer lab kickoff Lab: Developer Journey Part 1 - Create Smart Contract Package Lab: Developer Journey Part 2 - Using an Existing Contract Lab: Developer Journey Part 3 - Commercial Paper Lab errata and notes","title":"April 22"},{"location":"#april-23","text":"IBM Blockchain Platform and LinuxONE Kubernetes Explained Next Steps","title":"April 23"},{"location":"#april-24","text":"IBM Blockchain Platform lab kickoff Lab: IBM Blockchain Platform Part 1 - Deploy Network Lab: IBM Blockchain Platform Part 2 - Deploy Smart Contract","title":"April 24"},{"location":"#acknowledgements","text":"Thanks to the following people who helped us test out the labs: Elvin Galarza, Kevin Breitenother, Victoria Coates, Brandon Nguyen Thanks to Matt Lucas, Matthew Golby-kirk and David Gorman for the workshop materials","title":"Acknowledgements"},{"location":"#authors","text":"Austin Grice Barry Silliman Garrett Woodworth Jin VanStee","title":"Authors"},{"location":"cicd/","text":"1. Go to https://github.com/austingrice/digibank within Firefox 2. Then click on Fork button in the top right. Then log into your GitHub or create a Github account to then fork this repository 3. Once you have the forked repository in your GitHub account, then you can do a Git Clone . To do this find the Clone or download button on the right and then click on the copy button to the right of the URL 4. Then go to your terminal and navigate to your Desktop folder. Once you are there, enter the command below : tecadmin@ubuntubase:~/Desktop$ cd ~ tecadmin@ubuntubase:~/Desktop$ git clone https://github.com/austingrice/digibank.git Cloning into 'digibank'... remote: Enumerating objects: 56, done. remote: Counting objects: 100% (56/56), done. remote: Compressing objects: 100% (43/43), done. remote: Total 56 (delta 6), reused 53 (delta 6), pack-reused 0 Unpacking objects: 100% (56/56), done. 5. While you are in the terminal, navigate to the folder where you downloaded your connection profile from Part 2, Section 8 and step 2. : For example: tecadmin@ubuntubase:~/Desktop$ cd ../Downloads tecadmin@ubuntubase:~/Downloads$ ls -l * drwxr-xr-x 5 tecadmin tecadmin 160 Jun 11 12:53 Your_Connection_Profile * 6. When you are there, enter this command to copy our connection profile to our new digibank folder : tecadmin@ubuntubase:~/Downloads$ cp connectionprofile.json /home/tecadmin/Desktop/digibank/ 7. From here, go into VSCode and add the digibank folder to the workplace. To do this, go to the Editor perspective and then right click on the empty black space and select Add Folder to Workspace . From there, go to your digibank folder and click on select to open up the file. 8. Once you have the digibank folder open, right click on your connection profile file and select Rename . Then rename your connection profile to networkConnection.json . 9. Then toggle on the Identity folder within the digibank folder. Within there, you will see 3 files: config.json , enroll.js and then package.json . Within the config.json file, we have a few places wanting some information. The only things we have to change is our CA port number as well as our MSP name. Other than that, keep everything the same! You can find your CA port by opening your networkConnection.json file and looking for the IP address under the certificateAuthorities section. It should have a 192.168.22.81:3xxx IP address. : { \"connection_file\": \"/home/tecadmin/Desktop/digibank/networkConnection.json\", \"appAdmin\": \"app-admin\", \"appAdminSecret\": \"app-adminpw\", \"orgMSPID\": \"teamXXorg1msp\", \"caName\": \"https://192.168.22.81: Put_Your_CA_Port_Here \", \"userName\": \"app-admin\", \"gatewayDiscovery\": { \"enabled\": true, \"asLocalhost\": false } } --- CHANGES TO --- { \"connection_file\": \"/home/tecadmin/Desktop/digibank/networkConnection.json\", \"appAdmin\": \"app-admin\", \"appAdminSecret\": \"app-adminpw\", \"orgMSPID\": \"team19org1msp\", \"caName\": \"https://192.168.22.81:31142\", \"userName\": \"app-admin\", \"gatewayDiscovery\": { \"enabled\": true, \"asLocalhost\": false } } Save this File! 10. Within the digibank folder there is a src folder. Within the src there will be a blockchainClient.ts file. You can click on the file to open it up and then navigate to line 38 . Go ahead and rename the channel to match the channel name in your IBM Blockchain for Multicloud console. : const network = await gateway.getNetwork('teamXX-channel1'); --- CHANGES TO --- const network = await gateway.getNetwork('team19-channel1'); Save this File! 11. From the CLI application, navigate to the digibank/Identity folder and then run the command below : tecadmin@ubuntubase:~/Downloads$ cd /home/tecadmin/Desktop/digibank/Identity tecadmin@ubuntubase:~/Desktop/digibank/Identity$ npm install * * 12. Once npm has completed some installations, run the command below to enroll our user : tecadmin@ubuntubase:~/Desktop/digibank/Identity$ node enroll.js Wallet path: /home/tecadmin/Desktop/digibank/IBP msg: Successfully enrolled admin user app-admin and imported it into the wallet 13. The previous step created a certificate and public/private key pair for us. We can check that by entering the command below : tecadmin@ubuntubase:~/Desktop/digibank/Identity$ ls -l ../IBP total 4 drwxr-xr-x 2 tecadmin tecadmin 4096 Jun 27 00:39 app-admin tecadmin@ubuntubase:~/Desktop/digibank/Identity$ ls -l ../IBP/app-admin total 12 -rw-r--r-- 1 tecadmin tecadmin 246 Jun 27 00:39 5b17e99aa4da28c2dad4d834409e01c543f19965840b3ba4482049111893897e-priv -rw-r--r-- 1 tecadmin tecadmin 182 Jun 27 00:39 5b17e99aa4da28c2dad4d834409e01c543f19965840b3ba4482049111893897e-pub -rw-r--r-- 1 tecadmin tecadmin 1104 Jun 27 00:39 app-admin 14. Then change the Jenkinsfile to match your team : 15. Once npm has completed some installations, enter the next command below to push our changes to our GitHub account : tecadmin@ubuntubase:~/Desktop/digibank$ git add * tecadmin@ubuntubase:~/Desktop/digibank$ git commit -m 'blockchain is awesome' * * Your file changes and other output messages * tecadmin@ubuntubase:~/Desktop/digibank$ git push Counting objects: 53, done. Delta compression using up to 8 threads. Compressing objects: 100% (48/48), done. Writing objects: 100% (53/53), 13.95 KiB | 0 bytes/s, done. Total 53 (delta 6), reused 0 (delta 0) remote: Resolving deltas: 100% (6/6), done. To github.com:austingrice/digibank.git 140abdf..0666159 master - master 16. Go back to your GitHub repository of digibank and then hit the refresh button to confirm your changes took. JENKINS THEN GOES TO WORK FOR K8S LOOPBACKAPI Jenkins will enable us to automatically build a docker image from our code and deploy it into a IBM Cloud Private via Kubernetes. We are using the Kubernetes plugin for Jenkins to enable this functionality. Jenkins has functionality added through plugins to add new capabilities and features from a variety of different contributors. One of these plugins enables us to connect to Jenkins via a Github webhook so that when new code is pushed it will automatically trigger your Jenkins jobs (in our case we will be using a pipeline). i . Go to the github fork where you just pushed new code. Then, go to the settings for the repository ii Choose the Webhooks section iii Click to add your webhook. iv Configure your webhook. 1. smee url: The smee url will be provided to you for the lab as it is auto-generated for each lab. 2. `application/json` content type 3. Leave the rest as defaults as shown and click `Add Webhook` You may be wondering why we are providing a smee url here and not a jenkins url. Our Jenkins service is not accessible from the public internet. Thus, we can use smee, which is a service that serves as a proxy for webhooks. It acts as a local sidecar container to the Jenkins master (running in the same Kubernetes pod) on it's network. While the services such as GitHub on the public internet can't initaite connections with it, it can initiate connections with them. Using this method, smee forwards Jenkins webhooks when it hears of them via a connection to a public smee service (addressable from the internet) which is in turn listening for github webhooks from your github repositories. v See successful Webhook creation message. vi Time to go to Jenkins. Navigate to https://192.168.22.81:8443/jenkins in your browser. vii Upon seeing the welcome page please enter you team and password for the lab which will be given to you. In this case I am team19 . viii After successfully logging in click on My View to see just the folder you have access to. ix Click on your folder (the only one listed) to enter it. x Create a new job. You could also have created a New item instead which is why that is circled as well. xi Make a pipeline for your digibank project using the options shown below xii Get your repo url from your github fork. xiii Use the url you got from the previous step for the github repository in the configuration below in both places it appears. The other values keep the same as mine. Click save when you are done entering these. xiv Set up authorization for your project in your personal folder by clicking on authorization. xv Choose Run as specific user and put in your team name for the user. This will enable your github to run with your blessing. xvi Click the arrow next to your team name in the upper right hand corner to the left of log out and then select Credentials xvii Click either the Add Credentials or Adding some credentials? link. xviii Make a credential id in Jenkins to securely access your icp creds by making an entry with your team name and password and an id of teamname-icp and click ok. xix Go to My View by clicking the arrow to the left of Jenkins in the upper left hand corner and selecting My View . xx Go on the time clock to build your project now to the right of your pipeline. This will run the Jenkinsfile in your cloned version of the github you adjusted to use your team with the one line change. xxi View the output of your job in the console by clicking the arrow to the right of Build View and Selecting the console output. xxii The job should complete successfully and give you a url you can right click to visit in a new tab. Proceed with Step 17. 17. Once we have our loopback application deployed in our IBM Cloud Private cluster, go ahead and open it. Once you get to the homepage for loopback, click on the Explorer link to view our controllers (which will submit transactions for us). 18. Go ahead and toggle on the IssueController and then click on Try it Out in the top right. Go ahead and enter the text below to issue a new paper : { \"issuer\": \"Digibank\", \"paperNumber\": \"0032\", \"issueDateTime\": \"2020-05-31\", \"maturityDateTime\": \"2020-11-30\", \"faceValue\": \"500\", \"paperRate\": \"0.02\" } 19. Then click on the Execute button below. Then, let it spin around for a moment, but it should come back with some type of response in the response body. Sometimes, it might continuously spin. It will eventually time out, but actually submit the paper and have it be recorded in the IBM Blockchain Platform. You can confirm this by going to your console and clicking on your channel and viewing the block height and transactions. For the loopback, you can just let it time out and then try to issue the same paper with a new paperNumber and it should come back. 20. Do a similar transaction for Buy once you click on Try it Out in the top right : { \"issuer\": \"Digibank\", \"paperNumber\": \"0032\", \"currentOwner\": \"Digibank\", \"newOwner\": \"MagnetoCorp\", \"price\": \"400\", \"purchaseDateTime\": \"2020-06-10\" } 21. Do the same for the Redeem transaction once you click on Try it Out in the top right : { \"issuer\": \"Digibank\", \"paperNumber\": \"0032\", \"redeemingOwner\": \"MagnetoCorp\", \"redeemDateTime\": \"2020-11-30\" } 22. All of these transactions are being recorded on the IBM Blockchain Platform by going to your channel list and then viewing the block height and list of transactions. UPDATE OUR GITHUB TO ADD GETPAPER AND LET JENKINS GO BACK TO WORK xxiii See the successful job in Jenkins is github triggered. To get back to the project you can click Back to project . When the build is finished you can also reload the same page you were on before and see that is was updated as a new docker image was created and deployed to Kubernetes. ![jenkinsimages/successful_build_github_triggered.png] 1. Let's take advantage of our CI/CD pipeline, by adding our getAllPapersFromIssuer query. Important: For this section, the getAllPapersFromIssuer transaction is going to be referred as getPapers . It's the same logic, but we had to rename it due to some loopback issues. 2. To add our getPaper transaction we need to add a model, repository and controller. Make sure your are in the Desktop/digibank folder. Also, it is very important that what you see below is what you enter. Make sure you don't see dashes ( - ) in any of the prompts. : --- Make the Getpapers Model --- tecadmin@ubuntubase:~/Desktop/digibank$ cd /home/tecadmin/Desktop/digibank/ * * I realize, that I'm cd-ing into a folder I'm already in, but it is to make sure everyone in the lab is in the right folder! * tecadmin@ubuntubase:~/Desktop/digibank$ lb4 model ? Model class name: Getpapers ? Please select the model base class Entity (A persisted model with an ID) ? Allow additional (free-form) properties? No Model Getpapers will be created in src/models/getpapers.model.ts Let's add a property to Getpapers Enter an empty property name when done ? Enter the property name: issuer ? Property type: string ? Is issuer the ID property? Yes ? Is it required?: No ? Default value [leave blank for none]: Let's add another property to Getpapers Enter an empty property name when done ? Enter the property name: create src/models/getpapers.model.ts update src/models/index.ts Model Getpapers was created in src/models/ -- Create the Getpapers Repository --- tecadmin@ubuntubase:~/Desktop/digibank$ lb4 repository ? Please select the datasource DbDatasource ? Select the model(s) you want to generate a repository Getpapers ? Please select the repository base class DefaultCrudRepository (Legacy juggler bridge) create src/repositories/getpapers.repository.ts update src/repositories/index.ts Repository GetpapersRepository was created in src/repositories/ --- Create the Getpapers Controller --- tecadmin@ubuntubase:~/Desktop/digibank$ lb4 controller ? Controller class name: Getpapers Controller Getpapers will be created in src/controllers/getpapers.controller.ts ? What kind of controller would you like to generate? REST Controller with CRUD functions ? What is the name of the model to use with this CRUD repository? Getpapers ? What is the name of your CRUD repository? GetpapersRepository ? What is the type of your ID? string ? What is the base HTTP path name of the CRUD operations? /getpapers create src/controllers/getpapers.controller.ts update src/controllers/index.ts Controller Getpapers was created in src/controllers/ 3. Within VSCode, navigate to the digibank/src/repository folder. You will see 6 files, with 4 of them being our repositories. Open the getpaper.repository.ts file and make a change that I lay out below on line 8 : typeof Getpapers.prototype., --- Change To --- // typeof Getpapers.prototype., Save this file! 4. Within our digibank/src/controllers folder, open the getpapers.controller.ts file and delete all of the code within that controller. Next, paste in the code below : // Copyright IBM Corp. 2017,2018. All Rights Reserved. // Node module: @loopback/example-todo // This file is licensed under the MIT License. // License text available at https://opensource.org/licenses/MIT import { del, get, getFilterSchemaFor, param, patch, post, put, requestBody, } from '@loopback/rest'; import { Getpapers } from '../models'; import { BlockChainModule } from '../blockchainClient'; let blockchainClient = new BlockChainModule.BlockchainClient(); export class GetpapersController { constructor() { } @post('/getpapers', { responses: { '200': { description: 'Todo model instance', content: { 'application/json': { schema: { 'x-ts-type': Getpapers } } }, }, }, }) async createGetpapers(@requestBody() requestBody: Getpapers): Promise Getpapers { console.log('Buy, requestBody: ') console.log(requestBody) let networkObj = await blockchainClient.connectToNetwork(); if (!networkObj) { let errString = 'Error connecting to network'; let getpapers = new Getpapers({ issuer: errString }); return getpapers; } console.log('newtork obj: ') console.log(networkObj) let dataForGetpapers = { function: 'getAllPapersFromIssuer', issuer: requestBody.issuer, contract: networkObj.contract }; var resultString = await blockchainClient.getpapers(dataForGetpapers); console.log('result from blockchainClient.submitTransaction in controller: ') console.log(resultString); let result = JSON.parse(resultString); return result; } } Save this file! 5. Now, that we have made some further changes to our digibank folder, let's push it back up to GitHub : tecadmin@ubuntubase:~/Desktop/digibank$ cd /home/tecadmin/Desktop/digibank * * I realize, that I'm cd-ing into a folder I'm already in, but it is to make sure everyone in the lab is in the right folder! * tecadmin@ubuntubase:~/Desktop/digibank$ git add * tecadmin@ubuntubase:~/Desktop/digibank$ git commit -m 'blockchain is awesome' * * Your file changes and other output messages * tecadmin@ubuntubase:~/Desktop/digibank$ git push Counting objects: 53, done. Delta compression using up to 8 threads. Compressing objects: 100% (48/48), done. Writing objects: 100% (53/53), 13.95 KiB | 0 bytes/s, done. Total 53 (delta 6), reused 0 (delta 0) remote: Resolving deltas: 100% (6/6), done. To github.com:austingrice/digibank.git 140abdf..0666159 master - master LET JENKINS GO TO WORK BY MAKING A K8S DEPLOYMENT xxiv You can again click back to main project and see successfully running job. xxv We can also see how Jenkins keeps track of the jobs triggered by Github. xxvi We can also see our console output again selecting the screen from the picture in step xxv above this one. This console should show another successful job and we can now again visit the updated loopback. 6. Once you have your kubernetes deployment of our loopback application, go ahead and open it. Then go to the GetpapersController and then paste in the text below once you click on Try it Out : { \"issuer\": \"Digibank\" } xxvii It's time to cleanup the Github webhook since you are done with it. Go back to your fork of Github repository for this lab. Go to the settings page for the repository and then Webhooks. Click delete to clean up the Webhook. xxvii Finally, get a message confirming your deletion and pat yourself on the back for a job well done, but of course don't forget our now familiar friend Jenkins.","title":"Cicd"},{"location":"connect-home/","text":"Welcome to Marbles Connect-a-thon with IBM Blockchain Platform for IBM Cloud Private (IBP4ICP) The goal of the lab is to give you hands on experience interacting with IBM Blockchain Platform for IBM Cloud Private (IBP4ICP). You will take on the role of an organization that is part of a larger Hyperledger Fabric blockchain consortium called the Marbles business network. All of the components in the above diagram reside within an IBM Cloud Private (ICP) Kubernetes cluster running on Linux on System Z. IBP4ICP packages the Hyperledger Fabric components (Certificate Authority, Orderer, Peer) into Kubernetes Helm charts for deployment and management. For more information on IBP4ICP, please visit the official IBP4ICP documentation . This lab is broken into two parts. In the first part, you will interact with your deployed peer, and enable the Marbles front end application to connect to the marbles chaincode installed on your peer. In the second part, you will go through the process of enabling the Marbles application to deploy inside an ICP Kubernetes cluster. You will be able to transact marbles with the other lab participants who are all acting as their own organizations in the Marbles business network. Note This lab runs on Linux on IBM Z systems in the IBM Washington Systems Center (WSC). In order to connect to this environment, you must use the CISCO AnyConnect client to establish a virtual private network (VPN) connection into the WSC network. You will be given connection information at the beginning of the lab. Tip If you find any typos, errors, or just want to provide helpful feedback to make this lab better, please click on the GitHub icon in the lower left corner of this page to be taken to our GitHub repository, from where you can create an Issue to suggest a correction or improvement. Thanks for your feedback! Acknowledgements Latrell Freeman for providing us with the backbone automation scripts Dave Wakeman for providing guidance on using MkDocs to make this Github Pages site Thanks to the following people who helped us test out the labs: Steven Bodie, Kevin Breitenother, Victoria Coates, Jack Sykes, MacKenna Kelleher, Keziah Knopp, Jasmine Burgess, Barry Silliman, Austin Grice Authors Garrett Woodworth Jin VanStee","title":"Welcome to Marbles Connect-a-thon with IBM Blockchain Platform for IBM Cloud Private (IBP4ICP)"},{"location":"connect-home/#welcome-to-marbles-connect-a-thon-with-ibm-blockchain-platform-for-ibm-cloud-private-ibp4icp","text":"The goal of the lab is to give you hands on experience interacting with IBM Blockchain Platform for IBM Cloud Private (IBP4ICP). You will take on the role of an organization that is part of a larger Hyperledger Fabric blockchain consortium called the Marbles business network. All of the components in the above diagram reside within an IBM Cloud Private (ICP) Kubernetes cluster running on Linux on System Z. IBP4ICP packages the Hyperledger Fabric components (Certificate Authority, Orderer, Peer) into Kubernetes Helm charts for deployment and management. For more information on IBP4ICP, please visit the official IBP4ICP documentation . This lab is broken into two parts. In the first part, you will interact with your deployed peer, and enable the Marbles front end application to connect to the marbles chaincode installed on your peer. In the second part, you will go through the process of enabling the Marbles application to deploy inside an ICP Kubernetes cluster. You will be able to transact marbles with the other lab participants who are all acting as their own organizations in the Marbles business network. Note This lab runs on Linux on IBM Z systems in the IBM Washington Systems Center (WSC). In order to connect to this environment, you must use the CISCO AnyConnect client to establish a virtual private network (VPN) connection into the WSC network. You will be given connection information at the beginning of the lab. Tip If you find any typos, errors, or just want to provide helpful feedback to make this lab better, please click on the GitHub icon in the lower left corner of this page to be taken to our GitHub repository, from where you can create an Issue to suggest a correction or improvement. Thanks for your feedback!","title":"Welcome to Marbles Connect-a-thon with IBM Blockchain Platform for IBM Cloud Private (IBP4ICP)"},{"location":"connect-home/#acknowledgements","text":"Latrell Freeman for providing us with the backbone automation scripts Dave Wakeman for providing guidance on using MkDocs to make this Github Pages site Thanks to the following people who helped us test out the labs: Steven Bodie, Kevin Breitenother, Victoria Coates, Jack Sykes, MacKenna Kelleher, Keziah Knopp, Jasmine Burgess, Barry Silliman, Austin Grice","title":"Acknowledgements"},{"location":"connect-home/#authors","text":"Garrett Woodworth Jin VanStee","title":"Authors"},{"location":"connect-part1/","text":"Overview The goal of this part of the lab is to go through the process of using your peer with the fabric command line interface (cli) tools and connecting it with marbles. In this part of the lab, you will: Connect to your peer Log in to our Kubernetes cluster Take a look at your peer setup environment variables Check the chaincode on the peer and the channel Submit transactions with your peer to create yourself as a marbles owner with a marble Configure the marbles application to connect to your peer Connect the marbles application to your peer Connect to your peer An IBM Blockchain Platform network has been set up with an organization for each member of the lab in our IBM Cloud Private Kubernetes Cluster. The necessary certificate material and environment variables to operate your peer as well as the marbles project have been packaged into a container for your use during the lab. This container is labeled based on your team. Please open a terminal window on your computer, set your given ip address and ssh into that z machine IP_ADDRESS=givenip ssh bcuser@$IP_ADDRESS Sample Output: Welcome to Ubuntu 16.04.5 LTS (GNU/Linux 4.4.0-139-generic s390x) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantage Last login: Mon Jan 21 21:43:38 2019 from 192.168.22.64 bcuser@ubuntu16045:~ Then, add the cluster to your /etc/hosts and add the self-signed certificate to your ca-certificates (Note: Please run this command exactly as printed below keeping the 192.168.22.81 ip address which is the address to access our ICP Kubernetes cluster) echo 192.168.22.81 wsc-ibp-icp-cluster.icp | sudo tee --append /etc/hosts sudo mkdir /usr/local/share/ca-certificates/wsc-ibp-icp-cluster.icp sudo openssl s_client -showcerts -servername wsc-ibp-icp-cluster.icp -connect wsc-ibp-icp-cluster.icp:8443 /dev/null 2 /dev/null | sudo openssl x509 | sudo tee /usr/local/share/ca-certificates/wsc-ibp-icp-cluster.icp/ca.crt sudo update-ca-certificates Sample Output: 192.168.22.81 wsc-ibp-icp-cluster.icp -----BEGIN CERTIFICATE----- MIIFfjCCA2agAwIBAgIQbJlENedx5PvDbGD7XLDnITANBgkqhkiG9w0BAQsFADBj MQswCQYDVQQGEwJVUzERMA8GA1UECAwITmV3IFlvcmsxDzANBgNVBAcMBkFybW9u azEaMBgGA1UECgwRSUJNIENsb3VkIFByaXZhdGUxFDASBgNVBAMMC3d3dy5pYm0u Y29tMCAXDTE4MTIxMjE5NTQ1MVoYDzIxMTgxMTE4MTk1NDUxWjBgMQswCQYDVQQG EwJDTjEQMA4GA1UECAwHU2hhYW54aTEOMAwGA1UEBwwFWGknYW4xGjAYBgNVBAoM EUlCTSBDbG91ZCBQcml2YXRlMRMwEQYDVQQDDAppY3Atcm91dGVyMIIBIjANBgkq hkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArsBisMJEyMGHZ+93mcFsXX0AQc+QXSVW o53f3JEd2Kn+tZLx57vOzRWmMop7B1pSe06c1GwFKofOWSTgHCHv8DO8+h9TIm3x +9IUaLx65mxrTMToUjIxjNyt2JjElHJskxrbpwJsofG59gxhGal8ed89SveXYIL/ PkXvkm5jsoPaRFjgQq0KJoy9UO26aD/FMJu9HzV+7P6Tu8Q+OJHgWSvIgKfX9vOg qyMxv8vGYEGh4jLgQFRMMfXdH01y2diZ259771wHjsTdMRUnxRC36RTDgIXp+0CR 143p1+dmucYD5G45rOwzPuDi67VNho8mtXs5ohTQfovj4FdcDVtFgQIDAQABo4IB LTCCASkwCQYDVR0TBAIwADAdBgNVHQ4EFgQUIMoa55D0BPmJ5FYOEiIa6mw+qtYw gZUGA1UdIwSBjTCBioAUZ9zE9CrhJ2Lm/tLiDLDK5H3asjqhZ6RlMGMxCzAJBgNV BAYTAlVTMREwDwYDVQQIDAhOZXcgWW9yazEPMA0GA1UEBwwGQXJtb25rMRowGAYD VQQKDBFJQk0gQ2xvdWQgUHJpdmF0ZTEUMBIGA1UEAwwLd3d3LmlibS5jb22CCQCV Y/GaGOxNzTAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwCwYDVR0PBAQD AgWgMDkGA1UdEQQyMDCHBH8AAAGCCWxvY2FsaG9zdIcEwKgWUYIXd3NjLWlicC1p Y3AtY2x1c3Rlci5pY3AwDQYJKoZIhvcNAQELBQADggIBABCkUfS8TTO2sPJlJjAn ZiatcrliKZ2KJqdNNouF68E+xHfthfXxhl93TP5oUEw7lFN8yRb+z0o16wZksliw h8FpunHZAuQ+M2qI3afIiRU2H58drGHkBmbZwoMYAQaFrU+A9VEzgibtjBHCkL4p g+3kzQySCJq+A9lmVq/gwrd3cqfPxsFckqq1eGvP8BfcwxvkUIPnOp/Vh9f2jgK7 UNfmPd4hZSzTr2jOfdBAGaltc4C+MAougCAppz7cVQXvb9A2b7ffF3JmYbr626Bk Pp7c0rZAzLRsoZy8ngT9zS+9CucY8MolpPDQmBL48asaMYCRgTx6wAgD6bDzJnpt F0c+FFf7k4782vJELs4gwXkkWRVmaHBlHn4yfYObsiS23snhu2Fvuu2bBWmFMXEr PCK9d1JO1czb672fd18aOj6pmNLZMiIfwIxOxkDpASa4urOhA4sV/61cTpxCSuGs MFhrLN9rKvPlQCh+z/gLPvcf/DVuKoRO+JIVLKl7oSp4GQY7HjdpzggUvCxayp3J EUe4eqOnN50oogTFw8FA4/mNrMzt4wXfk/1yPgWS9ey0EBuFg8fTi2GjLuR00Xsb pjbmU0n0RUpzWdZBHZwb2SpvA6D5M7Ii+aFM0eH5YK5gCU9U9x3hI1MjAtVsINsF cTiYtc/9hu704vR7CQ3uFvOk -----END CERTIFICATE----- Updating certificates in /etc/ssl/certs... 1 added, 0 removed; done. Running hooks in /etc/ca-certificates/update.d... done. Take particular note that 1 certificate was added and 0 removed in your output like in the sample output above. Next, restart your docker service to pick up the newly added certificate: sudo service docker restart Next, login to the private docker repository: echo $credential | docker login wsc-ibp-icp-cluster.icp:8500 -u $TEAM --password-stdin Sample Output: Login Succeeded Now, start your unique image which will return a command prompt: docker run --rm -it -v /var/run/docker.sock:/var/run/docker.sock --name $TEAM -p 3000:3001 wsc-ibp-icp-cluster.icp:8500/lab-test/connectathon-s390x-$TEAM:1.0 bash This command is using Docker to run your team's container in an interactive bash shell and connect it to your machine's docker socket so you can create sibling containers from your container image. Additionally, you are giving it the name of your team and forwarding traffic on port 3000 of the host to port 3001 on your container to access your marbles application during the lab. This means marbles comes up on port 3000 in this part1 of the connectathon versus port 3001 in part2. This makes it so that no port conflicts occur during the lab. Login to our Kubernetes cluster Run the following command to connect to the running IBM Cloud Private Kubernetes cluster. cloudctl login -a https://192.168.22.81:8443 -u $team -p $credential -n lab-test Sample Output: Targeted account wsc-ibp-icp-cluster Account (id-wsc-ibp-icp-cluster-account) Targeted namespace lab-test Configuring kubectl ... Property clusters.wsc-ibp-icp-cluster unset. Property users.wsc-ibp-icp-cluster-user unset. Property contexts.wsc-ibp-icp-cluster-context unset. Cluster wsc-ibp-icp-cluster set. User wsc-ibp-icp-cluster-user set. Context wsc-ibp-icp-cluster-context created. Switched to context wsc-ibp-icp-cluster-context . OK Configuring helm: /root/.helm OK Take a look at your peer setup environment variables In order to operate your peer a number of environment variables need to be set. Let's take a look at some of the environment variables set for the Hyperledger Fabric cli to work with your peer: env | grep \"CORE\\|FABRIC\" Sample Output: CORE_PEER_LOCALMSPID=org0 FABRIC_CFG_PATH=/home/fabric-ca-client/fabric-binaries/config CORE_PEER_TLS_ENABLED=true CORE_PEER_MSPCONFIGPATH=/home/org0/admin CORE_PEER_TLS_ROOTCERT_FILE=/home/org0/peertls.pem CORE_PEER_ADDRESS=192.168.22.81:30787 CORE_PEER_LOCALMSPID defines the local MSP or Membership Services Provider of the peer which contains the identifying information (i.e., certs and keys) for the peer as well as the certificates of trusted Certificate Authorities which are authorized to issue identities on behalf of the organization. (In the sample output above org0 is the MSPID, yours will correspond with your team) FABRIC_CFG_PATH=/home/fabric-ca-client/fabric-binaries/config defines the config path that holds config files such as core.yaml required for some fabric binary tools such as the peer command used in peer chaincode list --installed below. CORE_PEER_TLS_ENABLED=true is used to enable transport layer security (TLS) communication. CORE_PEER_MSPCONFIGPATH points to the MSP material you are using to operate the peer CORE_PEER_TLS_ROOTCERT_FILE is the path to the root TLS certificate for the peer which your system needs to trust to have a TLS connection with the peer. CORE_PEER_ADDRESS is the peer's IP address used to connect with the peer. Additionally, a few more variables are set for ease of use in later commands. You can see the values of these variables with the command below: env | grep \"CHANNEL\\|CC_NAME\\|ORDERER_CA\\|ORDERER_1\\|team\\|credential\" | grep -v \"DOCKER\" Sample Output: ORDERER_1=192.168.22.81:30634 CC_NAME=marbles CHANNEL=mychannel team=team00 ORDERER_CA=/home/org0/ordererca.pem credential=p@ssw0rd ORDERER_1 is the orderer's IP address used to connect to the orderer. CC_NAME is the name of the chaincode that we are targeting on the channel. CHANNEL is the name of the channel we are targeting. Remember a channel in Hyperledger Fabric is it's own subnetwork of communication with its own ledger. team is the name of the team that you are a part of for this lab which is used to differentiate between different lab members. ORDERER_CA is the path to the root TLS certificate for the orderer which your system needs to trust to have a TLS connection with the orderer. credential is the password you will use to authenticate to the cluster for both the private docker registry as well as the Kubernetes API server. Check the chaincode on the peer and the channel In order to check which chaincode is installed on your peer run: peer chaincode list --installed Sample Output: Get installed chaincodes on peer: Name: marbles, Version: 1.0, Path: marbles, Id: 4421fd51a7949b08620ab8db7407d1269c38e4ef2edd143b1a78d56ae82eaa2d You will notice the marbles chaincode has been installed on your peer. Next, let's check which chaincode is instantiated on the channel: peer chaincode list --instantiated -C $CHANNEL Sample Output: Get instantiated chaincodes on channel mychannel: Name: marbles, Version: 1.0, Path: marbles, Escc: escc, Vscc: vscc Here, you see the marbles chaincode has also been instantiated on the channel and is ready to be used to submit transactions. Submit transactions with the peer to create yourself as a marbles owner with a marble of your own Now it's time for one of your team members to add yourself as a marbles owner to the channel. First set your name as the marbles owner owner=Garrett Then create the owner with the following command: peer chaincode invoke -C ${CHANNEL} -n ${CC_NAME} -c '{ Args :[ init_owner , o0'$team' , '$owner' , '$CORE_PEER_LOCALMSPID' ]}' --tls --cafile $ORDERER_CA -o ${ORDERER_1} Sample Output: 2019-03-08 03:47:55.093 UTC [chaincodeCmd] chaincodeInvokeOrQuery - INFO 001 Chaincode invoke successful. result: status:200 Next, give your owner a black marble: peer chaincode invoke -C ${CHANNEL} -n ${CC_NAME} -c '{ Args :[ init_marble , m0'$team' , black , 200 , o0'$team' , '$CORE_PEER_LOCALMSPID' ]}' --tls --cafile $ORDERER_CA -o ${ORDERER_1} Sample Output 2019-03-08 03:48:02.027 UTC [chaincodeCmd] chaincodeInvokeOrQuery - INFO 001 Chaincode invoke successful. result: status:200 Finally, run a query against the ledger to see your owner and marble as well as everyone else's so far: peer chaincode invoke -C ${CHANNEL} -n ${CC_NAME} -c '{ Args :[ read_everything ]}' --tls --cafile $ORDERER_CA -o ${ORDERER_1} Sample Output: 2019-03-15 08:47:04.730 UTC [chaincodeCmd] chaincodeInvokeOrQuery - INFO 001 Chaincode invoke successful. result: status:200 payload: {\\ owners\\ :[{\\ docType\\ :\\ marble_owner\\ ,\\ id\\ :\\ o015525575491703BpSw\\ ,\\ username\\ :\\ rick\\ ,\\ company\\ :\\ org0\\ ,\\ enabled\\ :true} Note: This will grow as more marbles and owners get added to the ledger by your org and other orgs. Configure the marbles application to connect to your peer Go into the marbles directory: cd marbles/config The marbles application will connect to your fabric network using the Hyperledger Fabric Node.js Software Development Kit (SDK) Application Programming Interface (API) by consuming information in the file connection_profile_tls.json Take a look at this file with cat connection_profile_tls.json Take note that this file has connection information and TLS certificates for your, peers, certificate authority (CA), and the orderer for your network. Next, you will be able to specify which users you want to enroll in your application. Edit the file marbles_tls.json to do this: vim marbles_tls.json Edit the names to what you want in the usernames section such as: { cred_filename : connection_profile_tls.json , use_events : true, keep_alive_secs : 120, usernames : [ Beth , Rick , Jerry ], port : 3001 } In vim you edit by typing i and then making your changes using the arrow keys to navigate. Once you are finished making changes hit the escape key. Then save your changes with a save command such as :x , holding down shift and typing ZZ ( shift + ZZ ), shift + ZQ or using the worst option :wq . Once the file has been saved, move back to the parent directory with cd .. Connect the marbles application to your peer Run npm install -g gulp This will install the gulp npm package necessary to run the marbles application. Warnings are to be expected and are normal at this step and the following npm install step. Run npm install This will install the dependencies for the marbles application specified in the package.json file in the /home/marbles directory. This may take a few minutes. You will notice a bunch of CXX(target) in the output of this command because two of the packages (i.e., pkcs11js and grpc) need to be compiled from source for s390x. This needs to happen since the binaries are not publicly available for this platform. When this command completes it will return your terminal to you. Now you can start the marbles application with gulp marbles_tls Open up a web browser on your pc and navigate to the ip given to you earlier at port 3000 in the form xxx.xxx.xxx.xxx:3000 where xxx.xxx.xxx.xxx is your given ip address with each x being a possible digit (e.g., 192.168.22.150:3000 ). First, choose Express to setup your marbles application Here you can see your org's owners and marbles. You created the owner with your name and a black marble to its name with the cli commands at the beginning of this part of the lab. You created the other three owners by specifying the parameters in the marbles_tls.json file. If you are wondering about marble colors you created a black marble with the cli and the application randomly selected a color for the marbles created from the marbles_tls.json file (in my case black, but your mileage with the random function may vary) We can also see the other orgs and their marbles that are connected in this connectathon. Next, turn on story mode to see the marble transaction process: Click on settings Enable Story Mode Finally, trade some marbles to other users. Click on a marble from a user in your org and drag it to another user in your org Click and drag a marble from a member in your org and move it to a member of a different org Click and drag a marble from a member of a different org and drag it to a member of your org Notice that you can give marbles to other orgs but can't take them. Please think about the logic for why this may be the case for this use case... Now close the application by returning to your terminal and typing ctrl + c to get back your terminal prompt. You have now setup the marbles application. Please move on to part 2 where you will deploy this into our Kubernetes cluster.","title":"Connect part1"},{"location":"connect-part1/#overview","text":"The goal of this part of the lab is to go through the process of using your peer with the fabric command line interface (cli) tools and connecting it with marbles. In this part of the lab, you will: Connect to your peer Log in to our Kubernetes cluster Take a look at your peer setup environment variables Check the chaincode on the peer and the channel Submit transactions with your peer to create yourself as a marbles owner with a marble Configure the marbles application to connect to your peer Connect the marbles application to your peer","title":"Overview"},{"location":"connect-part1/#connect-to-your-peer","text":"An IBM Blockchain Platform network has been set up with an organization for each member of the lab in our IBM Cloud Private Kubernetes Cluster. The necessary certificate material and environment variables to operate your peer as well as the marbles project have been packaged into a container for your use during the lab. This container is labeled based on your team. Please open a terminal window on your computer, set your given ip address and ssh into that z machine IP_ADDRESS=givenip ssh bcuser@$IP_ADDRESS Sample Output: Welcome to Ubuntu 16.04.5 LTS (GNU/Linux 4.4.0-139-generic s390x) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantage Last login: Mon Jan 21 21:43:38 2019 from 192.168.22.64 bcuser@ubuntu16045:~ Then, add the cluster to your /etc/hosts and add the self-signed certificate to your ca-certificates (Note: Please run this command exactly as printed below keeping the 192.168.22.81 ip address which is the address to access our ICP Kubernetes cluster) echo 192.168.22.81 wsc-ibp-icp-cluster.icp | sudo tee --append /etc/hosts sudo mkdir /usr/local/share/ca-certificates/wsc-ibp-icp-cluster.icp sudo openssl s_client -showcerts -servername wsc-ibp-icp-cluster.icp -connect wsc-ibp-icp-cluster.icp:8443 /dev/null 2 /dev/null | sudo openssl x509 | sudo tee /usr/local/share/ca-certificates/wsc-ibp-icp-cluster.icp/ca.crt sudo update-ca-certificates Sample Output: 192.168.22.81 wsc-ibp-icp-cluster.icp -----BEGIN CERTIFICATE----- MIIFfjCCA2agAwIBAgIQbJlENedx5PvDbGD7XLDnITANBgkqhkiG9w0BAQsFADBj MQswCQYDVQQGEwJVUzERMA8GA1UECAwITmV3IFlvcmsxDzANBgNVBAcMBkFybW9u azEaMBgGA1UECgwRSUJNIENsb3VkIFByaXZhdGUxFDASBgNVBAMMC3d3dy5pYm0u Y29tMCAXDTE4MTIxMjE5NTQ1MVoYDzIxMTgxMTE4MTk1NDUxWjBgMQswCQYDVQQG EwJDTjEQMA4GA1UECAwHU2hhYW54aTEOMAwGA1UEBwwFWGknYW4xGjAYBgNVBAoM EUlCTSBDbG91ZCBQcml2YXRlMRMwEQYDVQQDDAppY3Atcm91dGVyMIIBIjANBgkq hkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArsBisMJEyMGHZ+93mcFsXX0AQc+QXSVW o53f3JEd2Kn+tZLx57vOzRWmMop7B1pSe06c1GwFKofOWSTgHCHv8DO8+h9TIm3x +9IUaLx65mxrTMToUjIxjNyt2JjElHJskxrbpwJsofG59gxhGal8ed89SveXYIL/ PkXvkm5jsoPaRFjgQq0KJoy9UO26aD/FMJu9HzV+7P6Tu8Q+OJHgWSvIgKfX9vOg qyMxv8vGYEGh4jLgQFRMMfXdH01y2diZ259771wHjsTdMRUnxRC36RTDgIXp+0CR 143p1+dmucYD5G45rOwzPuDi67VNho8mtXs5ohTQfovj4FdcDVtFgQIDAQABo4IB LTCCASkwCQYDVR0TBAIwADAdBgNVHQ4EFgQUIMoa55D0BPmJ5FYOEiIa6mw+qtYw gZUGA1UdIwSBjTCBioAUZ9zE9CrhJ2Lm/tLiDLDK5H3asjqhZ6RlMGMxCzAJBgNV BAYTAlVTMREwDwYDVQQIDAhOZXcgWW9yazEPMA0GA1UEBwwGQXJtb25rMRowGAYD VQQKDBFJQk0gQ2xvdWQgUHJpdmF0ZTEUMBIGA1UEAwwLd3d3LmlibS5jb22CCQCV Y/GaGOxNzTAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwCwYDVR0PBAQD AgWgMDkGA1UdEQQyMDCHBH8AAAGCCWxvY2FsaG9zdIcEwKgWUYIXd3NjLWlicC1p Y3AtY2x1c3Rlci5pY3AwDQYJKoZIhvcNAQELBQADggIBABCkUfS8TTO2sPJlJjAn ZiatcrliKZ2KJqdNNouF68E+xHfthfXxhl93TP5oUEw7lFN8yRb+z0o16wZksliw h8FpunHZAuQ+M2qI3afIiRU2H58drGHkBmbZwoMYAQaFrU+A9VEzgibtjBHCkL4p g+3kzQySCJq+A9lmVq/gwrd3cqfPxsFckqq1eGvP8BfcwxvkUIPnOp/Vh9f2jgK7 UNfmPd4hZSzTr2jOfdBAGaltc4C+MAougCAppz7cVQXvb9A2b7ffF3JmYbr626Bk Pp7c0rZAzLRsoZy8ngT9zS+9CucY8MolpPDQmBL48asaMYCRgTx6wAgD6bDzJnpt F0c+FFf7k4782vJELs4gwXkkWRVmaHBlHn4yfYObsiS23snhu2Fvuu2bBWmFMXEr PCK9d1JO1czb672fd18aOj6pmNLZMiIfwIxOxkDpASa4urOhA4sV/61cTpxCSuGs MFhrLN9rKvPlQCh+z/gLPvcf/DVuKoRO+JIVLKl7oSp4GQY7HjdpzggUvCxayp3J EUe4eqOnN50oogTFw8FA4/mNrMzt4wXfk/1yPgWS9ey0EBuFg8fTi2GjLuR00Xsb pjbmU0n0RUpzWdZBHZwb2SpvA6D5M7Ii+aFM0eH5YK5gCU9U9x3hI1MjAtVsINsF cTiYtc/9hu704vR7CQ3uFvOk -----END CERTIFICATE----- Updating certificates in /etc/ssl/certs... 1 added, 0 removed; done. Running hooks in /etc/ca-certificates/update.d... done. Take particular note that 1 certificate was added and 0 removed in your output like in the sample output above. Next, restart your docker service to pick up the newly added certificate: sudo service docker restart Next, login to the private docker repository: echo $credential | docker login wsc-ibp-icp-cluster.icp:8500 -u $TEAM --password-stdin Sample Output: Login Succeeded Now, start your unique image which will return a command prompt: docker run --rm -it -v /var/run/docker.sock:/var/run/docker.sock --name $TEAM -p 3000:3001 wsc-ibp-icp-cluster.icp:8500/lab-test/connectathon-s390x-$TEAM:1.0 bash This command is using Docker to run your team's container in an interactive bash shell and connect it to your machine's docker socket so you can create sibling containers from your container image. Additionally, you are giving it the name of your team and forwarding traffic on port 3000 of the host to port 3001 on your container to access your marbles application during the lab. This means marbles comes up on port 3000 in this part1 of the connectathon versus port 3001 in part2. This makes it so that no port conflicts occur during the lab.","title":"Connect to your peer"},{"location":"connect-part1/#login-to-our-kubernetes-cluster","text":"Run the following command to connect to the running IBM Cloud Private Kubernetes cluster. cloudctl login -a https://192.168.22.81:8443 -u $team -p $credential -n lab-test Sample Output: Targeted account wsc-ibp-icp-cluster Account (id-wsc-ibp-icp-cluster-account) Targeted namespace lab-test Configuring kubectl ... Property clusters.wsc-ibp-icp-cluster unset. Property users.wsc-ibp-icp-cluster-user unset. Property contexts.wsc-ibp-icp-cluster-context unset. Cluster wsc-ibp-icp-cluster set. User wsc-ibp-icp-cluster-user set. Context wsc-ibp-icp-cluster-context created. Switched to context wsc-ibp-icp-cluster-context . OK Configuring helm: /root/.helm OK","title":"Login to our Kubernetes cluster"},{"location":"connect-part1/#take-a-look-at-your-peer-setup-environment-variables","text":"In order to operate your peer a number of environment variables need to be set. Let's take a look at some of the environment variables set for the Hyperledger Fabric cli to work with your peer: env | grep \"CORE\\|FABRIC\" Sample Output: CORE_PEER_LOCALMSPID=org0 FABRIC_CFG_PATH=/home/fabric-ca-client/fabric-binaries/config CORE_PEER_TLS_ENABLED=true CORE_PEER_MSPCONFIGPATH=/home/org0/admin CORE_PEER_TLS_ROOTCERT_FILE=/home/org0/peertls.pem CORE_PEER_ADDRESS=192.168.22.81:30787 CORE_PEER_LOCALMSPID defines the local MSP or Membership Services Provider of the peer which contains the identifying information (i.e., certs and keys) for the peer as well as the certificates of trusted Certificate Authorities which are authorized to issue identities on behalf of the organization. (In the sample output above org0 is the MSPID, yours will correspond with your team) FABRIC_CFG_PATH=/home/fabric-ca-client/fabric-binaries/config defines the config path that holds config files such as core.yaml required for some fabric binary tools such as the peer command used in peer chaincode list --installed below. CORE_PEER_TLS_ENABLED=true is used to enable transport layer security (TLS) communication. CORE_PEER_MSPCONFIGPATH points to the MSP material you are using to operate the peer CORE_PEER_TLS_ROOTCERT_FILE is the path to the root TLS certificate for the peer which your system needs to trust to have a TLS connection with the peer. CORE_PEER_ADDRESS is the peer's IP address used to connect with the peer. Additionally, a few more variables are set for ease of use in later commands. You can see the values of these variables with the command below: env | grep \"CHANNEL\\|CC_NAME\\|ORDERER_CA\\|ORDERER_1\\|team\\|credential\" | grep -v \"DOCKER\" Sample Output: ORDERER_1=192.168.22.81:30634 CC_NAME=marbles CHANNEL=mychannel team=team00 ORDERER_CA=/home/org0/ordererca.pem credential=p@ssw0rd ORDERER_1 is the orderer's IP address used to connect to the orderer. CC_NAME is the name of the chaincode that we are targeting on the channel. CHANNEL is the name of the channel we are targeting. Remember a channel in Hyperledger Fabric is it's own subnetwork of communication with its own ledger. team is the name of the team that you are a part of for this lab which is used to differentiate between different lab members. ORDERER_CA is the path to the root TLS certificate for the orderer which your system needs to trust to have a TLS connection with the orderer. credential is the password you will use to authenticate to the cluster for both the private docker registry as well as the Kubernetes API server.","title":"Take a look at your peer setup environment variables"},{"location":"connect-part1/#check-the-chaincode-on-the-peer-and-the-channel","text":"In order to check which chaincode is installed on your peer run: peer chaincode list --installed Sample Output: Get installed chaincodes on peer: Name: marbles, Version: 1.0, Path: marbles, Id: 4421fd51a7949b08620ab8db7407d1269c38e4ef2edd143b1a78d56ae82eaa2d You will notice the marbles chaincode has been installed on your peer. Next, let's check which chaincode is instantiated on the channel: peer chaincode list --instantiated -C $CHANNEL Sample Output: Get instantiated chaincodes on channel mychannel: Name: marbles, Version: 1.0, Path: marbles, Escc: escc, Vscc: vscc Here, you see the marbles chaincode has also been instantiated on the channel and is ready to be used to submit transactions.","title":"Check the chaincode on the peer and the channel"},{"location":"connect-part1/#submit-transactions-with-the-peer-to-create-yourself-as-a-marbles-owner-with-a-marble-of-your-own","text":"Now it's time for one of your team members to add yourself as a marbles owner to the channel. First set your name as the marbles owner owner=Garrett Then create the owner with the following command: peer chaincode invoke -C ${CHANNEL} -n ${CC_NAME} -c '{ Args :[ init_owner , o0'$team' , '$owner' , '$CORE_PEER_LOCALMSPID' ]}' --tls --cafile $ORDERER_CA -o ${ORDERER_1} Sample Output: 2019-03-08 03:47:55.093 UTC [chaincodeCmd] chaincodeInvokeOrQuery - INFO 001 Chaincode invoke successful. result: status:200 Next, give your owner a black marble: peer chaincode invoke -C ${CHANNEL} -n ${CC_NAME} -c '{ Args :[ init_marble , m0'$team' , black , 200 , o0'$team' , '$CORE_PEER_LOCALMSPID' ]}' --tls --cafile $ORDERER_CA -o ${ORDERER_1} Sample Output 2019-03-08 03:48:02.027 UTC [chaincodeCmd] chaincodeInvokeOrQuery - INFO 001 Chaincode invoke successful. result: status:200 Finally, run a query against the ledger to see your owner and marble as well as everyone else's so far: peer chaincode invoke -C ${CHANNEL} -n ${CC_NAME} -c '{ Args :[ read_everything ]}' --tls --cafile $ORDERER_CA -o ${ORDERER_1} Sample Output: 2019-03-15 08:47:04.730 UTC [chaincodeCmd] chaincodeInvokeOrQuery - INFO 001 Chaincode invoke successful. result: status:200 payload: {\\ owners\\ :[{\\ docType\\ :\\ marble_owner\\ ,\\ id\\ :\\ o015525575491703BpSw\\ ,\\ username\\ :\\ rick\\ ,\\ company\\ :\\ org0\\ ,\\ enabled\\ :true} Note: This will grow as more marbles and owners get added to the ledger by your org and other orgs.","title":"Submit transactions with the peer to create yourself as a marbles owner with a marble of your own"},{"location":"connect-part1/#configure-the-marbles-application-to-connect-to-your-peer","text":"Go into the marbles directory: cd marbles/config The marbles application will connect to your fabric network using the Hyperledger Fabric Node.js Software Development Kit (SDK) Application Programming Interface (API) by consuming information in the file connection_profile_tls.json Take a look at this file with cat connection_profile_tls.json Take note that this file has connection information and TLS certificates for your, peers, certificate authority (CA), and the orderer for your network. Next, you will be able to specify which users you want to enroll in your application. Edit the file marbles_tls.json to do this: vim marbles_tls.json Edit the names to what you want in the usernames section such as: { cred_filename : connection_profile_tls.json , use_events : true, keep_alive_secs : 120, usernames : [ Beth , Rick , Jerry ], port : 3001 } In vim you edit by typing i and then making your changes using the arrow keys to navigate. Once you are finished making changes hit the escape key. Then save your changes with a save command such as :x , holding down shift and typing ZZ ( shift + ZZ ), shift + ZQ or using the worst option :wq . Once the file has been saved, move back to the parent directory with cd ..","title":"Configure the marbles application to connect to your peer"},{"location":"connect-part1/#connect-the-marbles-application-to-your-peer","text":"Run npm install -g gulp This will install the gulp npm package necessary to run the marbles application. Warnings are to be expected and are normal at this step and the following npm install step. Run npm install This will install the dependencies for the marbles application specified in the package.json file in the /home/marbles directory. This may take a few minutes. You will notice a bunch of CXX(target) in the output of this command because two of the packages (i.e., pkcs11js and grpc) need to be compiled from source for s390x. This needs to happen since the binaries are not publicly available for this platform. When this command completes it will return your terminal to you. Now you can start the marbles application with gulp marbles_tls Open up a web browser on your pc and navigate to the ip given to you earlier at port 3000 in the form xxx.xxx.xxx.xxx:3000 where xxx.xxx.xxx.xxx is your given ip address with each x being a possible digit (e.g., 192.168.22.150:3000 ). First, choose Express to setup your marbles application Here you can see your org's owners and marbles. You created the owner with your name and a black marble to its name with the cli commands at the beginning of this part of the lab. You created the other three owners by specifying the parameters in the marbles_tls.json file. If you are wondering about marble colors you created a black marble with the cli and the application randomly selected a color for the marbles created from the marbles_tls.json file (in my case black, but your mileage with the random function may vary) We can also see the other orgs and their marbles that are connected in this connectathon. Next, turn on story mode to see the marble transaction process: Click on settings Enable Story Mode Finally, trade some marbles to other users. Click on a marble from a user in your org and drag it to another user in your org Click and drag a marble from a member in your org and move it to a member of a different org Click and drag a marble from a member of a different org and drag it to a member of your org Notice that you can give marbles to other orgs but can't take them. Please think about the logic for why this may be the case for this use case... Now close the application by returning to your terminal and typing ctrl + c to get back your terminal prompt. You have now setup the marbles application. Please move on to part 2 where you will deploy this into our Kubernetes cluster.","title":"Connect the marbles application to your peer"},{"location":"connect-part2/","text":"Overview The goal of this part of the lab is to guide you through the process of packaging up a blockchain front end application to run inside a Kubernetes cluster. In the lab environment, this happens to be the same cluster that is hosting your blockchain components. In the real world, this may not always be the case. In this part of the lab, you will: Build a docker image with the Marbles UI Test the container locally on your Linux image Push the image to the ICP cluster's private docker registry Create a Kubernetes deployment and service for the Marbles UI Deploy the Kubernetes deployment Test the marbles UI Only if you stopped in between the lab parts 1 and 2 Make sure you still have an ssh connection to your bcuser instance. If not please rerun IP_ADDRESS=givenip for your given ip and ssh bcuser@$IP_ADDRESS Check to make sure you are still inside your docker image. If you got out of your docker image, go back into the image by first setting your TEAM with TEAM=teamxx where xx is the number of your team. Then, check if your container is still running with docker ps | grep team a) If you get sample output showing a container such as: 6e6ad92499b1 wsc-ibp-icp-cluster.icp:8500/lab-test/connectathon-s390x-team10:1.0 \"bash\" 12 minutes ago Up 12 minutes 0.0.0.0:3000- 3001/tcp team10 follow Option a) of step 3 below b) If you get sample output not showing anything such as: follow Option b) of step 3 below Do only 1 of the options below based on step 2 above! a) exec back into your running container with docker exec -it $TEAM sh OR b) restart your container with docker run --rm -it -v /var/run/docker.sock:/var/run/docker.sock --name $TEAM -p 3000:3001 wsc-ibp-icp-cluster.icp:8500/lab-test/connectathon-s390x-$TEAM:1.0 bash Before you start, make sure you are still logged in to the cluster. Run the following commands to display the pods that are currently deployed to our cluster. First, type kubectl get pods Sample Output: NAME READY STATUS RESTARTS AGE connectathon-orderer-orderer-85bb44f87c-qk662 1/1 Running 0 1d connectathon-ordererorg-ca-fabric-ca-deployment-7f6b9b6577whxgr 1/1 Running 0 1d connectathon-org0-ca-fabric-ca-deployment-67cf7486dd-9wtg7 1/1 Running 0 1d connectathon-org0peer1-55fc894b9-5qncl 2/2 Running 0 1d connectathon-org1-ca-fabric-ca-deployment-59f9457fc5-9jmfp 1/1 Running 0 1d connectathon-org10-ca-fabric-ca-deployment-76794dcbbf-jdkcr 1/1 Running 0 1d connectathon-org10peer1-86dc5fcdf7-6c5qm 2/2 Running 0 39m connectathon-org11-ca-fabric-ca-deployment-5bc55cc776-5cjbz 1/1 Running 0 1d connectathon-org11peer1-69f67d965-svwjh 2/2 Running 0 1d connectathon-org1peer1-7665b7c6d7-x8spx 2/2 Running 0 1d connectathon-org2-ca-fabric-ca-deployment-787cbdf766-qwdjw 1/1 Running 0 1d connectathon-org2peer1-7d4bbfc7bf-gs9qv 2/2 Running 0 1d connectathon-org3-ca-fabric-ca-deployment-54cfc78777-m782f 1/1 Running 0 1d If you are able to see the output of the kubectl command such as above you are still logged in. If not, run: cloudctl login -a https://192.168.22.81:8443 -u $team -p $credential -n lab-test Sample Output: Targeted account wsc-ibp-icp-cluster Account (id-wsc-ibp-icp-cluster-account) Targeted namespace lab-test Configuring kubectl ... Property clusters.wsc-ibp-icp-cluster unset. Property users.wsc-ibp-icp-cluster-user unset. Property contexts.wsc-ibp-icp-cluster-context unset. Cluster wsc-ibp-icp-cluster set. User wsc-ibp-icp-cluster-user set. Context wsc-ibp-icp-cluster-context created. Switched to context wsc-ibp-icp-cluster-context . OK Configuring helm: /root/.helm OK Now, run kubectl get pods | grep $CORE_PEER_LOCALMSPID Sample Output: NAME READY STATUS RESTARTS AGE connectathon-org0-ca-fabric-ca-deployment-67cf7486dd-9wtg7 1/1 Running 0 7h connectathon-org0peer1-55fc894b9-5qncl 2/2 Running 0 7h You should see one peer pod, and one CA pod. Both should be in Running status. Your organization only has one peer in this scenario. Build a docker image Now that you have tested the Marbles front end User Interface (Marbles UI, for short), let's save it as a docker image using the supplied Dockerfile. A Dockerfile is a text document that contains all the commands a user could call on the command line to assemble an image. Think of it as a specific way to package up a set of files and instructions that together make up a microservice. Go to your marbles directory: cd /home/marbles Here you should see a Dockerfile: ls -ltr Dockerfile Sample Output: -rw-rw-r-- 1 1000 1000 394 Feb 28 22:12 Dockerfile If you are curious, cat the file to look at its contents: cat Dockerfile Sample Output: FROM node:8-alpine ENV NPM_CONFIG_LOGLEVEL warn RUN mkdir -p /usr/src/app WORKDIR /usr/src/app COPY package.json /usr/src/app/ RUN apk add --no-cache --virtual .build-deps make gcc g++ python \\ npm install \\ npm install gulp -g ---unsafe-perm \\ apk del .build-deps .build-deps make gcc g++ python COPY . /usr/src/app/ EXPOSE 3001 CMD [ gulp , marbles_tls ] The above Dockerfile builds from an Alpine node image in DockerHub. This is a bare bones Linux image of the Alpine distribution with node version 8 installed. Next, the NPM_CONFIG_LOGLEVEL for npm is globally set to warn so that npm will only print errors and warnings. ENV is used for this to persist this change as an environment variable in your finished container. Then, it uses RUN to execute a command inside of the base node:8-alpine container to make a directory for the marbles application. WORKDIR makes this directory the current working directory. Moreover, COPY brings the package.json file (containing the names of the application's dependent node modules) into the containers /usr/src/app directory. The following RUN command uses apk (Alpine's package manager) to install a variety of pre-reqs to your npm install such as make, gcc and python, before running the actual npm install twice to install both the necessary node modules for both the Marbles UI itself and gulp to start the marbles UI. Note that this is all done in one line with to make it occur in one layer. This way, at the end of the RUN command you can use a delete command apk del and take the developer tools you no longer need out of your image. If you instead ran this as multiple commands, you would not be able to shrink your image size since previous layers can't be effectively deleted due to the layered file system used for docker images. Finally, you copy the application itself and the connection profile materials into your working directory, document the port you will run marbles on ( 3001 ), and set a command for the container to run when it starts gulp marbles_tls . Now let's run docker build in the /home/marbles directory: docker build -t marbles-$team . NOTE: Please remember to not forget that pesky . Otherwise you will get an error saying \"docker build\" requires exactly 1 argument Sample Output: Sending build context to Docker daemon 261.9MB Step 1/9 : FROM node:8-alpine --- 66f08ecb7600 Step 2/9 : ENV NPM_CONFIG_LOGLEVEL warn --- Using cache --- 180c28267c41 Step 3/9 : RUN mkdir -p /usr/src/app --- Using cache --- f9615b4a1813 Step 4/9 : WORKDIR /usr/src/app --- Using cache --- e53d507c2bf9 .... .... lots more messages .... Successfully built 9b57c7c3e480 Successfully tagged marbles-team00:latest Now you should see this new image that you just built: docker images Sample Output: REPOSITORY TAG IMAGE ID CREATED SIZE marbles-team00 latest 5cc513286904 29 seconds ago 312MB wsc-ibp-icp-cluster.icp:8500/lab-test/connectathon-s390x-team00 1.0 a2d1b20e0e1e 12 hours ago 1.16GB node 8-alpine 030469210de8 2 weeks ago 69.5MB Test the docker image locally Let's test the image that was just built, by running it locally: docker run -it --init -p 3001:3001/tcp --name marbles-$team marbles-$team Sample Output [20:57:50] Using gulpfile /usr/src/app/gulpfile.js [20:57:50] Starting 'env_tls'... [20:57:50] Finished 'env_tls' after 73 \u03bcs [20:57:50] Starting 'build-sass'... [20:57:50] Finished 'build-sass' after 7.48 ms [20:57:50] Starting 'watch-sass'... [20:57:50] Finished 'watch-sass' after 7.47 ms [20:57:50] Starting 'watch-server'... [20:57:50] Finished 'watch-server' after 2.55 ms [20:57:50] Starting 'server'... info: Checking connection profile is done info: Loaded config file /usr/src/app/config/marbles_tls.json info: Loaded connection profile file /usr/src/app/config/connection_profile_tls.json ... lots of output ... - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - debug: Detected that we have launched successfully before debug: Welcome back - Marbles is ready debug: Open your browser to http://localhost:3001 and login as admin - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - After you see the \"Open your browser to https://localhost:3001\" message, point your browser to the IP address of your Linux image, e.g., http://192.168.22.107:3001 and you will see the Marbles UI. Once you verify that the image works locally, it's time to stop the running container. Type Ctrl + C to exit out of the running container in the current terminal. Push image to the ICP Cluster's private repo You will now tag the image you created with the private repo's host name and port number, followed by the namespace you are using, as follows. docker tag marbles-$team:latest wsc-ibp-icp-cluster.icp:8500/lab-test/marbles-$team:1.0 Log into the docker private registry using your teamNN id and credential, as follows: echo $credential | docker login wsc-ibp-icp-cluster.icp:8500 -u $team --password-stdin Sample Output: WARNING! Your password will be stored unencrypted in /root/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded Now push up the image using the tag you just created (again be mindful that the name pushed in the output will reflect your team name): docker push wsc-ibp-icp-cluster.icp:8500/lab-test/marbles-$team:1.0 Sample Output: The push refers to repository [wsc-ibp-icp-cluster.icp:8500/lab-test/marbles-team00] c8490573a0d8: Pushed 8e63f87572fb: Pushed a6a08bb664f7: Pushed 3a30ca7a2471: Pushed ccc0f617b78a: Pushed 1801fc515e2a: Pushed 1.0: digest: sha256:6a796e973817f714b64e767b3c35affd93a6dc5df7ef12ca872aca64d20a5155 size: 1997 Let's log in to the ICP Console for the first time and verify that your image got pushed up to the cluster's private docker registry. Point your browser to https://192.168.22.81:8443 . Accept that it's using a self-signed certificate. This should lead you to the sign in page. Log in with your team's credentials given to you at the beginning of the lab: you can find this by echoing the team and credential variables in your terminal: echo $team echo $credential . Your team is your username and your credential is your password. You can verify your image got pushed up by going to the hamburger menu on the top left corner and selecting Container Images and look for lab-test/marbles-teamNN. Note: you will have to go to the last page to see images under the namespace lab-test. Create a Kubernetes deployment and service Log in to the ICP cluster with your team's ID and password: cloudctl login -a https://192.168.22.81:8443 -u $team -p $credential -n lab-test Sample Output: Targeted account wsc-ibp-icp-cluster Account (id-wsc-ibp-icp-cluster-account) Targeted namespace lab-test Configuring kubectl ... Property clusters.wsc-ibp-icp-cluster unset. Property users.wsc-ibp-icp-cluster-user unset. Property contexts.wsc-ibp-icp-cluster-context unset. Cluster wsc-ibp-icp-cluster set. User wsc-ibp-icp-cluster-user set. Context wsc-ibp-icp-cluster-context created. Switched to context wsc-ibp-icp-cluster-context . OK Configuring helm: /root/.helm OK Verify that your organization's Fabric pods are running. Note that you have a Fabric CA pod and one Fabric peer pod running. The environment variable $CORE_PEER_LOCALMSPID was set for you and it was set to your peer's MSPID. In this lab environment, your MSPID corresponds to your team number. i.e. team01 will be org1, team02 will be org2, etc. kubectl get pods | grep connectathon-$CORE_PEER_LOCALMSPID Sample Output: connectathon-org0-ca-fabric-ca-deployment-67cf7486dd-xgqkb 1/1 Running 0 7h connectathon-org0peer1-55fc894b9-fhz2f 2/2 Running 0 7h You should have a Kubernetes deployment yaml file in your /home/marbles directory called marbles-teamNN.yaml . Kubernetes objects are defined in yaml files and then created on or applied to a running cluster. You can create a Kubernetes resource from the ICP Console as well. But here you will do this via the command line tool kubectl which interacts with the Kubernetes API Server on the cluster. Now run the following command to create a marbles deployment yaml file that matches your team name. cat marbles-teamNN.yaml | sed -r 's/teamNN/'$team'/' marbles-$team.yaml You can cat the yaml file to see its contents: cat marbles-$team.yaml Sample Output: apiVersion: v1 kind: Service metadata: name: marbles-team00-svc spec: selector: app: marbles-team00 ports: - protocol: TCP port: 3001 targetPort: 3001 type: NodePort --- apiVersion: extensions/v1beta1 kind: Deployment metadata: name: marbles-team00-deploy labels: app: marbles-team00 spec: selector: matchLabels: app: marbles-team00 replicas: 1 template: metadata: labels: app: marbles-team00 spec: nodeSelector: beta.kubernetes.io/arch: s390x containers: - name: marbles-team00 image: wsc-ibp-icp-cluster.icp:8500/lab-test/marbles-team00:1.0 ports: - containerPort: 3001 imagePullPolicy: Always The important parts to point out in the yaml file are that it will create a Kubernetes service called marbles-team00-svc and that it is pointing to the marbles-team00 container. The service will be of type NodePort which means this service will be reachable outside of the cluster. The yaml file will also create a Kubernetes deployment that has one pod with one container that will be based off of the wsc-ibp-icp-cluster.icp:8500/lab-test/marbles-team00:1.0 image that you pushed to the private image registry earlier. Finally, since you built the marbles-teamxx image with the s390x (z) architecture and there are machines with multiple different architectures in our cluster (s390x and amd64) you need to specify for it to run on s390x with a nodeSelector of beta.kubernetes.io/arch: s390x . If you built it for a different architecture, you would instead use a nodeSelector for that architecture. Deploy the service and test the Marbles UI Now you are ready to create the Kubernetes resources. Run the following command: kubectl apply -f marbles-$team.yaml service/marbles-team00-svc created deployment.extensions/marbles-team00-deploy created The deployment will create one pod that has one container. A service is also created. Check that your pod is READY 1/1 and in Running status: kubectl get pods | grep marbles-$team marbles-team00-deploy-55649dbc5b-xf787 1/1 Running 0 35s Launch the Marbles service and test the Marbles UI Now, let's navigate through the ICP Console to your deployment. Point your browser to https://192.168.22.81:8443 . Accept that it's using a self signed certificate. This should lead you to the sign in page. Log in with your team's credentials given to you at the beginning of the lab. Go to the hamburger menu on the upper left corner, and select Workloads - Deployments . Find your team's deployment, it should be similar to marbles-team00-deploy but with your team name. Click on your deployment. You will be taken to the details page of your deployment. Upon further exploration you will see the deployment has one ReplicaSet, and one Pod. You can choose to click into either the ReplicaSet or Pod to get details about those two objects. Now click on the Launch button for your deployment. This will bring up the Marbles UI. At this point, depending on where the other classroom students are, you will see two or more organizations in the Marbles UI. Test out the application by transacting some marbles with your neighboring students. Enabling Story Mode in Settings will provide a step by step guided experience during each transaction. Congratulations! You've successfully created a container for the Marbles front end application, created a Kubernetes deployment for it, and deployed it in a IBM Cloud Private Kubernetes cluster.","title":"Connect part2"},{"location":"connect-part2/#overview","text":"The goal of this part of the lab is to guide you through the process of packaging up a blockchain front end application to run inside a Kubernetes cluster. In the lab environment, this happens to be the same cluster that is hosting your blockchain components. In the real world, this may not always be the case. In this part of the lab, you will: Build a docker image with the Marbles UI Test the container locally on your Linux image Push the image to the ICP cluster's private docker registry Create a Kubernetes deployment and service for the Marbles UI Deploy the Kubernetes deployment Test the marbles UI","title":"Overview"},{"location":"connect-part2/#only-if-you-stopped-in-between-the-lab-parts-1-and-2","text":"Make sure you still have an ssh connection to your bcuser instance. If not please rerun IP_ADDRESS=givenip for your given ip and ssh bcuser@$IP_ADDRESS Check to make sure you are still inside your docker image. If you got out of your docker image, go back into the image by first setting your TEAM with TEAM=teamxx where xx is the number of your team. Then, check if your container is still running with docker ps | grep team a) If you get sample output showing a container such as: 6e6ad92499b1 wsc-ibp-icp-cluster.icp:8500/lab-test/connectathon-s390x-team10:1.0 \"bash\" 12 minutes ago Up 12 minutes 0.0.0.0:3000- 3001/tcp team10 follow Option a) of step 3 below b) If you get sample output not showing anything such as: follow Option b) of step 3 below Do only 1 of the options below based on step 2 above! a) exec back into your running container with docker exec -it $TEAM sh OR b) restart your container with docker run --rm -it -v /var/run/docker.sock:/var/run/docker.sock --name $TEAM -p 3000:3001 wsc-ibp-icp-cluster.icp:8500/lab-test/connectathon-s390x-$TEAM:1.0 bash","title":"Only if you stopped in between the lab parts 1 and 2"},{"location":"connect-part2/#before-you-start-make-sure-you-are-still-logged-in-to-the-cluster","text":"Run the following commands to display the pods that are currently deployed to our cluster. First, type kubectl get pods Sample Output: NAME READY STATUS RESTARTS AGE connectathon-orderer-orderer-85bb44f87c-qk662 1/1 Running 0 1d connectathon-ordererorg-ca-fabric-ca-deployment-7f6b9b6577whxgr 1/1 Running 0 1d connectathon-org0-ca-fabric-ca-deployment-67cf7486dd-9wtg7 1/1 Running 0 1d connectathon-org0peer1-55fc894b9-5qncl 2/2 Running 0 1d connectathon-org1-ca-fabric-ca-deployment-59f9457fc5-9jmfp 1/1 Running 0 1d connectathon-org10-ca-fabric-ca-deployment-76794dcbbf-jdkcr 1/1 Running 0 1d connectathon-org10peer1-86dc5fcdf7-6c5qm 2/2 Running 0 39m connectathon-org11-ca-fabric-ca-deployment-5bc55cc776-5cjbz 1/1 Running 0 1d connectathon-org11peer1-69f67d965-svwjh 2/2 Running 0 1d connectathon-org1peer1-7665b7c6d7-x8spx 2/2 Running 0 1d connectathon-org2-ca-fabric-ca-deployment-787cbdf766-qwdjw 1/1 Running 0 1d connectathon-org2peer1-7d4bbfc7bf-gs9qv 2/2 Running 0 1d connectathon-org3-ca-fabric-ca-deployment-54cfc78777-m782f 1/1 Running 0 1d If you are able to see the output of the kubectl command such as above you are still logged in. If not, run: cloudctl login -a https://192.168.22.81:8443 -u $team -p $credential -n lab-test Sample Output: Targeted account wsc-ibp-icp-cluster Account (id-wsc-ibp-icp-cluster-account) Targeted namespace lab-test Configuring kubectl ... Property clusters.wsc-ibp-icp-cluster unset. Property users.wsc-ibp-icp-cluster-user unset. Property contexts.wsc-ibp-icp-cluster-context unset. Cluster wsc-ibp-icp-cluster set. User wsc-ibp-icp-cluster-user set. Context wsc-ibp-icp-cluster-context created. Switched to context wsc-ibp-icp-cluster-context . OK Configuring helm: /root/.helm OK Now, run kubectl get pods | grep $CORE_PEER_LOCALMSPID Sample Output: NAME READY STATUS RESTARTS AGE connectathon-org0-ca-fabric-ca-deployment-67cf7486dd-9wtg7 1/1 Running 0 7h connectathon-org0peer1-55fc894b9-5qncl 2/2 Running 0 7h You should see one peer pod, and one CA pod. Both should be in Running status. Your organization only has one peer in this scenario.","title":"Before you start, make sure you are still logged in to the cluster."},{"location":"connect-part2/#build-a-docker-image","text":"Now that you have tested the Marbles front end User Interface (Marbles UI, for short), let's save it as a docker image using the supplied Dockerfile. A Dockerfile is a text document that contains all the commands a user could call on the command line to assemble an image. Think of it as a specific way to package up a set of files and instructions that together make up a microservice. Go to your marbles directory: cd /home/marbles Here you should see a Dockerfile: ls -ltr Dockerfile Sample Output: -rw-rw-r-- 1 1000 1000 394 Feb 28 22:12 Dockerfile If you are curious, cat the file to look at its contents: cat Dockerfile Sample Output: FROM node:8-alpine ENV NPM_CONFIG_LOGLEVEL warn RUN mkdir -p /usr/src/app WORKDIR /usr/src/app COPY package.json /usr/src/app/ RUN apk add --no-cache --virtual .build-deps make gcc g++ python \\ npm install \\ npm install gulp -g ---unsafe-perm \\ apk del .build-deps .build-deps make gcc g++ python COPY . /usr/src/app/ EXPOSE 3001 CMD [ gulp , marbles_tls ] The above Dockerfile builds from an Alpine node image in DockerHub. This is a bare bones Linux image of the Alpine distribution with node version 8 installed. Next, the NPM_CONFIG_LOGLEVEL for npm is globally set to warn so that npm will only print errors and warnings. ENV is used for this to persist this change as an environment variable in your finished container. Then, it uses RUN to execute a command inside of the base node:8-alpine container to make a directory for the marbles application. WORKDIR makes this directory the current working directory. Moreover, COPY brings the package.json file (containing the names of the application's dependent node modules) into the containers /usr/src/app directory. The following RUN command uses apk (Alpine's package manager) to install a variety of pre-reqs to your npm install such as make, gcc and python, before running the actual npm install twice to install both the necessary node modules for both the Marbles UI itself and gulp to start the marbles UI. Note that this is all done in one line with to make it occur in one layer. This way, at the end of the RUN command you can use a delete command apk del and take the developer tools you no longer need out of your image. If you instead ran this as multiple commands, you would not be able to shrink your image size since previous layers can't be effectively deleted due to the layered file system used for docker images. Finally, you copy the application itself and the connection profile materials into your working directory, document the port you will run marbles on ( 3001 ), and set a command for the container to run when it starts gulp marbles_tls . Now let's run docker build in the /home/marbles directory: docker build -t marbles-$team . NOTE: Please remember to not forget that pesky . Otherwise you will get an error saying \"docker build\" requires exactly 1 argument Sample Output: Sending build context to Docker daemon 261.9MB Step 1/9 : FROM node:8-alpine --- 66f08ecb7600 Step 2/9 : ENV NPM_CONFIG_LOGLEVEL warn --- Using cache --- 180c28267c41 Step 3/9 : RUN mkdir -p /usr/src/app --- Using cache --- f9615b4a1813 Step 4/9 : WORKDIR /usr/src/app --- Using cache --- e53d507c2bf9 .... .... lots more messages .... Successfully built 9b57c7c3e480 Successfully tagged marbles-team00:latest Now you should see this new image that you just built: docker images Sample Output: REPOSITORY TAG IMAGE ID CREATED SIZE marbles-team00 latest 5cc513286904 29 seconds ago 312MB wsc-ibp-icp-cluster.icp:8500/lab-test/connectathon-s390x-team00 1.0 a2d1b20e0e1e 12 hours ago 1.16GB node 8-alpine 030469210de8 2 weeks ago 69.5MB","title":"Build a docker image"},{"location":"connect-part2/#test-the-docker-image-locally","text":"Let's test the image that was just built, by running it locally: docker run -it --init -p 3001:3001/tcp --name marbles-$team marbles-$team Sample Output [20:57:50] Using gulpfile /usr/src/app/gulpfile.js [20:57:50] Starting 'env_tls'... [20:57:50] Finished 'env_tls' after 73 \u03bcs [20:57:50] Starting 'build-sass'... [20:57:50] Finished 'build-sass' after 7.48 ms [20:57:50] Starting 'watch-sass'... [20:57:50] Finished 'watch-sass' after 7.47 ms [20:57:50] Starting 'watch-server'... [20:57:50] Finished 'watch-server' after 2.55 ms [20:57:50] Starting 'server'... info: Checking connection profile is done info: Loaded config file /usr/src/app/config/marbles_tls.json info: Loaded connection profile file /usr/src/app/config/connection_profile_tls.json ... lots of output ... - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - debug: Detected that we have launched successfully before debug: Welcome back - Marbles is ready debug: Open your browser to http://localhost:3001 and login as admin - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - After you see the \"Open your browser to https://localhost:3001\" message, point your browser to the IP address of your Linux image, e.g., http://192.168.22.107:3001 and you will see the Marbles UI. Once you verify that the image works locally, it's time to stop the running container. Type Ctrl + C to exit out of the running container in the current terminal.","title":"Test the docker image locally"},{"location":"connect-part2/#push-image-to-the-icp-clusters-private-repo","text":"You will now tag the image you created with the private repo's host name and port number, followed by the namespace you are using, as follows. docker tag marbles-$team:latest wsc-ibp-icp-cluster.icp:8500/lab-test/marbles-$team:1.0 Log into the docker private registry using your teamNN id and credential, as follows: echo $credential | docker login wsc-ibp-icp-cluster.icp:8500 -u $team --password-stdin Sample Output: WARNING! Your password will be stored unencrypted in /root/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded Now push up the image using the tag you just created (again be mindful that the name pushed in the output will reflect your team name): docker push wsc-ibp-icp-cluster.icp:8500/lab-test/marbles-$team:1.0 Sample Output: The push refers to repository [wsc-ibp-icp-cluster.icp:8500/lab-test/marbles-team00] c8490573a0d8: Pushed 8e63f87572fb: Pushed a6a08bb664f7: Pushed 3a30ca7a2471: Pushed ccc0f617b78a: Pushed 1801fc515e2a: Pushed 1.0: digest: sha256:6a796e973817f714b64e767b3c35affd93a6dc5df7ef12ca872aca64d20a5155 size: 1997 Let's log in to the ICP Console for the first time and verify that your image got pushed up to the cluster's private docker registry. Point your browser to https://192.168.22.81:8443 . Accept that it's using a self-signed certificate. This should lead you to the sign in page. Log in with your team's credentials given to you at the beginning of the lab: you can find this by echoing the team and credential variables in your terminal: echo $team echo $credential . Your team is your username and your credential is your password. You can verify your image got pushed up by going to the hamburger menu on the top left corner and selecting Container Images and look for lab-test/marbles-teamNN. Note: you will have to go to the last page to see images under the namespace lab-test.","title":"Push image to the ICP Cluster's private repo"},{"location":"connect-part2/#create-a-kubernetes-deployment-and-service","text":"Log in to the ICP cluster with your team's ID and password: cloudctl login -a https://192.168.22.81:8443 -u $team -p $credential -n lab-test Sample Output: Targeted account wsc-ibp-icp-cluster Account (id-wsc-ibp-icp-cluster-account) Targeted namespace lab-test Configuring kubectl ... Property clusters.wsc-ibp-icp-cluster unset. Property users.wsc-ibp-icp-cluster-user unset. Property contexts.wsc-ibp-icp-cluster-context unset. Cluster wsc-ibp-icp-cluster set. User wsc-ibp-icp-cluster-user set. Context wsc-ibp-icp-cluster-context created. Switched to context wsc-ibp-icp-cluster-context . OK Configuring helm: /root/.helm OK Verify that your organization's Fabric pods are running. Note that you have a Fabric CA pod and one Fabric peer pod running. The environment variable $CORE_PEER_LOCALMSPID was set for you and it was set to your peer's MSPID. In this lab environment, your MSPID corresponds to your team number. i.e. team01 will be org1, team02 will be org2, etc. kubectl get pods | grep connectathon-$CORE_PEER_LOCALMSPID Sample Output: connectathon-org0-ca-fabric-ca-deployment-67cf7486dd-xgqkb 1/1 Running 0 7h connectathon-org0peer1-55fc894b9-fhz2f 2/2 Running 0 7h You should have a Kubernetes deployment yaml file in your /home/marbles directory called marbles-teamNN.yaml . Kubernetes objects are defined in yaml files and then created on or applied to a running cluster. You can create a Kubernetes resource from the ICP Console as well. But here you will do this via the command line tool kubectl which interacts with the Kubernetes API Server on the cluster. Now run the following command to create a marbles deployment yaml file that matches your team name. cat marbles-teamNN.yaml | sed -r 's/teamNN/'$team'/' marbles-$team.yaml You can cat the yaml file to see its contents: cat marbles-$team.yaml Sample Output: apiVersion: v1 kind: Service metadata: name: marbles-team00-svc spec: selector: app: marbles-team00 ports: - protocol: TCP port: 3001 targetPort: 3001 type: NodePort --- apiVersion: extensions/v1beta1 kind: Deployment metadata: name: marbles-team00-deploy labels: app: marbles-team00 spec: selector: matchLabels: app: marbles-team00 replicas: 1 template: metadata: labels: app: marbles-team00 spec: nodeSelector: beta.kubernetes.io/arch: s390x containers: - name: marbles-team00 image: wsc-ibp-icp-cluster.icp:8500/lab-test/marbles-team00:1.0 ports: - containerPort: 3001 imagePullPolicy: Always The important parts to point out in the yaml file are that it will create a Kubernetes service called marbles-team00-svc and that it is pointing to the marbles-team00 container. The service will be of type NodePort which means this service will be reachable outside of the cluster. The yaml file will also create a Kubernetes deployment that has one pod with one container that will be based off of the wsc-ibp-icp-cluster.icp:8500/lab-test/marbles-team00:1.0 image that you pushed to the private image registry earlier. Finally, since you built the marbles-teamxx image with the s390x (z) architecture and there are machines with multiple different architectures in our cluster (s390x and amd64) you need to specify for it to run on s390x with a nodeSelector of beta.kubernetes.io/arch: s390x . If you built it for a different architecture, you would instead use a nodeSelector for that architecture.","title":"Create a Kubernetes deployment and service"},{"location":"connect-part2/#deploy-the-service-and-test-the-marbles-ui","text":"Now you are ready to create the Kubernetes resources. Run the following command: kubectl apply -f marbles-$team.yaml service/marbles-team00-svc created deployment.extensions/marbles-team00-deploy created The deployment will create one pod that has one container. A service is also created. Check that your pod is READY 1/1 and in Running status: kubectl get pods | grep marbles-$team marbles-team00-deploy-55649dbc5b-xf787 1/1 Running 0 35s","title":"Deploy the service and test the Marbles UI"},{"location":"connect-part2/#launch-the-marbles-service-and-test-the-marbles-ui","text":"Now, let's navigate through the ICP Console to your deployment. Point your browser to https://192.168.22.81:8443 . Accept that it's using a self signed certificate. This should lead you to the sign in page. Log in with your team's credentials given to you at the beginning of the lab. Go to the hamburger menu on the upper left corner, and select Workloads - Deployments . Find your team's deployment, it should be similar to marbles-team00-deploy but with your team name. Click on your deployment. You will be taken to the details page of your deployment. Upon further exploration you will see the deployment has one ReplicaSet, and one Pod. You can choose to click into either the ReplicaSet or Pod to get details about those two objects. Now click on the Launch button for your deployment. This will bring up the Marbles UI. At this point, depending on where the other classroom students are, you will see two or more organizations in the Marbles UI. Test out the application by transacting some marbles with your neighboring students. Enabling Story Mode in Settings will provide a step by step guided experience during each transaction. Congratulations! You've successfully created a container for the Marbles front end application, created a Kubernetes deployment for it, and deployed it in a IBM Cloud Private Kubernetes cluster.","title":"Launch the Marbles service and test the Marbles UI"},{"location":"hlf-home/","text":"Welcome to the Hyperledger Fabric Lab The goal of this lab is to give you hands on experience interacting with Hyperledger Fabric using the Hyperledger Fabric command line interface (CLI) and make you familiar with chaincode lifecycle operations such as install , instantiate and invoke . You will also have the opportunity to configure a front-end application that provides a browser-based user interface (UI) that uses the Application Programming Interface (API) provided by the Hyperledger Fabric Node.js Software Development Kit (SDK) to interact with chaincode. This lab is broken into two parts. The first part deals with the chaincode and the second part deals with the front-end application. Please read the instructions carefully. In the shaded sections in the lab where command input and output is shown, the convention followed is that the first line of the shaded area will contain the command input after the command prompt, and any subsequent lines in the shaded area are the command output. It will probably be easiest for you to copy the command input from the lab and paste it into your terminal window. Be careful not to accidentally copy in some of the command output from line two and beyond of the shaded area when you are doing this. Note This lab runs on Linux on IBM Z systems in the IBM Washington Systems Center (WSC). In order to connect to this environment, you must use the CISCO AnyConnect client to establish a virtual private network (VPN) connection into the WSC network. You will be given connection information at the beginning of the lab. Tip If you find any typos, errors, or just want to provide helpful feedback to make this lab better, please click on the GitHub icon in the lower left corner of this page to be taken to our GitHub repository, from where you can create an Issue to suggest a correction or improvement. Thanks for your feedback! Acknowledgements Special thanks to John Harrison who was the first person to get the application used in this lab to work on Hyperledger Fabric running on IBM Z! Thanks to Jin VanStee for contributing the overview diagram at the beginning of Part 1! Author Barry Silliman","title":"Welcome to the Hyperledger Fabric Lab"},{"location":"hlf-home/#welcome-to-the-hyperledger-fabric-lab","text":"The goal of this lab is to give you hands on experience interacting with Hyperledger Fabric using the Hyperledger Fabric command line interface (CLI) and make you familiar with chaincode lifecycle operations such as install , instantiate and invoke . You will also have the opportunity to configure a front-end application that provides a browser-based user interface (UI) that uses the Application Programming Interface (API) provided by the Hyperledger Fabric Node.js Software Development Kit (SDK) to interact with chaincode. This lab is broken into two parts. The first part deals with the chaincode and the second part deals with the front-end application. Please read the instructions carefully. In the shaded sections in the lab where command input and output is shown, the convention followed is that the first line of the shaded area will contain the command input after the command prompt, and any subsequent lines in the shaded area are the command output. It will probably be easiest for you to copy the command input from the lab and paste it into your terminal window. Be careful not to accidentally copy in some of the command output from line two and beyond of the shaded area when you are doing this. Note This lab runs on Linux on IBM Z systems in the IBM Washington Systems Center (WSC). In order to connect to this environment, you must use the CISCO AnyConnect client to establish a virtual private network (VPN) connection into the WSC network. You will be given connection information at the beginning of the lab. Tip If you find any typos, errors, or just want to provide helpful feedback to make this lab better, please click on the GitHub icon in the lower left corner of this page to be taken to our GitHub repository, from where you can create an Issue to suggest a correction or improvement. Thanks for your feedback!","title":"Welcome to the Hyperledger Fabric Lab"},{"location":"hlf-home/#acknowledgements","text":"Special thanks to John Harrison who was the first person to get the application used in this lab to work on Hyperledger Fabric running on IBM Z! Thanks to Jin VanStee for contributing the overview diagram at the beginning of Part 1!","title":"Acknowledgements"},{"location":"hlf-home/#author","text":"Barry Silliman","title":"Author"},{"location":"hlf-part1/","text":"Section 1 - Overview of Hyperledger Fabric Smart Contract installation lab part 1 In this lab, you will work with the Marbles demo application, which is considered by many to be a de facto \"hello world\" application for getting started with Hyperledger Fabric. Hyperledger Fabric is one of several projects within the open-source Hyperledger collaborative effort hosted by the Linux Foundation. Hyperledger Fabric provides the distributed ledger, a.k.a. blockchain, technology that is the core of IBM Blockchain solutions and services. Below is a diagram that depicts the blockchain network you will build and operate: You will use Docker Compose to bring up a Hyperledger Fabric network in which two organizations will participate. There will be one orderer service for the entire network, and each organization will use its own certificate authority service and have two peer nodes. Each peer node will use CouchDB for its ledger store. Each peer node's CouchDB will run in a separate Docker container. That makes eleven Docker containers, as follows: 1 orderer service Docker container 2 certificate authority (CA) Docker containers (one for each organization) 4 peer node Docker containers (each of the two organizations has two peers) 4 CouchDB Docker containers (each peer node has its own separate CouchDB ledger store) You will also bring up a twelfth Docker container that we will call the cli container. You will use it as a convenience to enter Hyperledger Fabric commands targeted to specific peers. You will see how this is done later in the lab. The network you bring up will use Transport Layer Security (TLS) which provides secure, encrypted communications between the peer nodes and the orderer, just as most production implementations will require. You will install the Marbles chaincode on the peer nodes, instantiate the chaincode, and invoke functions of the chaincode. I will explain later in the lab the difference between the install and instantiate actions and what each one does. Section 2 - Description of the subsequent sections in Part 1 This section provides a brief description of the subsequent sections in Part 1 of the lab, where you will get hands-on experience with the Hyperledger Fabric command line interface (CLI). In most production implementations you would perform many of these functions through other means, such as programmatically through an Application Programming Interface (API) provided by a Hyperledger Fabric Software Development Kit (SDK), which the project provides for the Node.js, Java, Golang and Python programming languages, or perhaps through a user interface such as the one provided by the IBM Blockchain Platform. But using the CLI, as you will in this lab, is a great way to learn about how Hyperledger Fabric works. You will extract the artifacts necessary to run the lab in Section 3. All the artifacts necessary for the lab are provided in a compressed tarball- in essence, a zip file. You will use Docker Compose in Section 4 to bring up the twelve Docker containers that comprise the Hyperledger Fabric network. You will see that all twelve Docker containers that I mentioned in Section 1 are brought up with a single docker-compose command, and I will explain some of the more interesting bits of what is going on under the covers. You will create a channel in the Hyperledger Fabric network in Section 5. In Hyperledger Fabric, each channel is essentially its own blockchain. You will instruct each peer node to join the channel in Section 6. We will join all four Peer nodes to the channel. Peer nodes can be members of more than one channel, but for this lab you are only creating one channel. You will define an \"anchor\" peer for each organization in the channel in Section 7. An anchor peer for an organization is a peer that is known by all the other organizations in a channel. Not all peers for an organization need to be known by outside organizations. Peers not defined as anchor peers are visible only within their own organization. You will install the chaincode on the peer nodes in Section 8. Installing chaincode simply puts the chaincode executable on the file system of the peer. It is a necessary step before you execute that chaincode on the peer, but the next step is also required. You will instantiate the chaincode on the channel in Section 9. This step is a prerequisite to being able to run chaincode on a channel. It only needs to be performed on one peer that is a member of the channel. This causes a transaction to be recorded on the channel's blockchain to indicate that the chaincode can be run on the channel. You will invoke functions on the chaincode that will create, read, update and delete (CRUD) data stored on the blockchain in Section 10. Blocks of transactions in a blockchain are always added (i.e., created), and they can be read, but they are never, in normal operations, updated or deleted. However, although the blocks in a chain are not updated or deleted, the transactions themselves operate on Key/Value pairs that can have all CRUD operations performed on them. This collection of Key/Value pairs is often referred to as state data. Section 3 - Extract the artifacts necessary to run the lab Log in to your assigned Linux on Z Ubuntu instance with the instructions provided to you by your class instructor. If you are using Linux or MacOS you will likely be using ssh to log in via a Terminal window. If you are using Windows, you will most likely be using a PuTTY terminal session. If you are trying this lab at home, I am assuming you can figure out how to log in. All of the following instructions in the lab assume that you have successfully logged in to the Linux on Z Ubuntu instance assigned to your team. As you proceed through the lab, you will have to be logged in to more than one terminal session. When that becomes necessary, simply follow the same procedure used to log in to your first terminal session. Let's get started! Step 3.1: Navigate to the home directory by entering cd ~ (the \"tilde\" character, i.e., ' ~ ', represents the user's home directory in Linux). This directory is also usually set in the $HOME environment variable, so cd $HOME will also usually get you to your home directory: bcuser@ubuntu18042:~$ cd ~ bcuser@ubuntu18042:~$ Note: You may already be in your home directory prior to entering cd ~ , in which case you'll just stay there- not a problem. Step 3.2: Retrieve the zmarbles compressed tarball prepared for this lab with the following command: bcuser@ubuntu18042:~$ wget https://raw.githubusercontent.com/ibm-blockchain-wsc/ImmersionWorkshop/master/zmarbles.tar.gz --2019-04-28 14:57:58-- https://raw.githubusercontent.com/ibm-blockchain-wsc/ImmersionWorkshop/master/zmarbles.tar.gz Resolving raw.githubusercontent.com (raw.githubusercontent.com)... 151.101.200.133 Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|151.101.200.133|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 10272273 (9.8M) [application/octet-stream] Saving to: 'zmarbles.tar.gz' zmarbles.tar.gz 100%[=================================================== ] 9.80M --.-KB/s in 0.1s 2019-04-28 14:57:58 (77.3 MB/s) - 'zmarbles.tar.gz' saved [10272273/10272273] bcuser@ubuntu18042:~$ Step 3.3: The zmarbles directory should not yet exist. Prove it with this ls command: bcuser@ubuntu18042:~$ ls zmarbles ls: cannot access 'zmarbles': No such file or directory bcuser@ubuntu18042:~$ Step 3.4: Extract the zmarbles.tar.gz file which will create the missing directory (and lots of subdirectories). If you want to see the name of all of the files and directories that are extracted, add the \" v \" switch into the options in the command below. That is, use -xzvf instead of -xzf . So, enter the tar command below as shown, feeling free to substitute -xzvf for -xzf in the command (the \" v \" is for \" verbose \") : bcuser@ubuntu18042:~$ tar -xzf zmarbles.tar.gz bcuser@ubuntu18042:~$ Step 3.5: List the zmarbles directory with this command: bcuser@ubuntu18042:~$ ls -l zmarbles total 64 drwxr-xr-x 2 bcuser bcuser 4096 Apr 16 11:54 base drwxrwxr-x 2 bcuser bcuser 4096 Jan 14 07:54 bin drwxr-xr-x 2 bcuser bcuser 4096 Apr 16 12:24 channel-artifacts drwxrwxr-x 2 bcuser bcuser 4096 Jul 3 2018 config -rw-r--r-- 1 bcuser bcuser 12209 Jul 30 2018 configtx.yaml -rw-r--r-- 1 bcuser bcuser 4175 Jul 30 2018 crypto-config.yaml -rw-r--r-- 1 bcuser bcuser 6304 Apr 16 11:54 docker-compose-template.yaml drwxr-xr-x 3 bcuser bcuser 4096 Jun 18 2017 examples -rwxr-xr-x 1 bcuser bcuser 3587 Sep 24 2018 generateArtifacts.sh drwxr-xr-x 2 bcuser bcuser 4096 Oct 1 2017 hostScripts drwxrwxr-x 9 bcuser bcuser 4096 Apr 16 12:24 marblesUI drwxr-xr-x 2 bcuser bcuser 4096 Jan 19 14:58 scripts bcuser@ubuntu18042:~$ An explanation of the purpose of each of these files and directories is given here: The base directory contains Docker Compose files that are included in the docker-compose-template.yaml file with the extends directive. The bin directory contains two executable programs, cryptogen and configtxgen , that will be run later when you execute the generateArtifacts.sh script. The channel-artifacts directory is empty, but it must exist when the generateArtifacts.sh script, which you will run later, invokes the configtxgen utility. The configtxgen utility generates input to channel configuration transactions, and it is expecting the channel-artifacts directory to exist. The configtx.yaml file is input to the configtxgen utility The cryto-config.yaml file is input to the cryptogen utiity, which is called by the generateArtifacts.sh script to create cryptographic material (in the form of X.509 certificates and public and private key pairs) used to identify peers, orderers, and administrative and regular users of a Hyperledger Fabric network. The docker-compose-template.yaml file is used as a template file that the generateArtifacts.sh script will use to create the main Docker Compose template file, docker-compose.yaml , which contains definitions for all of the Docker containers that you will need. The examples directory contains the actual Marbles chaincode within its subdirectory structure. The generateArtifacts.sh script is used to generate channel configuration transaction input and to generate cryptographic material and it also creates docker-compose.yaml , using docker-compose-template.yaml as input. The hostScripts directory is not used in this lab. The marblesUI directory is used in Part 2 of this lab, in which you will be working with the browser-based user interface (UI) for Marbles. The scripts directory contains a script named setpeer that you will be using throughout this lab from within the cli Docker container. setpeer will be explained in Section 5 . \u2003 Section 4 - Bring up the twelve Docker containers that comprise the Hyperledger Fabric network Step 4.1: Change to the zmarbles directory with the cd command: bcuser@ubuntu18042:~$ cd zmarbles/ bcuser@ubuntu18042:~/zmarbles$ Step 4.2: You are going to run a script named generateArtifacts.sh that will create some configuration information that is necessary to get your Hyperledger Fabric network set up. There is one optional parameter you may pass to the script, and that is the name of the channel you will be creating. If you do not specify this parameter, the channel name defaults to mychannel . You may choose to specify your own channel name. E.g., if you wished to name your channel tim , then you would enter ./generateArtifacts.sh tim instead of just ./generateArtifacts.sh when directed below to enter the command. Warning If you pick your own channel name, it must start with a lowercase character, and only contain lowercase characters, numbers, or the dash ('-') character, or the period ('.'). So, enter the command below, optionally specifying a custom channel name (not shown here) as the lone argument to the generateArtifacts.sh script: bcuser@ubuntu18042:~/zmarbles$ source ./generateArtifacts.sh # specify a custom channel name or accept the default value of 'mychannel' Using cryptogen - /home/bcuser/zmarbles/bin/cryptogen ########################################################## ##### Generate certificates using cryptogen tool ######### ########################################################## unitedmarbles.com marblesinc.com Using configtxgen - /home/bcuser/zmarbles/bin/configtxgen ########################################################## ######### Generating Orderer Genesis block ############## ########################################################## 2019-04-28 15:01:07.988 EDT [common.tools.configtxgen] main - WARN 001 Omitting the channel ID for configtxgen for output operations is deprecated. Explicitly passing the channel ID will be required in the future, defaulting to 'testchainid'. 2019-04-28 15:01:07.988 EDT [common.tools.configtxgen] main - INFO 002 Loading configuration 2019-04-28 15:01:08.000 EDT [common.tools.configtxgen.localconfig] completeInitialization - INFO 003 orderer type: solo 2019-04-28 15:01:08.000 EDT [common.tools.configtxgen.localconfig] Load - INFO 004 Loaded configuration: /home/bcuser/zmarbles/configtx.yaml 2019-04-28 15:01:08.012 EDT [common.tools.configtxgen.localconfig] completeInitialization - INFO 005 orderer type: solo 2019-04-28 15:01:08.012 EDT [common.tools.configtxgen.localconfig] LoadTopLevel - INFO 006 Loaded configuration: /home/bcuser/zmarbles/configtx.yaml 2019-04-28 15:01:08.013 EDT [common.tools.configtxgen] doOutputBlock - INFO 007 Generating genesis block 2019-04-28 15:01:08.014 EDT [common.tools.configtxgen] doOutputBlock - INFO 008 Writing genesis block ################################################################# ### Generating channel configuration transaction 'channel.tx' ### ################################################################# 2019-04-28 15:01:08.077 EDT [common.tools.configtxgen] main - INFO 001 Loading configuration 2019-04-28 15:01:08.088 EDT [common.tools.configtxgen.localconfig] Load - INFO 002 Loaded configuration: /home/bcuser/zmarbles/configtx.yaml 2019-04-28 15:01:08.102 EDT [common.tools.configtxgen.localconfig] completeInitialization - INFO 003 orderer type: solo 2019-04-28 15:01:08.102 EDT [common.tools.configtxgen.localconfig] LoadTopLevel - INFO 004 Loaded configuration: /home/bcuser/zmarbles/configtx.yaml 2019-04-28 15:01:08.102 EDT [common.tools.configtxgen] doOutputChannelCreateTx - INFO 005 Generating new channel configtx 2019-04-28 15:01:08.102 EDT [common.tools.configtxgen.encoder] NewChannelGroup - WARN 006 Default policy emission is deprecated, please include policy specifications for the channel group in configtx.yaml 2019-04-28 15:01:08.103 EDT [common.tools.configtxgen.encoder] NewChannelGroup - WARN 007 Default policy emission is deprecated, please include policy specifications for the channel group in configtx.yaml 2019-04-28 15:01:08.104 EDT [common.tools.configtxgen] doOutputChannelCreateTx - INFO 008 Writing new channel tx ################################################################# ####### Generating anchor peer update for Org0MSP ########## ################################################################# 2019-04-28 15:01:08.170 EDT [common.tools.configtxgen] main - INFO 001 Loading configuration 2019-04-28 15:01:08.181 EDT [common.tools.configtxgen.localconfig] Load - INFO 002 Loaded configuration: /home/bcuser/zmarbles/configtx.yaml 2019-04-28 15:01:08.193 EDT [common.tools.configtxgen.localconfig] completeInitialization - INFO 003 orderer type: solo 2019-04-28 15:01:08.193 EDT [common.tools.configtxgen.localconfig] LoadTopLevel - INFO 004 Loaded configuration: /home/bcuser/zmarbles/configtx.yaml 2019-04-28 15:01:08.193 EDT [common.tools.configtxgen] doOutputAnchorPeersUpdate - INFO 005 Generating anchor peer update 2019-04-28 15:01:08.193 EDT [common.tools.configtxgen] doOutputAnchorPeersUpdate - INFO 006 Writing anchor peer update ################################################################# ####### Generating anchor peer update for Org1MSP ########## ################################################################# 2019-04-28 15:01:08.255 EDT [common.tools.configtxgen] main - INFO 001 Loading configuration 2019-04-28 15:01:08.266 EDT [common.tools.configtxgen.localconfig] Load - INFO 002 Loaded configuration: /home/bcuser/zmarbles/configtx.yaml 2019-04-28 15:01:08.277 EDT [common.tools.configtxgen.localconfig] completeInitialization - INFO 003 orderer type: solo 2019-04-28 15:01:08.278 EDT [common.tools.configtxgen.localconfig] LoadTopLevel - INFO 004 Loaded configuration: /home/bcuser/zmarbles/configtx.yaml 2019-04-28 15:01:08.278 EDT [common.tools.configtxgen] doOutputAnchorPeersUpdate - INFO 005 Generating anchor peer update 2019-04-28 15:01:08.278 EDT [common.tools.configtxgen] doOutputAnchorPeersUpdate - INFO 006 Writing anchor peer update bcuser@ubuntu18042:~/zmarbles$ This script calls two Hyperledger Fabric utilites- cryptogen , which creates security material (certificates and keys) and configtxgen (Configuration Transaction Generator), which is called four times, to create four things: An orderer genesis block -- this will be the first block on the orderer's system channel. The location of this block is specified to the Orderer when it is started up via the ORDERER_GENERAL_GENESISFILE environment variable. A channel transaction -- later in the lab, this is sent to the orderer and will cause a new channel to be created when you run the peer channel create command. An anchor peer update for Org0MSP. An anchor peer is a peer that is set up so that peers from other organizations may communicate with it. The concept of anchor peers allows an organization to create multiple peers, perhaps to provide extra capacity or throughput or resilience (or all the above) but not have to advertise this to outside organizations. An anchor peer update for Org1MSP. You will perform the anchor peer updates for both Org0MSP and Org1MSP later in the lab via peer channel create commands. Step 4.3: Issue the following command which will show you all files that were created by the configtxgen utility when it was called from inside generateArtifacts.sh : bcuser@ubuntu18042:~/zmarbles$ ls -ltr channel-artifacts total 28 -rw-r--r-- 1 bcuser bcuser 12995 Apr 28 15:01 genesis.block -rw-r--r-- 1 bcuser bcuser 346 Apr 28 15:01 channel.tx -rw-r--r-- 1 bcuser bcuser 285 Apr 28 15:01 Org0MSPanchors.tx -rw-r--r-- 1 bcuser bcuser 282 Apr 28 15:01 Org1MSPanchors.tx bcuser@ubuntu18042:~/zmarbles$ genesis.block will be passed to the orderer at startup, and will be used to configure the orderer's system channel . This file contains the x.509 signing certificates for every organization defined within the consortia that were specified within the configtx.yaml file when configtxgen was run. The system channel contains other values such as parameters defining when a block of transactions is cut- e.g., based on time, number of transactions, or block size- and these values serve as a template, that is, as defaults, for any additional channels that might be created, if a new channel creation request does not provide its own custom values. channel.tx is the input for a configuration transaction that will create a channel. You will use this as input to a peer channel create request in Section 5 . Org0MSPanchors.tx and Org1MSPanchors.tx are inputs for configuration transactions that will define an anchor peer for Org0 and Org1 respectively. You will use these inputs in Section 7 . Step 4.4: Issue the following command which will show you all files that were created by the cryptogen utility when it was called from inside generateArtifacts.sh . This command will show one screen at a time and pause- press the space bar to scroll to the end, that is, until you get your command prompt back: bcuser@ubuntu18042:~/zmarbles$ ls -ltrR crypto-config | more . . (output not shown here) . Actually, these files were created before the files listed in the prior step, Step 4.3 , were created, because, among the many cryptographic artifacts created are the x.509 signing certificates for the organizations, which are baked into the genesis.block discussed in the prior step. You can see that there is a dizzying set of directories and files, containing things like CA root certificates, signing certificates, TLS certificates, corresponding private keys, and public keys, for certificate authorities, organizations, administrative and general users. A thorough discussion of them is beyond the scope of this lab. Note This utiltity created crypto material for both organizations, including private keys that each organization would keep secret and never share with the other organizations. You have created this for both organizations on a single server for purposes of this lab, but in a production implementation each organization would create their own material separately so that they could indeed keep their private keys to themselves. Their public certificates, which are meant to be shared, are baked into the channel definitions for channels in which they participate. This allows peer nodes from all organizations in a channel to verify digital signatures of transaction requests and transaction endorsements from other organizations that are members of the channel. Step 4.5: You are going to look inside the Docker Compose configuration file a little bit. Enter the following command: bcuser@ubuntu18042:~/zmarbles$ vi -R docker-compose.yaml You can enter Ctrl-f to scroll forward in the file and Ctrl-b to scroll back in the file. The -R flag opens the file in read-only mode, so if you accidentally change something in the file, it's okay. It will not be saved. The statements within docker-compose.yaml are in a markup language called YAML , which stands for Y et A nother M arkup L anguage. (Who says nerds do not have a sense of humor). We will go over some highlights here. There are twelve \"services\", or Docker containers, defined within this file. They all start in column 3 and have several statements to describe them. For example, the first service defined is ca0 , and there are image , environment , ports , command , volumes , and container_name statements that describe it. If you scroll down in the file with Ctrl-f you will see all the services. Not every service has the same statements describing it. The twelve services are: ca0 -- The certificate authority service for \"Organization 0\" (unitedmarbles.com) ca1 -- The certificate authority service for \"Organization 1\" (marblesinc.com) orderer.blockchain.com -- The single ordering service that both organizations will use peer0.unitedmarbles.com -- The first peer node for \"Organization 0\" peer1.unitedmarbles.com -- The second peer node for \"Organization 0\" peer0.marblesinc.com -- The first peer node for \"Organization 1\" peer1.marblesinc.com -- The second peer node for \"Organization 1\" couchdb0 -- The CouchDB server for peer0.unitedmarbles.com couchdb1 -- The CouchDB server for peer1.unitedmarbles.com couchdb2 -- The CouchDB server for peer0.marblesinc.com couchdb3 -- The CouchDB server for peer1.marblesinc.com cli -- The Docker container from which you will enter Hyperledger Fabric command line interface (CLI) commands targeted towards a peer node. I will describe how several statements work within the file, but time does not permit me to address every single line in the file! image statements define which Docker image file the Docker container will be created from. Basically, the Docker image file is a static file that, once created, is read-only. A Docker container is based on a Docker image, and any changes to the file system within a Docker container are stored within the container. So, multiple Docker containers can be based on the same Docker image, and each Docker container keeps track of its own changes. For example, the containers built for the ca0 and ca1 service will both be based on the hyperledger/fabric-ca:1.4.1 Docker image because they both have this statement in their definition: image: hyperledger/fabric-ca:1.4.1 environment statements define environment variables that are available to the Docker container. The Hyperledger Fabric processes make ample use of environment variables. In general, you will see that the certificate authority environment variables start with FABRIC_CA , the orderer's environment variables start with ORDERER_GENERAL , and the peer node's environment variables start with CORE . These variables control behavior of the Hyperledger Fabric code, and, in many cases, will override values that are specified in configuration files. All the peers and the orderer have an environment variable to specify that TLS is enabled- CORE_PEER_TLS_ENABLED=true for the peers and ORDERER_GENERAL_TLS_ENABLED=true for the orderer. You will notice there are other TLS-related variables to specify private keys, certificates and root certificates. Note Most of the TLS-related environment variables for the peer and orderer are specified in separate files that are brought in via the extends statement. Specifically, base/docker-compose.yaml for the orderer and base/peer-base.yaml for the peers. We'll discuss the extends statement shortly. ports statements map ports on our Linux on IBM Z host to ports within the Docker container. The syntax is host port : Docker container port . For example, the service for ca1 has this port statement: ports: - \"8054:7054\" This says that port 7054 in the Docker container for the ca1 node will be mapped to port 8054 on your Linux on IBM Z host. This is how you can run two CA nodes in two Docker containers and four peer nodes in four Docker containers and keep things straight- within each CA node they are both using port 7054, and within each peer node Docker container, they are all using port 7051 for the same thing, but if you want to get to one of the peers from your host or even the outside world, you would target the appropriate host-mapped port. Note: To see the port mappings for the peers you have to look in base/docker-compose.yaml . See if you can figure out why. container_name statements are used to create hostnames that the Docker containers spun up by the docker-compose command use to communicate with each other. A separate, private network will be created by Docker where the 12 Docker containers can communicate with each other via the names specified by container_name . So, they do not need to worry about the port mappings from the ports statements- those are used for trying to get to the Docker containers from outside the private network created by Docker. volumes statements are used to map file systems on the host to file systems within the Docker container. Just like with ports, the file system on the host system is on the left and the file system name mapped within the Docker container is on the right. For example, look at this statement from the ca0 service: volumes: - ./crypto-config/peerOrganizations/unitedmarbles.com/ca/:/etc/hyperledger/fabric-ca-server-config The security-related files that were created from the previous step where you ran generateArtifacts.sh were all within the crypto-config directory on your Linux on IBM Z host. The prior volumes statement is how this stuff is made accessible to the ca0 service that will run within the Docker container. Similar magic is done for the other services as well, except for the CouchDB services. extends statements are used by the peer nodes. What this does is merge in other statements from another file. For example, you may notice that the peer nodes do not contain an images statement. How does Docker know what Docker image file to base the container on? That is defined in the file, base/peer-base.yaml , specified in the extends section of base/docker-compose.yaml , which is specified in the extends section of docker-compose.yaml for the peer nodes. command statements define what command is run when the Docker container is started. This is how the actual Hyperledger Fabric processes get started. You can define default commands when you create the Docker image. This is why you do not see command statements for the cli service or for the CouchDB services. For the peer nodes, the command statement is specified in the base/peer-base.yaml file. working_dir statements define what directory the Docker container will be in when its startup commands are run. Again, defaults for this can be defined when the Docker image is created. When you are done reviewing the docker-compose.yaml file, exit the vi session by typing :q! (that's \"colon\", \"q\", \"exclamation point\") which will exit the file and discard any changes you may have accidentally made while browsing through the file. If :q! doesn't work right away, you may have to hit the escape key first before trying it. If that still doesn't work, ask an instructor for help- vi can be tricky if you are not used to it. If you would like to see what is in the base/docker-compose-base.yaml and base/peer-base.yaml files I mentioned, take a quick peek with vi -R base/docker-compose-base.yaml and vi -R base/peer-base.yaml and exit with the :q! key sequence when you have had enough. Step 4.6: Start the Hyperledger Fabric network by entering the command shown below: bcuser@ubuntu18042:~/zmarbles$ docker-compose up --detach Creating network \"zmarbles_default\" with the default driver Pulling orderer.blockchain.com (hyperledger/fabric-orderer:1.4.1)... 1.4.1: Pulling from hyperledger/fabric-orderer 39653445334d: Pull complete 329bdf3df601: Pull complete e1af42922173: Pull complete 4b9e5154055d: Pull complete 8ed6225295fd: Pull complete 11c7fddfdc0f: Pull complete Pulling ca1 (hyperledger/fabric-ca:1.4.1)... 1.4.1: Pulling from hyperledger/fabric-ca 39653445334d: Already exists 329bdf3df601: Already exists e1af42922173: Already exists a5b6cc1abc77: Pull complete 1d0fabac8892: Pull complete 6eae46c3b75a: Pull complete ce86d957bb82: Pull complete a089155eb52f: Pull complete Pulling ca0 (hyperledger/fabric-ca:1.4.1)... 1.4.1: Pulling from hyperledger/fabric-ca Pulling couchdb0 (hyperledger/fabric-couchdb:s390x-0.4.15)... s390x-0.4.15: Pulling from hyperledger/fabric-couchdb 39653445334d: Already exists 329bdf3df601: Already exists e1af42922173: Already exists 38375a01635c: Pull complete e0c199f48fe8: Pull complete 32ba5a82959e: Pull complete 7e91f8f93642: Pull complete 17039674b6c5: Pull complete 2ff3f86b6c77: Pull complete ce5364742c8c: Pull complete 8202e4590853: Pull complete 2f293014c84a: Pull complete 9779e3b3aa0f: Pull complete c78880840b57: Pull complete 66b99fceb3c4: Pull complete abe937827dde: Pull complete ad4c12835ee0: Pull complete Pulling peer0.unitedmarbles.com (hyperledger/fabric-peer:1.4.1)... 1.4.1: Pulling from hyperledger/fabric-peer 39653445334d: Already exists 329bdf3df601: Already exists e1af42922173: Already exists 4b9e5154055d: Already exists 22c8eabb9c48: Pull complete b536383fde82: Pull complete Pulling cli (hyperledger/fabric-tools:1.4.1)... 1.4.1: Pulling from hyperledger/fabric-tools 39653445334d: Already exists 329bdf3df601: Already exists e1af42922173: Already exists 38375a01635c: Already exists e0c199f48fe8: Already exists 32ba5a82959e: Already exists 7e91f8f93642: Already exists 5bcfc5abd027: Pull complete 3ff8871c88b1: Pull complete 9a7a331d670e: Pull complete Creating couchdb0 ... done Creating orderer.blockchain.com ... done Creating couchdb3 ... done Creating ca_Org1 ... done Creating couchdb2 ... done Creating ca_Org0 ... done Creating couchdb1 ... done Creating peer0.unitedmarbles.com ... done Creating peer1.marblesinc.com ... done Creating peer1.unitedmarbles.com ... done Creating peer0.marblesinc.com ... done Creating cli ... done bcuser@ubuntu18042:~/zmarbles$ Note: Depending upon the circumstances under which you run this lab, the Hyperledger Fabric Docker images required may already exist on your system, in which case you may not observe the messages shown above that show the progress of the downloads. Step 4.7: Verify that all twelve services are Up and none of them say Exited . The Exited status means something went wrong, and you should check with an instructor for help if you see any of them in Exited status. If, however, all twelve of your Docker containers are in Up status, as in the output below, you are ready to proceed to the next section: bcuser@ubuntu18042:~/zmarbles$ docker ps --all CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 84b6c0ee74aa hyperledger/fabric-tools:1.4.1 \"bash\" 2 minutes ago Up 2 minutes cli e6eabd9fd96d hyperledger/fabric-peer:1.4.1 \"peer node start\" 2 minutes ago Up 2 minutes 0.0.0.0:9051- 7051/tcp, 0.0.0.0:9052- 7052/tcp, 0.0.0.0:9053- 7053/tcp peer0.marblesinc.com 8174f3021744 hyperledger/fabric-peer:1.4.1 \"peer node start\" 2 minutes ago Up 2 minutes 0.0.0.0:8051- 7051/tcp, 0.0.0.0:8052- 7052/tcp, 0.0.0.0:8053- 7053/tcp peer1.unitedmarbles.com 1a22b9eb5be5 hyperledger/fabric-peer:1.4.1 \"peer node start\" 2 minutes ago Up 2 minutes 0.0.0.0:10051- 7051/tcp, 0.0.0.0:10052- 7052/tcp, 0.0.0.0:10053- 7053/tcp peer1.marblesinc.com 11423ca89763 hyperledger/fabric-peer:1.4.1 \"peer node start\" 2 minutes ago Up 2 minutes 0.0.0.0:7051-7053- 7051-7053/tcp peer0.unitedmarbles.com 18b9e5efbfc9 hyperledger/fabric-couchdb:s390x-0.4.15 \"tini -- /docker-ent\u2026\" 2 minutes ago Up 2 minutes 4369/tcp, 9100/tcp, 0.0.0.0:6984- 5984/tcp couchdb1 77288f8c0060 hyperledger/fabric-couchdb:s390x-0.4.15 \"tini -- /docker-ent\u2026\" 2 minutes ago Up 2 minutes 4369/tcp, 9100/tcp, 0.0.0.0:7984- 5984/tcp couchdb2 43214da184da hyperledger/fabric-ca:1.4.1 \"sh -c 'fabric-ca-se\u2026\" 2 minutes ago Up 2 minutes 0.0.0.0:7054- 7054/tcp ca_Org0 1ea639c77a3a hyperledger/fabric-ca:1.4.1 \"sh -c 'fabric-ca-se\u2026\" 2 minutes ago Up 2 minutes 0.0.0.0:8054- 7054/tcp ca_Org1 07df27e35368 hyperledger/fabric-couchdb:s390x-0.4.15 \"tini -- /docker-ent\u2026\" 2 minutes ago Up 2 minutes 4369/tcp, 9100/tcp, 0.0.0.0:8984- 5984/tcp couchdb3 93e0465394b6 hyperledger/fabric-orderer:1.4.1 \"orderer\" 2 minutes ago Up 2 minutes 0.0.0.0:7050- 7050/tcp orderer.blockchain.com 4201915cc3b2 hyperledger/fabric-couchdb:s390x-0.4.15 \"tini -- /docker-ent\u2026\" 2 minutes ago Up 2 minutes 4369/tcp, 9100/tcp, 0.0.0.0:5984- 5984/tcp couchdb0 bcuser@ubuntu18042:~/zmarbles$ Step 4.8: Try this variant of the docker ps command that uses the --format * option to show only a subset of the information shown in the previous caommand: bcuser@ubuntu18042:~/zmarbles$ docker ps --all --format '{{.Names}}\\t\\t {{.Status}}' cli Up About a minute peer1.unitedmarbles.com Up About a minute peer0.marblesinc.com Up About a minute peer0.unitedmarbles.com Up 2 minutes peer1.marblesinc.com Up About a minute couchdb1 Up About a minute couchdb2 Up About a minute ca_Org1 Up 2 minutes ca_Org0 Up 2 minutes orderer.blockchain.com Up 2 minutes couchdb3 Up 2 minutes couchdb0 Up 2 minutes Section 5 - Create a channel in the Hyperledger Fabric network In a Hyperledger Fabric v1.4.1 network, multiple channels can be created. Each channel can have its own policies for things such as requirements for endorsement and what organizations may join the channel. This allows for a subset of network participants to participate in their own channel. Imagine a scenario where OrgA, OrgB and OrgC are three organizations participating in the network. You could set up a channel in which all three organizations participate. You could also set up a channel where only OrgA and OrgB participate. In this case, the peers in OrgC would not see the transactions occurring in that channel. OrgA could participate in another channel with only OrgC, in which case OrgB does not have visibility. And so on. You could create channels with the same participants, but have different policies. For example, perhaps one channel with OrgA, OrgB, and OrgC could require all three organizations to endorse a transaction proposal, but another channel with OrgA, OrgB and OrgC could require just two, or even just one, of the three organizations to endorse a transaction proposal. Note A use case where only one organization would need to endorse a transaction proposal would be unusual, as the whole point of blockchain is for multiple organizations to agree on what is valid transaction, and allowing just one organization to consider a transaction valid sort of goes against the grain of that type of thinking, but I never say never (oops! I just said it twice) but it is technically possible. Most trust models would probably call for a majority, a super-majority (e.g. two-thirds), or even unanimous consent (100%) of the organizations in the channel to endorse a transaction proposal. Note A policy of requiring unanimous consent implies that each member organization should build an available and resilient infrastructure since if even one organization's peers are unavailable, then additions to the blockchain for that channel would grind to a halt. Then again, who runs in production without an available and resilient infrastructure anyway? The decision on how many channels to create and what policies they have will usually be driven by the requirements of the particular business problem being solved. Step 5.1: Access the cli Docker container: bcuser@ubuntu18042:~/zmarbles$ docker exec --interactive --tty cli bash root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Observe that your command prompt changes when you enter the Docker container's shell. The docker exec command runs a command against an existing Docker container. The --interactive and --tty arguments basically work together to say, \"we want an interactive terminal session with this Docker container\". cli is the name of the Docker container (this came from the container_name statement in the docker-compose.yaml file for the cli service). bash is the name of the command you want to enter. In other words, you are entering a Bash shell within the cli Docker container. For most of the rest of the lab, you will be entering commands within this Bash shell. Instead of working as user bcuser on the ubuntu18042 server in the ~/zmarbles directory, you are now inside the Docker container with ID aaaaf5aa2798 (your ID will differ), working in the /opt/gopath/src/github.com/hyperledger/fabric/peer directory. It is no coincidence that that directory is the value of the working_dir statement for the cli service in your docker-compose.yaml file. Step 5.2: There is no command to enter in this step, but read this explanation of convenience script that you will use repeatedly to point to a particular peer from the cli Docker container. Within the cli container, a convenience script named setpeer is provided in the scripts subdirectory of your current working directory. This script will set the environment variables to the values necessary to point to a particular peer. The script takes two arguments. The first argument is either 0 or 1 for Organization 0 or Organization 1 respectively, and the second argument is for either Peer 0 or Peer 1 of the organization selected by the first argument. Therefore, throughout the remainder of this lab, before sending commands to a peer, you will enter one of the following four valid combinations from within the cli Docker container, depending on which peer you want to run the command on: source scripts/setpeer 0 0 # to target Org 0, peer 0 (peer0.unitedmarbles.com) source scripts/setpeer 0 1 # to target Org 0, peer 1 (peer1.united marbles.com) source scripts/setpeer 1 0 # to target Org 1, peer 0 (peer0.marblesinc.com) source scripts/setpeer 1 1 # to target Org 1, peer 1 (peer1.marblesinc.com) Step 5.3: Choose your favorite peer and use one of the four source scripts/setpeer commands listed in the prior step. Although you are going to join all four peers to our channel, you only need to issue the channel creation command once. You can issue it from any of the four peers, so pick your favorite peer and issue the source command. In this screen snippet, I have chosen Org 1, peer 1. Issue the command below, leaving the arguments '1 1' as is, or change it to one of the other valid combinations as described in the previous step: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# source scripts/setpeer 1 1 CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.key CORE_PEER_LOCALMSPID=Org1MSP CORE_PEER_TLS_ENABLED=true CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.crt CORE_PEER_ID=cli CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/marblesinc.com/users/Admin@marblesinc.com/msp CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/marblesinc.com/peers/peer1.marblesinc.com/tls/ca.crt CORE_PEER_ADDRESS=peer1.marblesinc.com:7051 CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# The next to last environment variable listed, CORE_PEER_ADDRESS , determines to which peer your commands will be routed. Step 5.4: The Hyperledger Fabric network is configured to require TLS, so when you enter your peer commands, you need to add a flag that indicates TLS is enabled, and you need to add an argument that points to the root signer certificate of the certificate authority for the orderer service. Fortunately, an environment variable has been set for you within the CLI container that sets the flag ( --tls argument) and points to the appropriate certificate (the --cafile argument) so that you can simply pass both arguments by specifying the single short environment variable name instead of having to enter the two arguments and the tediously long argument value for --cafile . Enter this command now to see the value of this environment variable, and thank me later for setting this up for you: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# echo $FABRIC_TLS --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/blockchain.com/orderers/orderer.blockchain.com/msp/tlscacerts/tlsca.blockchain.com-cert.pem root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 5.5: Now enter this command: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer channel create -o orderer.blockchain.com:7050 -f channel-artifacts/channel.tx $FABRIC_TLS -c $CHANNEL_NAME 2019-04-28 19:12:13.144 UTC [channelCmd] InitCmdFactory - INFO 001 Endorser and orderer connections initialized 2019-04-28 19:12:13.180 UTC [cli.common] readBlock - INFO 002 Received block: 0 root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# The last line before you get your command prompt back will contain the words \"Received block: 0\". This indicates that your channel creation was successful, and the peer received the initial, or genesis block for the channel, which is block 0. Programmers love to start counting things at zero instead of one- it makes them feel special. Proceed to the next section where you will join each peer to the channel. \u2003 Section 6 - Instruct each peer node to join the channel In the last section, you issued the peer channel create command from one of the peers. Now any peer that you want to join the channel may join- you will issue the peer channel join command from each peer. For a peer to be eligible to join a channel, it must be a member of an organization that is authorized to join the channel. When you created your channel, you authorized Org0MSP and Org1MSP to join the channel. Each of your four peers belongs to one of those two organizations- two peers for each one- so they will be able to join successfully. If someone from an organization other than Org0MSP or Org1MSP attempted to join their peers to this channel, the attempt would fail. You are going to repeat the following steps for each of the four peer nodes, in order to show that the peer successfully joined the channel: Use the scripts/setpeer script to point the CLI to the peer Use the peer channel list command to show that the peer is not joined to any channels Use the peer channel join command to join the peer to your channel Use the peer channel list command again to see that the peer has joined your channel Step 6.1: Point the cli to peer0 for Org0MSP : root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# source scripts/setpeer 0 0 CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.key CORE_PEER_LOCALMSPID=Org0MSP CORE_PEER_TLS_ENABLED=true CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.crt CORE_PEER_ID=cli CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/users/Admin@unitedmarbles.com/msp CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/ca.crt CORE_PEER_ADDRESS=peer0.unitedmarbles.com:7051 CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 6.2: Enter peer channel list and observe that no channels are returned at the end of the output: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer channel list 2019-04-28 19:13:27.080 UTC [channelCmd] InitCmdFactory - INFO 001 Endorser and orderer connections initialized Channels peers has joined: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 6.3: Issue peer channel join -b $CHANNEL_NAME.block to join the channel you set up when you ran generateArtifacts.sh a little while ago. Among the many things that script did, it exported an environment variable named $CHANNEL_NAME set to the channel name you specified (or mychannel if you did not specify your own name), and then the Docker Compose file is set up to pass this environment variable to the cli container. If you are still on the happy path, your output will look similar to this: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer channel join -b $CHANNEL_NAME.block 2019-04-28 19:13:58.536 UTC [channelCmd] InitCmdFactory - INFO 001 Endorser and orderer connections initialized 2019-04-28 19:13:58.618 UTC [channelCmd] executeJoin - INFO 002 Successfully submitted proposal to join channel root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 6.4: Repeat the peer channel list command and now you should see your channel listed in the output: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer channel list 2019-04-28 19:14:23.186 UTC [channelCmd] InitCmdFactory - INFO 001 Endorser and orderer connections initialized Channels peers has joined: mychannel root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 6.5: Point the cli to peer1 for Org0MSP : root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# source scripts/setpeer 0 1 CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.key CORE_PEER_LOCALMSPID=Org0MSP CORE_PEER_TLS_ENABLED=true CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.crt CORE_PEER_ID=cli CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/users/Admin@unitedmarbles.com/msp CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer1.unitedmarbles.com/tls/ca.crt CORE_PEER_ADDRESS=peer1.unitedmarbles.com:7051 CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 6.6: Enter peer channel list and observe that no channels are returned at the end of the output: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer channel list 2019-04-28 19:15:21.894 UTC [channelCmd] InitCmdFactory - INFO 001 Endorser and orderer connections initialized Channels peers has joined: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 6.7: Issue peer channel join -b $CHANNEL_NAME.block to join your channel. Your output should look similar to this: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer channel join -b $CHANNEL_NAME.block 2019-04-28 19:15:53.751 UTC [channelCmd] InitCmdFactory - INFO 001 Endorser and orderer connections initialized 2019-04-28 19:15:53.851 UTC [channelCmd] executeJoin - INFO 002 Successfully submitted proposal to join channel root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 6.8: Repeat the peer channel list command and now you should see your channel listed: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer channel list 2019-04-28 19:16:19.287 UTC [channelCmd] InitCmdFactory - INFO 001 Endorser and orderer connections initialized Channels peers has joined: mychannel root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 6.9: Point the cli to peer0 for Org1MSP : root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# source scripts/setpeer 1 0 CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.key CORE_PEER_LOCALMSPID=Org1MSP CORE_PEER_TLS_ENABLED=true CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.crt CORE_PEER_ID=cli CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/marblesinc.com/users/Admin@marblesinc.com/msp CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/marblesinc.com/peers/peer0.marblesinc.com/tls/ca.crt CORE_PEER_ADDRESS=peer0.marblesinc.com:7051 CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 6.10: Enter peer channel list and observe that no channels are returned at the end of the output: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer channel list 2019-04-28 19:17:20.354 UTC [channelCmd] InitCmdFactory - INFO 001 Endorser and orderer connections initialized Channels peers has joined: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 6.11: Issue peer channel join -b $CHANNEL_NAME.block to join your channel. Your output should look similar to this: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer channel join -b $CHANNEL_NAME.block 2019-04-28 19:17:45.129 UTC [channelCmd] InitCmdFactory - INFO 001 Endorser and orderer connections initialized 2019-04-28 19:17:45.212 UTC [channelCmd] executeJoin - INFO 002 Successfully submitted proposal to join channel root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 6.12: Repeat the peer channel list command and now you should see your channel listed in the output: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer channel list 2019-04-28 19:18:14.491 UTC [channelCmd] InitCmdFactory - INFO 001 Endorser and orderer connections initialized Channels peers has joined: mychannel root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 6.13: Point the cli to peer1 for Org1MSP : root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# source scripts/setpeer 1 1 CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.key CORE_PEER_LOCALMSPID=Org1MSP CORE_PEER_TLS_ENABLED=true CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.crt CORE_PEER_ID=cli CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/marblesinc.com/users/Admin@marblesinc.com/msp CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/marblesinc.com/peers/peer1.marblesinc.com/tls/ca.crt CORE_PEER_ADDRESS=peer1.marblesinc.com:7051 CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 6.14: Enter peer channel list and observe that no channels are returned at the end of the output: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer channel list 2019-04-28 19:19:32.055 UTC [channelCmd] InitCmdFactory - INFO 001 Endorser and orderer connections initialized Channels peers has joined: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 6.15: Issue peer channel join -b $CHANNEL_NAME.block to join your channel. (Am I being redundant? Am I repeating myself? Am I saying the same thing over and over again?) Your output should look similar to this: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer channel join -b $CHANNEL_NAME.block 2019-04-28 19:19:51.856 UTC [channelCmd] InitCmdFactory - INFO 001 Endorser and orderer connections initialized 2019-04-28 19:19:51.953 UTC [channelCmd] executeJoin - INFO 002 Successfully submitted proposal to join channel root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 6.16: Repeat the peer channel list command and now you should see your channel listed in the output: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer channel list 2019-04-28 19:20:20.791 UTC [channelCmd] InitCmdFactory - INFO 001 Endorser and orderer connections initialized Channels peers has joined: mychannel root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer#s has joined: mychannel Section 7 - Define an \"anchor\" peer for each organization in the channel An anchor peer for an organization is a peer that can be known by all the other organizations in a channel. Not all peers for an organization need to be defined as anchor peers. Peers from other organizations will reach out to anchor peers which can then make information about the other peers available. In a production environment, an organization will typically define more than one peer as an anchor peer for availability and resilience. In our lab, we will just define one of the two peers for each organization as an anchor peer. The definition of an anchor peer took place back in section 4 when you ran the generateArtifacts.sh script. Two of the output files from that step were Org0MSPanchors.tx and Org1MSPanchors.tx. These are input files to define the anchor peers for Org0MSP and Org1MSP respectively. After the channel is created, each organization needs to run this command. You will do that now- this process is a little bit confusing in that the command to do this starts with peer channel create ... but the command will actually update the existing channel with the information about the desired anchor peer. Think of peer channel create here as meaning, \"create an update transaction for a channel\". Step 7.1: Switch to peer0 for Org0MSP : root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# source scripts/setpeer 0 0 # to switch to Peer 0 for Org0MSP CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.key CORE_PEER_LOCALMSPID=Org0MSP CORE_PEER_TLS_ENABLED=true CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.crt CORE_PEER_ID=cli CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/users/Admin@unitedmarbles.com/msp CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/ca.crt CORE_PEER_ADDRESS=peer0.unitedmarbles.com:7051 CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 7.2: Issue this command to create the anchor peer for Org0MSP : root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer channel create -o orderer.blockchain.com:7050 -f channel-artifacts/Org0MSPanchors.tx $FABRIC_TLS -c $CHANNEL_NAME 2019-04-28 19:23:09.479 UTC [channelCmd] InitCmdFactory - INFO 001 Endorser and orderer connections initialized 2019-04-28 19:23:09.495 UTC [cli.common] readBlock - INFO 002 Received block: 0 root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 7.3: Switch to peer0 for Org1MSP : root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# source scripts/setpeer 1 0 CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.key CORE_PEER_LOCALMSPID=Org1MSP CORE_PEER_TLS_ENABLED=true CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.crt CORE_PEER_ID=cli CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/marblesinc.com/users/Admin@marblesinc.com/msp CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/marblesinc.com/peers/peer0.marblesinc.com/tls/ca.crt CORE_PEER_ADDRESS=peer0.marblesinc.com:7051 CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 7.4: Issue this command to create the anchor peer for Org1MSP : root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer channel create -o orderer.blockchain.com:7050 -f channel-artifacts/Org1MSPanchors.tx $FABRIC_TLS -c $CHANNEL_NAME 2019-04-28 19:24:21.903 UTC [channelCmd] InitCmdFactory - INFO 001 Endorser and orderer connections initialized 2019-04-28 19:24:21.914 UTC [cli.common] readBlock - INFO 002 Received block: 0 root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Section 8 - Install the chaincode on the peer nodes Installing chaincode on the peer nodes puts the chaincode binary executable on a peer node. If you want the peer to be an endorser on a channel for a chaincode, then you must install the chaincode on that peer. If you only want the peer to be a committer on a channel for a chaincode, then you do not have to install the chaincode on that peer. In this section, you will install the chaincode on two of your peers. Step 8.1: Switch to peer0 in Org0MSP : root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# source scripts/setpeer 0 0 CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.key CORE_PEER_LOCALMSPID=Org0MSP CORE_PEER_TLS_ENABLED=true CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.crt CORE_PEER_ID=cli CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/users/Admin@unitedmarbles.com/msp CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/ca.crt CORE_PEER_ADDRESS=peer0.unitedmarbles.com:7051 CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 8.2: Try this command to list the chaincodes installed on the peer. It will return an empty list, as you haven't yet installed any chaincode on any of the peers: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode list --installed Get installed chaincodes on peer: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 8.3: Install the marbles chaincode on Peer0 in Org0MSP. You are looking for a message near the end of the output similar to what is shown here: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode install -n marbles -v 1.0 -p github.com/hyperledger/fabric/examples/chaincode/go/marbles 2019-04-28 19:25:59.811 UTC [chaincodeCmd] checkChaincodeCmdParams - INFO 001 Using default escc 2019-04-28 19:25:59.811 UTC [chaincodeCmd] checkChaincodeCmdParams - INFO 002 Using default vscc 2019-04-28 19:26:00.040 UTC [chaincodeCmd] install - INFO 003 Installed remotely response: status:200 payload:\"OK\" root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 8.4: Repeat the command from Step 8.2: - Tip: you could probably use the up arrow key a couple of times to retrieve that command as an alternative to doing a copy-and-paste here, but I'll leave it up to you: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode list --installed Get installed chaincodes on peer: Name: marbles, Version: 1.0, Path: github.com/hyperledger/fabric/examples/chaincode/go/marbles, Id: 19776f7d2a186d5188b748254a5767bd9689f3723672450c3fdd2daa62b4b746 root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Note: I won't have you repeat the \"before\" and \"after\" peer chaincode list --installed commands on any of the other peers on which you install it, but I won't take extraordinary measures to stop you if you insist on doing it. Step 8.5: Switch to peer0 in Org1MSP : root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# source scripts/setpeer 1 0 CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.key CORE_PEER_LOCALMSPID=Org1MSP CORE_PEER_TLS_ENABLED=true CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.crt CORE_PEER_ID=cli CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/marblesinc.com/users/Admin@marblesinc.com/msp CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/marblesinc.com/peers/peer0.marblesinc.com/tls/ca.crt CORE_PEER_ADDRESS=peer0.marblesinc.com:7051 CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 8.6: Install the marbles chaincode on Peer0 in Org1MSP. You are looking for a message near the end of the output similar to what is shown here: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode install -n marbles -v 1.0 -p github.com/hyperledger/fabric/examples/chaincode/go/marbles 2019-04-28 19:27:38.352 UTC [chaincodeCmd] checkChaincodeCmdParams - INFO 001 Using default escc 2019-04-28 19:27:38.352 UTC [chaincodeCmd] checkChaincodeCmdParams - INFO 002 Using default vscc 2019-04-28 19:27:38.570 UTC [chaincodeCmd] install - INFO 003 Installed remotely response: status:200 payload:\"OK\" root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# An interesting thing to note is that for the peer chaincode install command you did not need to specify the $FABRIC_TLS environment variable. This is because this operation does not cause the peer to communicate with the orderer. Also, you did not need to specify the $CHANNEL_NAME environment variable. This is because the peer chaincode install command only installs the chaincode on the peer node. You only need to do this once per peer. That is, even if you wanted to invoke the same chaincode on multiple channels on a peer, you only install the chaincode once on that peer. Installing chaincode on a peer is a necessary step, but not the only step needed, in order to execute chaincode on that peer. The chaincode must also be instantiated on a channel that the peer participates in. You will do that in the next section. \u2003 Section 9 - Instantiate the chaincode on the channel In the previous section, you installed chaincode on two of your four peers. Chaincode installation is a peer-level operation. Chaincode instantiation, however, is a channel-level operation. It only needs to be performed once on the channel, no matter how many peers have joined the channel. I'll try to prove it to you in this section. Chaincode instantiation causes a transaction to occur on the channel, so even if a peer on the channel does not have the chaincode installed, it will be made aware of the instantiate transaction, and thus be aware that the chaincode exists and be able to commit transactions from the chaincode to the ledger- it just would not be able to endorse a transaction on the chaincode. Step 9.1: You want to stay signed in to the cli Docker container; however, you will also want to issue some Docker commands from your Linux on IBM Z host, so at this time open up a second terminal session and sign in to your Linux on IBM Z host. For the remainder of this lab, I will refer to the session where you are in the cli Docker container as Terminal Session 1 , and this new session where you are at the Linux on IBM Z host as Terminal Session 2 . If you are running this lab from a Windows laptop you probably are using PuTTY. If you are running this lab from Linux or MacOS you are probably using terminal sessions and using ssh . Step 9.2: You are going to confirm that you do not have any chaincode Docker images created, nor any Docker chaincode containers running currently. From Terminal Session 2, enter this command and observe that all of your images begin with hyperledger : bcuser@ubuntu18042:~$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE hyperledger/fabric-ca 1.4.1 a836041637e8 2 weeks ago 220MB hyperledger/fabric-tools 1.4.1 330902566372 2 weeks ago 1.52GB hyperledger/fabric-orderer 1.4.1 1b709e319b2d 2 weeks ago 148MB hyperledger/fabric-peer 1.4.1 719392658c28 2 weeks ago 154MB hyperledger/fabric-couchdb s390x-0.4.15 81ee917e0be2 5 weeks ago 1.55GB bcuser@ubuntu18042:~$ You should not have any images which begin with dev- , which is what your Docker chaincode images will start with, and at this point in the lab Docker chaincode images have not been created yet. Step 9.3: Now do essentially the same thing with docker ps and you should see all of the Docker containers for the Hyperledger Fabric processes and CouchDB, but no chaincode-related Docker containers: bcuser@ubuntu18042:~$ docker ps --all CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 84b6c0ee74aa hyperledger/fabric-tools:1.4.1 \"bash\" 23 minutes ago Up 23 minutes cli e6eabd9fd96d hyperledger/fabric-peer:1.4.1 \"peer node start\" 23 minutes ago Up 23 minutes 0.0.0.0:9051- 7051/tcp, 0.0.0.0:9052- 7052/tcp, 0.0.0.0:9053- 7053/tcp peer0.marblesinc.com 8174f3021744 hyperledger/fabric-peer:1.4.1 \"peer node start\" 23 minutes ago Up 23 minutes 0.0.0.0:8051- 7051/tcp, 0.0.0.0:8052- 7052/tcp, 0.0.0.0:8053- 7053/tcp peer1.unitedmarbles.com 1a22b9eb5be5 hyperledger/fabric-peer:1.4.1 \"peer node start\" 23 minutes ago Up 23 minutes 0.0.0.0:10051- 7051/tcp, 0.0.0.0:10052- 7052/tcp, 0.0.0.0:10053- 7053/tcp peer1.marblesinc.com 11423ca89763 hyperledger/fabric-peer:1.4.1 \"peer node start\" 23 minutes ago Up 23 minutes 0.0.0.0:7051-7053- 7051-7053/tcp peer0.unitedmarbles.com 18b9e5efbfc9 hyperledger/fabric-couchdb:s390x-0.4.15 \"tini -- /docker-ent\u2026\" 23 minutes ago Up 23 minutes 4369/tcp, 9100/tcp, 0.0.0.0:6984- 5984/tcp couchdb1 77288f8c0060 hyperledger/fabric-couchdb:s390x-0.4.15 \"tini -- /docker-ent\u2026\" 23 minutes ago Up 23 minutes 4369/tcp, 9100/tcp, 0.0.0.0:7984- 5984/tcp couchdb2 43214da184da hyperledger/fabric-ca:1.4.1 \"sh -c 'fabric-ca-se\u2026\" 23 minutes ago Up 23 minutes 0.0.0.0:7054- 7054/tcp ca_Org0 1ea639c77a3a hyperledger/fabric-ca:1.4.1 \"sh -c 'fabric-ca-se\u2026\" 23 minutes ago Up 23 minutes 0.0.0.0:8054- 7054/tcp ca_Org1 07df27e35368 hyperledger/fabric-couchdb:s390x-0.4.15 \"tini -- /docker-ent\u2026\" 23 minutes ago Up 23 minutes 4369/tcp, 9100/tcp, 0.0.0.0:8984- 5984/tcp couchdb3 93e0465394b6 hyperledger/fabric-orderer:1.4.1 \"orderer\" 23 minutes ago Up 23 minutes 0.0.0.0:7050- 7050/tcp orderer.blockchain.com 4201915cc3b2 hyperledger/fabric-couchdb:s390x-0.4.15 \"tini -- /docker-ent\u2026\" 23 minutes ago Up 23 minutes 4369/tcp, 9100/tcp, 0.0.0.0:5984- 5984/tcp couchdb0 bcuser@ubuntu18042:~$ Step 9.4: Entering this will make this fact stand out more as you should only see column headers in your output. (The --invert-match argument for grep says \"do not show me anything that contains the string \"hyperledger\"): bcuser@ubuntu18042:~$ docker ps --all | grep --invert-match hyperledger CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES bcuser@ubuntu18042:~$ Now that you have established that you have no chaincode-related Docker images or containers present, try to instantiate the chaincode. Step 9.5: On Terminal Session 1, switch to Peer 0 of Org0MSP by entering: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# source scripts/setpeer 0 0 CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.key CORE_PEER_LOCALMSPID=Org0MSP CORE_PEER_TLS_ENABLED=true CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.crt CORE_PEER_ID=cli CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/users/Admin@unitedmarbles.com/msp CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/ca.crt CORE_PEER_ADDRESS=peer0.unitedmarbles.com:7051 CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 9.6: On Terminal Session 1, enter this command to list instantiated chaincodes on your channel. Spoiler alert- there aren't any, so you will get an empty list: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode list --instantiated --channelID ${CHANNEL_NAME} Get instantiated chaincodes on channel mychannel: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 9.7: On Terminal Session 1, issue the command to instantiate the chaincode on the channel: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode instantiate -o orderer.blockchain.com:7050 -n marbles -v 1.0 -c '{\"Args\":[\"init\",\"1\"]}' -P \"OR ('Org0MSP.member','Org1MSP.member')\" $FABRIC_TLS -C $CHANNEL_NAME 2019-04-28 19:32:27.208 UTC [chaincodeCmd] checkChaincodeCmdParams - INFO 001 Using default escc 2019-04-28 19:32:27.208 UTC [chaincodeCmd] checkChaincodeCmdParams - INFO 002 Using default vscc root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Note In your prior commands, when specifying the channel name, you used lowercase 'c' as the argument, e.g., -c $CHANNEL_NAME . In the peer chaincode instantiate command however, you use an uppercase 'C' as the argument to specify the channel name, e.g., -C mychannel , because -c is used to specify the arguments given to the chaincode. Why c for arguments you may ask? Well, the ' c ' is short for ' ctor ', which itself is an abbreviation for constructor , which is a fancy word object-oriented programmers use to refer to the initial arguments given when creating an object. Step 9.8: You may have noticed a longer than usual pause before you got your command prompt back while that last command was being run. The reason for this is that as part of the instantiate, a Docker image for the chaincode is created and then a Docker container is started from the image. To prove this to yourself, on Terminal Session 2, enter this to see the new Docker image: bcuser@ubuntu18042:~$ docker images dev-* REPOSITORY TAG IMAGE ID CREATED SIZE dev-peer0.unitedmarbles.com-marbles-1.0-7e92f069adb7469939a96dcba723fa2019745461f05a562e81cec38e46424aa1 latest d41acea306aa About a minute ago 137MB bcuser@ubuntu18042:~$ Step 9.9: And enter this to see the Docker chaincode container created from the new Docker image: bcuser@ubuntu18042:~$ docker ps | grep --invert-match hyperledger CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 62a185d148d2 dev-peer0.unitedmarbles.com-marbles-1.0-7e92f069adb7469939a96dcba723fa2019745461f05a562e81cec38e46424aa1 \"chaincode -peer.add\u2026\" About a minute ago Up About a minute dev-peer0.unitedmarbles.com-marbles-1.0 bcuser@ubuntu18042:~$ The naming convention used by Hyperledger Fabric v1.4.1 for the Docker images it creates for chaincode is HyperledgerFabricNetworkName-PeerName-ChaincodeName-ChaincodeVersion-SHA256Hash . In our case of dev-peer0.unitedmarbles.com-marbles-1.0- , the default name of a Hyperledger Fabric network is dev , and you did not change it. peer0.unitedmarbles.com is the peer name of peer0 of Org0MSP, and you specified this via the CORE_PEER_ID environment variable in the Docker Compose YAML file. marbles is the name you gave this chaincode in the -n argument of the peer chaincode install command, and 1.0 is the version of the chaincode you used in the -v argument of the peer chaincode install command. Note that a chaincode Docker container was only created for the peer on which you entered the peer chaincode instantiate command. Docker containers will not be created on the other peers until you run a peer chaincode invoke or peer chaincode query command on that peer. Step 9.10: In Terminal Session 1 repeat the command from Step 9.6 to see that your instantiated chaincode on your channel is now listed: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode list --instantiated --channelID ${CHANNEL_NAME} Get instantiated chaincodes on channel mychannel: Name: marbles, Version: 1.0, Path: github.com/hyperledger/fabric/examples/chaincode/go/marbles, Escc: escc, Vscc: vscc root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 9.11: Remember when I said at the beginning of this section that I would try to prove it to you that you only need to do the instantiate once on a channel, and not on every peer in the channel? Let's find out if I'm lying. You did the instantiate on peer \"0 0\". Switch to another peer: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# source scripts/setpeer 1 1 CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.key CORE_PEER_LOCALMSPID=Org1MSP CORE_PEER_TLS_ENABLED=true CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.crt CORE_PEER_ID=cli CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/marblesinc.com/users/Admin@marblesinc.com/msp CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/marblesinc.com/peers/peer1.marblesinc.com/tls/ca.crt CORE_PEER_ADDRESS=peer1.marblesinc.com:7051 CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 9.12: Repeat the command from Step 9.10 on this peer, and even though you did not run the peer chaincode instantiate on this peer, you will see that this peer is aware of the instantiation: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode list --instantiated --channelID ${CHANNEL_NAME} Get instantiated chaincodes on channel mychannel: Name: marbles, Version: 1.0, Escc: escc, Vscc: vscc root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# I would never lie to you. Section 10 - Invoke chaincode functions You are now ready to invoke chaincode functions that will create, read, update and delete data in the ledger. In this section, you will enter scripts/setpeer and peer chaincode commands in Terminal session 1, while you will enter docker ps and docker images commands in Terminal session 2. Step 10.1: Switch to peer0 of Org0MSP: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# source scripts/setpeer 0 0 CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.key CORE_PEER_LOCALMSPID=Org0MSP CORE_PEER_TLS_ENABLED=true CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.crt CORE_PEER_ID=cli CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/users/Admin@unitedmarbles.com/msp CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/ca.crt CORE_PEER_ADDRESS=peer0.unitedmarbles.com:7051 CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 10.2: You will use the marbles chaincode to create a new Marbles owner named John. If you would like to use a different name than John, that is fine but then there will be other places later where you would need to use your \"custom\" name instead of John. And John's the guy who first got this lab working about three years ago so I think he deserves a marble, don't you, so if you do want to show off and change the name then I'm going to let you figure out later where it might need to be changed. Enter this command in Terminal session 1: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode invoke -n marbles -c '{\"Args\":[\"init_owner\", \"o0000000000001\",\"John\",\"Marbles Inc\"]}' $FABRIC_TLS -C $CHANNEL_NAME 2019-04-28 19:37:38.570 UTC [chaincodeCmd] InitCmdFactory - INFO 001 Retrieved channel (mychannel) orderer endpoint: orderer.blockchain.com:7050 2019-04-28 19:37:38.585 UTC [chaincodeCmd] chaincodeInvokeOrQuery - INFO 002 Chaincode invoke successful. result: status:200 root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 10.3: Let's deconstruct the arguments to the chaincode: {\u201cArgs\u201d:[\u201cinit_owner\u201d, \u201co0000000000001\u201d, \u201cJohn\u201d, \u201cMarbles Inc\u201d]} This is in JSON format. JSON stands for JavaScript Object Notation, and is a very popular format for transmitting data in many languages, not just with JavaScript. What is shown above is a single name/value pair. The name is Args and the value is an array of four arguments. (The square brackets \"[\" and \"]\" specify an array in JSON). Note In the formal JSON definition the term ' name/value ' is used, but many programmers will also use the term ' key/value ' instead. You can consider these two terms as synonymous. (Many people use the phrase \"the same\" instead of the word \"synonymous\"). The Args name specifies the arguments passed to the chaincode invocation. There is an interface layer, also called a \"shim\", that gains control before passing it along to user-written chaincode functions- it expects this Args name/value pair. The shim also expects the first array value to be the name of the user-written chaincode function that it will pass control to, and then all remaining array values are the arguments to pass, in order, to that user-written chaincode function. So, in the command you just entered, the init_owner function is called, and it is passed three arguments, o0000000000001 , John , and Marbles Inc . It is logic within the init_owner function that cause updates to the channel's ledger- subject to the transaction flow in Hyperledger Fabric v1.4.1- that is, chaincode execution causes proposed updates to the ledger, which are only committed at the end of the transaction flow if everything is validated properly. But it all starts with function calls inside the chaincode functions that ask for ledger state to be created or updated. Step 10.4: Go to Terminal session 2, and enter this Docker command and you will observe that you still only have a Docker image and a Docker container for peer0 of Org0MSP: bcuser@ubuntu18042:~$ docker images dev-* REPOSITORY TAG IMAGE ID CREATED SIZE dev-peer0.unitedmarbles.com-marbles-1.0-7e92f069adb7469939a96dcba723fa2019745461f05a562e81cec38e46424aa1 latest d41acea306aa 5 minutes ago 137MB bcuser@ubuntu18042:~$ Step 10.5: Enter this command to see information about the chaincode container. I introduce here the --no-trunc option, which stands for no truncation , so you can see more information about the container: bcuser@ubuntu18042:~$ docker ps --no-trunc | grep dev- 62a185d148d2a0ead43120ca50e3ed459a2a005b08b10ece0c4ae205bf1f016a dev-peer0.unitedmarbles.com-marbles-1.0-7e92f069adb7469939a96dcba723fa2019745461f05a562e81cec38e46424aa1 \"chaincode -peer.address=peer0.unitedmarbles.com:7052\" 6 minutes ago Up 6 minutes dev-peer0.unitedmarbles.com-marbles-1.0 bcuser@ubuntu18042:~$ The takeaway is that the chaincode execution has only run on peer0 of Org0MSP so far, and this is also the peer on which you instantiated the chaincode, so the Docker image for the chaincode, and the corresponding Docker container based on the image, have been created for only this peer. You will see soon that other peers will have their own chaincode Docker image and Docker container built the first time they are needed. Step 10.6: You created a marble owner in the previous step. Now create a marble belonging to this owner. Perform this from peer0 of Org1, so from Terminal session 1, switch to Peer0 of Org1MSP: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# source scripts/setpeer 1 0 CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.key CORE_PEER_LOCALMSPID=Org1MSP CORE_PEER_TLS_ENABLED=true CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.crt CORE_PEER_ID=cli CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/marblesinc.com/users/Admin@marblesinc.com/msp CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/marblesinc.com/peers/peer0.marblesinc.com/tls/ca.crt CORE_PEER_ADDRESS=peer0.marblesinc.com:7051 CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 10.7: Now enter the command to create a new marble for John: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode invoke -n marbles -c '{\"Args\":[\"init_marble\",\"m0000000000001\",\"blue\",\"35\",\"o0000000000001\",\"Marbles Inc\"]}' $FABRIC_TLS -C $CHANNEL_NAME 2019-04-28 19:40:11.744 UTC [chaincodeCmd] InitCmdFactory - INFO 001 Retrieved channel (mychannel) orderer endpoint: orderer.blockchain.com:7050 2019-04-28 19:40:29.338 UTC [chaincodeCmd] chaincodeInvokeOrQuery - INFO 002 Chaincode invoke successful. result: status:200 root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# This time you called the init_marble function. Now you have created one owner, and one marble. The owner is John (or your custom name) and his id is o0000000000001 , and his marble has an id of m0000000000001 . I cleverly decided that the letter ' o ' stands for owner and the letter ' m ' stands for marbles. I put 12 leading zeros in front of the number 1 in case you wanted to stay late and create trillions of marbles and owners. Step 10.8: In Terminal session 2, issue the command to see that you have two Docker chaincode images: bcuser@ubuntu18042:~$ docker images dev-* REPOSITORY TAG IMAGE ID CREATED SIZE dev-peer0.marblesinc.com-marbles-1.0-4077677f13838bacbfd8ff943e7348c00f3c4d6ca6e2838efd14204ca87ea12b latest ab7f5fa821ee 36 seconds ago 137MB dev-peer0.unitedmarbles.com-marbles-1.0-7e92f069adb7469939a96dcba723fa2019745461f05a562e81cec38e46424aa1 latest d41acea306aa 8 minutes ago 137MB bcuser@ubuntu18042:~$ Step 10.9: In Terminal session 2, issue the command to see that you have two Docker chaincode containers: bcuser@ubuntu18042:~$ docker ps --no-trunc | grep dev-* a7d6b658a35a5f7f82d489f6f797a0463739cb7297cc083875cd6e232600a061 dev-peer0.marblesinc.com-marbles-1.0-4077677f13838bacbfd8ff943e7348c00f3c4d6ca6e2838efd14204ca87ea12b \"chaincode -peer.address=peer0.marblesinc.com:7052\" About a minute ago Up About a minute dev-peer0.marblesinc.com-marbles-1.0 62a185d148d2a0ead43120ca50e3ed459a2a005b08b10ece0c4ae205bf1f016a dev-peer0.unitedmarbles.com-marbles-1.0-7e92f069adb7469939a96dcba723fa2019745461f05a562e81cec38e46424aa1 \"chaincode -peer.address=peer0.unitedmarbles.com:7052\" 8 minutes ago Up 8 minutes dev-peer0.unitedmarbles.com-marbles-1.0 bcuser@ubuntu18042:~$ Step 10.10: You will create a new owner now. From Terminal Session 1, try it on Peer 1 of Org0MSP: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# source scripts/setpeer 0 1 CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.key CORE_PEER_LOCALMSPID=Org0MSP CORE_PEER_TLS_ENABLED=true CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.crt CORE_PEER_ID=cli CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/users/Admin@unitedmarbles.com/msp CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer1.unitedmarbles.com/tls/ca.crt CORE_PEER_ADDRESS=peer1.unitedmarbles.com:7051 CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 10.11: Note The command in this step is intended to fail. Go ahead and enter it and then read on for why it failed and how to correct the failure Run this commnand to try to create a new owner: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode invoke -n marbles -c '{\"Args\":[\"init_owner\",\"o0000000000002\",\"Barry\",\"United Marbles\"]}' $FABRIC_TLS -C $CHANNEL_NAME 2019-04-28 19:43:18.425 UTC [chaincodeCmd] InitCmdFactory - INFO 001 Retrieved channel (mychannel) orderer endpoint: orderer.blockchain.com:7050 Error: endorsement failure during invoke. response: status:500 message:\"cannot retrieve package for chaincode marbles/1.0, error open /var/hyperledger/production/chaincodes/marbles.1.0: no such file or directory\" root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# What do you expect to happen when you enter this command? If you have followed these instructions exactly so far, the invoke will fail. It will fail because you have not yet installed the chaincode on Peer 1 of Org0. Here is the output which shows the error: 2019-04-28 19:43:18.425 UTC [chaincodeCmd] InitCmdFactory - INFO 001 Retrieved channel (mychannel) orderer endpoint: orderer.blockchain.com:7050 Error: endorsement failure during invoke. response: status:500 message:\"cannot retrieve package for chaincode marbles/1.0, error open /var/hyperledger/production/chaincodes/marbles.1.0: no such file or directory\" You must first install chaincode on a peer not only before you can do an instantiate from that peer, but also before you can do an invoke or query from that peer. If you want a peer to perform the endorsing function for a transaction, the chaincode for that transaction must be installed on that peer. If that peer is a member of the channel on which the chaincode is instantiated, but has not had the chaincode installed on it, it will still perform the committer function and update its copy of the channel's ledger when it receives valid transactions from the orderer, but it cannot endorse transaction proposals unless the chaincode has been installed on it. Step 10.12 : Correct things by installing the chaincode on peer1 of Org0. In Terminal session 1, enter this command, which should look familiar to you: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode install -n marbles -v1.0 -p github.com/hyperledger/fabric/examples/chaincode/go/marbles 2019-04-28 19:44:56.984 UTC [chaincodeCmd] checkChaincodeCmdParams - INFO 001 Using default escc 2019-04-28 19:44:56.984 UTC [chaincodeCmd] checkChaincodeCmdParams - INFO 002 Using default vscc 2019-04-28 19:44:57.189 UTC [chaincodeCmd] install - INFO 003 Installed remotely response: status:200 payload:\"OK\" root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 10.13: Now, in Terminal session 1, repeat the peer chaincode invoke command from Step 10.9 . It should work this time: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode invoke -n marbles -c '{\"Args\":[\"init_owner\",\"o0000000000002\",\"Barry\",\"United Marbles\"]}' $FABRIC_TLS -C $CHANNEL_NAME 2019-04-28 19:45:34.761 UTC [chaincodeCmd] InitCmdFactory - INFO 001 Retrieved channel (mychannel) orderer endpoint: orderer.blockchain.com:7050 2019-04-28 19:45:51.745 UTC [chaincodeCmd] chaincodeInvokeOrQuery - INFO 002 Chaincode invoke successful. result: status:200 root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 10.14: Go back to Terminal session 2 and enter the Docker command that will show you that you now have your third chaincode-related Docker image, the one just built for peer1 of Org0: bcuser@ubuntu18042:~$ docker images dev-* REPOSITORY TAG IMAGE ID CREATED SIZE dev-peer1.unitedmarbles.com-marbles-1.0-dea1aa08dc7c6f282a31dd498670173c21d3e75ef0ef1d170b95e1212fbacb77 latest c0e41de218a2 30 seconds ago 137MB dev-peer0.marblesinc.com-marbles-1.0-4077677f13838bacbfd8ff943e7348c00f3c4d6ca6e2838efd14204ca87ea12b latest ab7f5fa821ee 5 minutes ago 137MB dev-peer0.unitedmarbles.com-marbles-1.0-7e92f069adb7469939a96dcba723fa2019745461f05a562e81cec38e46424aa1 latest d41acea306aa 13 minutes ago 137MB bcuser@ubuntu18042:~$ Step 10.15: Enter the Docker command that will show you that you now have your third chaincode-related Docker container, the one just built for peer1 of Org0: bcuser@ubuntu18042:~$ docker ps --no-trunc | grep dev- 1e5c05183d6f77f4ca1264bd26b996189c5665031ad007d3cdfa28fb5c1a81f9 dev-peer1.unitedmarbles.com-marbles-1.0-dea1aa08dc7c6f282a31dd498670173c21d3e75ef0ef1d170b95e1212fbacb77 \"chaincode -peer.address=peer1.unitedmarbles.com:7052\" 59 seconds ago Up 57 seconds dev-peer1.unitedmarbles.com-marbles-1.0 a7d6b658a35a5f7f82d489f6f797a0463739cb7297cc083875cd6e232600a061 dev-peer0.marblesinc.com-marbles-1.0-4077677f13838bacbfd8ff943e7348c00f3c4d6ca6e2838efd14204ca87ea12b \"chaincode -peer.address=peer0.marblesinc.com:7052\" 6 minutes ago Up 6 minutes dev-peer0.marblesinc.com-marbles-1.0 62a185d148d2a0ead43120ca50e3ed459a2a005b08b10ece0c4ae205bf1f016a dev-peer0.unitedmarbles.com-marbles-1.0-7e92f069adb7469939a96dcba723fa2019745461f05a562e81cec38e46424aa1 \"chaincode -peer.address=peer0.unitedmarbles.com:7052\" 14 minutes ago Up 14 minutes dev-peer0.unitedmarbles.com-marbles-1.0 bcuser@ubuntu18042:~$ Step 10.16: Try some additional chaincode invocations. You have had enough experience switching between peers with source scripts/setpeer and issuing the peer chaincode invoke command that I will not show the output, nor tell you from which peer you should enter your command. I will just list several more commands you can run against the marbles chaincode. Feel free to switch amongst the four peers as you see fit before you enter each command. Note however, that you have only installed the chaincode on three of the four peers, so if you choose that fourth peer, you will need to install the chaincode there first. I won't tell you which peer does not currently have the chaincode installed, but if you need a hint, it is the one that does not have a Docker image built yet for its chaincode. (Note that checking for the absence of a Docker image for a peer is not, by itself,proof that you have not installed the chaincode on that peer- the Docker image is not built until you first invoke a function against the chaincode on that peer). If you are ambitious and want to install the chaincode on that fourth peer, try the useful Docker commands I have shown you from Terminal Session 2 to see that the chaincode's Docker image and Docker container are created when you invoke a transaction on that fourth peer. Try some or all of these commands from Terminal session 1: Create a marble for Barry, i.e., owner o0000000000002: peer chaincode invoke -n marbles -c '{\"Args\":[\"init_marble\",\"m0000000000002\",\"green\",\"50\",\"o0000000000002\",\"United Marbles\"]}' $FABRIC_TLS -C $CHANNEL_NAME Obtain all marble information- marbles and owners: peer chaincode invoke -n marbles -c '{\"Args\":[\"read_everything\"]}' $FABRIC_TLS -C $CHANNEL_NAME Change marble ownership- 'Barry' is giving his marble to 'John': peer chaincode invoke -n marbles -c '{\"Args\":[\"set_owner\",\"m0000000000002\",\"o0000000000001\",\"United Marbles\"]}' $FABRIC_TLS -C $CHANNEL_NAME Get the history of marble 'm0000000000002': peer chaincode invoke -n marbles -c '{\"Args\":[\"getHistory\",\"m0000000000002\"]}' $FABRIC_TLS -C $CHANNEL_NAME Delete marble 'm0000000000002': peer chaincode invoke -n marbles -c '{\"Args\":[\"delete_marble\",\"m0000000000002\",\"Marbles Inc\"]}' $FABRIC_TLS -C $CHANNEL_NAME Try again to get the history of marble 'm0000000000002' after you just deleted it: peer chaincode invoke -n marbles -c '{\"Args\":[\"getHistory\",\"m0000000000002\"]}' $FABRIC_TLS -C $CHANNEL_NAME Obtain all marble information again. See if it matches your expectations based on the commands you have entered: peer chaincode invoke -n marbles -c '{\"Args\":[\"read_everything\"]}' $FABRIC_TLS -C $CHANNEL_NAME Step 10.17: Exit the cli Docker container from Terminal session 1. Your command prompt should change to reflect that you are now back at your Linux on IBM Z host prompt and no longer in the Docker container: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# exit exit bcuser@ubuntu18042:~/zmarbles$ Step 10.18: Congratulations for making it through the treacherous portion of the lab! Stay logged in to your two terminal sessions and leave your Hyperledger Fabric network and all the chaincode Docker containers up and running- you will use what you created here in Part 2 of the lab where you will install a front-end application offering a browser-based UI from which you will interact with the marbles chaincode that you have installed in here in Part 1. Continue to Part 2 of the lab now.","title":"Hlf part1"},{"location":"hlf-part1/#section-1-overview-of-hyperledger-fabric-smart-contract-installation-lab-part-1","text":"In this lab, you will work with the Marbles demo application, which is considered by many to be a de facto \"hello world\" application for getting started with Hyperledger Fabric. Hyperledger Fabric is one of several projects within the open-source Hyperledger collaborative effort hosted by the Linux Foundation. Hyperledger Fabric provides the distributed ledger, a.k.a. blockchain, technology that is the core of IBM Blockchain solutions and services. Below is a diagram that depicts the blockchain network you will build and operate: You will use Docker Compose to bring up a Hyperledger Fabric network in which two organizations will participate. There will be one orderer service for the entire network, and each organization will use its own certificate authority service and have two peer nodes. Each peer node will use CouchDB for its ledger store. Each peer node's CouchDB will run in a separate Docker container. That makes eleven Docker containers, as follows: 1 orderer service Docker container 2 certificate authority (CA) Docker containers (one for each organization) 4 peer node Docker containers (each of the two organizations has two peers) 4 CouchDB Docker containers (each peer node has its own separate CouchDB ledger store) You will also bring up a twelfth Docker container that we will call the cli container. You will use it as a convenience to enter Hyperledger Fabric commands targeted to specific peers. You will see how this is done later in the lab. The network you bring up will use Transport Layer Security (TLS) which provides secure, encrypted communications between the peer nodes and the orderer, just as most production implementations will require. You will install the Marbles chaincode on the peer nodes, instantiate the chaincode, and invoke functions of the chaincode. I will explain later in the lab the difference between the install and instantiate actions and what each one does.","title":"Section 1 - Overview of Hyperledger Fabric Smart Contract installation lab part 1"},{"location":"hlf-part1/#section-2-description-of-the-subsequent-sections-in-part-1","text":"This section provides a brief description of the subsequent sections in Part 1 of the lab, where you will get hands-on experience with the Hyperledger Fabric command line interface (CLI). In most production implementations you would perform many of these functions through other means, such as programmatically through an Application Programming Interface (API) provided by a Hyperledger Fabric Software Development Kit (SDK), which the project provides for the Node.js, Java, Golang and Python programming languages, or perhaps through a user interface such as the one provided by the IBM Blockchain Platform. But using the CLI, as you will in this lab, is a great way to learn about how Hyperledger Fabric works. You will extract the artifacts necessary to run the lab in Section 3. All the artifacts necessary for the lab are provided in a compressed tarball- in essence, a zip file. You will use Docker Compose in Section 4 to bring up the twelve Docker containers that comprise the Hyperledger Fabric network. You will see that all twelve Docker containers that I mentioned in Section 1 are brought up with a single docker-compose command, and I will explain some of the more interesting bits of what is going on under the covers. You will create a channel in the Hyperledger Fabric network in Section 5. In Hyperledger Fabric, each channel is essentially its own blockchain. You will instruct each peer node to join the channel in Section 6. We will join all four Peer nodes to the channel. Peer nodes can be members of more than one channel, but for this lab you are only creating one channel. You will define an \"anchor\" peer for each organization in the channel in Section 7. An anchor peer for an organization is a peer that is known by all the other organizations in a channel. Not all peers for an organization need to be known by outside organizations. Peers not defined as anchor peers are visible only within their own organization. You will install the chaincode on the peer nodes in Section 8. Installing chaincode simply puts the chaincode executable on the file system of the peer. It is a necessary step before you execute that chaincode on the peer, but the next step is also required. You will instantiate the chaincode on the channel in Section 9. This step is a prerequisite to being able to run chaincode on a channel. It only needs to be performed on one peer that is a member of the channel. This causes a transaction to be recorded on the channel's blockchain to indicate that the chaincode can be run on the channel. You will invoke functions on the chaincode that will create, read, update and delete (CRUD) data stored on the blockchain in Section 10. Blocks of transactions in a blockchain are always added (i.e., created), and they can be read, but they are never, in normal operations, updated or deleted. However, although the blocks in a chain are not updated or deleted, the transactions themselves operate on Key/Value pairs that can have all CRUD operations performed on them. This collection of Key/Value pairs is often referred to as state data.","title":"Section 2 - Description of the subsequent sections in Part 1"},{"location":"hlf-part1/#section-3-extract-the-artifacts-necessary-to-run-the-lab","text":"Log in to your assigned Linux on Z Ubuntu instance with the instructions provided to you by your class instructor. If you are using Linux or MacOS you will likely be using ssh to log in via a Terminal window. If you are using Windows, you will most likely be using a PuTTY terminal session. If you are trying this lab at home, I am assuming you can figure out how to log in. All of the following instructions in the lab assume that you have successfully logged in to the Linux on Z Ubuntu instance assigned to your team. As you proceed through the lab, you will have to be logged in to more than one terminal session. When that becomes necessary, simply follow the same procedure used to log in to your first terminal session. Let's get started! Step 3.1: Navigate to the home directory by entering cd ~ (the \"tilde\" character, i.e., ' ~ ', represents the user's home directory in Linux). This directory is also usually set in the $HOME environment variable, so cd $HOME will also usually get you to your home directory: bcuser@ubuntu18042:~$ cd ~ bcuser@ubuntu18042:~$ Note: You may already be in your home directory prior to entering cd ~ , in which case you'll just stay there- not a problem. Step 3.2: Retrieve the zmarbles compressed tarball prepared for this lab with the following command: bcuser@ubuntu18042:~$ wget https://raw.githubusercontent.com/ibm-blockchain-wsc/ImmersionWorkshop/master/zmarbles.tar.gz --2019-04-28 14:57:58-- https://raw.githubusercontent.com/ibm-blockchain-wsc/ImmersionWorkshop/master/zmarbles.tar.gz Resolving raw.githubusercontent.com (raw.githubusercontent.com)... 151.101.200.133 Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|151.101.200.133|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 10272273 (9.8M) [application/octet-stream] Saving to: 'zmarbles.tar.gz' zmarbles.tar.gz 100%[=================================================== ] 9.80M --.-KB/s in 0.1s 2019-04-28 14:57:58 (77.3 MB/s) - 'zmarbles.tar.gz' saved [10272273/10272273] bcuser@ubuntu18042:~$ Step 3.3: The zmarbles directory should not yet exist. Prove it with this ls command: bcuser@ubuntu18042:~$ ls zmarbles ls: cannot access 'zmarbles': No such file or directory bcuser@ubuntu18042:~$ Step 3.4: Extract the zmarbles.tar.gz file which will create the missing directory (and lots of subdirectories). If you want to see the name of all of the files and directories that are extracted, add the \" v \" switch into the options in the command below. That is, use -xzvf instead of -xzf . So, enter the tar command below as shown, feeling free to substitute -xzvf for -xzf in the command (the \" v \" is for \" verbose \") : bcuser@ubuntu18042:~$ tar -xzf zmarbles.tar.gz bcuser@ubuntu18042:~$ Step 3.5: List the zmarbles directory with this command: bcuser@ubuntu18042:~$ ls -l zmarbles total 64 drwxr-xr-x 2 bcuser bcuser 4096 Apr 16 11:54 base drwxrwxr-x 2 bcuser bcuser 4096 Jan 14 07:54 bin drwxr-xr-x 2 bcuser bcuser 4096 Apr 16 12:24 channel-artifacts drwxrwxr-x 2 bcuser bcuser 4096 Jul 3 2018 config -rw-r--r-- 1 bcuser bcuser 12209 Jul 30 2018 configtx.yaml -rw-r--r-- 1 bcuser bcuser 4175 Jul 30 2018 crypto-config.yaml -rw-r--r-- 1 bcuser bcuser 6304 Apr 16 11:54 docker-compose-template.yaml drwxr-xr-x 3 bcuser bcuser 4096 Jun 18 2017 examples -rwxr-xr-x 1 bcuser bcuser 3587 Sep 24 2018 generateArtifacts.sh drwxr-xr-x 2 bcuser bcuser 4096 Oct 1 2017 hostScripts drwxrwxr-x 9 bcuser bcuser 4096 Apr 16 12:24 marblesUI drwxr-xr-x 2 bcuser bcuser 4096 Jan 19 14:58 scripts bcuser@ubuntu18042:~$ An explanation of the purpose of each of these files and directories is given here: The base directory contains Docker Compose files that are included in the docker-compose-template.yaml file with the extends directive. The bin directory contains two executable programs, cryptogen and configtxgen , that will be run later when you execute the generateArtifacts.sh script. The channel-artifacts directory is empty, but it must exist when the generateArtifacts.sh script, which you will run later, invokes the configtxgen utility. The configtxgen utility generates input to channel configuration transactions, and it is expecting the channel-artifacts directory to exist. The configtx.yaml file is input to the configtxgen utility The cryto-config.yaml file is input to the cryptogen utiity, which is called by the generateArtifacts.sh script to create cryptographic material (in the form of X.509 certificates and public and private key pairs) used to identify peers, orderers, and administrative and regular users of a Hyperledger Fabric network. The docker-compose-template.yaml file is used as a template file that the generateArtifacts.sh script will use to create the main Docker Compose template file, docker-compose.yaml , which contains definitions for all of the Docker containers that you will need. The examples directory contains the actual Marbles chaincode within its subdirectory structure. The generateArtifacts.sh script is used to generate channel configuration transaction input and to generate cryptographic material and it also creates docker-compose.yaml , using docker-compose-template.yaml as input. The hostScripts directory is not used in this lab. The marblesUI directory is used in Part 2 of this lab, in which you will be working with the browser-based user interface (UI) for Marbles. The scripts directory contains a script named setpeer that you will be using throughout this lab from within the cli Docker container. setpeer will be explained in Section 5 .","title":"Section 3 - Extract the artifacts necessary to run the lab"},{"location":"hlf-part1/#section-4-bring-up-the-twelve-docker-containers-that-comprise-the-hyperledger-fabric-network","text":"Step 4.1: Change to the zmarbles directory with the cd command: bcuser@ubuntu18042:~$ cd zmarbles/ bcuser@ubuntu18042:~/zmarbles$ Step 4.2: You are going to run a script named generateArtifacts.sh that will create some configuration information that is necessary to get your Hyperledger Fabric network set up. There is one optional parameter you may pass to the script, and that is the name of the channel you will be creating. If you do not specify this parameter, the channel name defaults to mychannel . You may choose to specify your own channel name. E.g., if you wished to name your channel tim , then you would enter ./generateArtifacts.sh tim instead of just ./generateArtifacts.sh when directed below to enter the command. Warning If you pick your own channel name, it must start with a lowercase character, and only contain lowercase characters, numbers, or the dash ('-') character, or the period ('.'). So, enter the command below, optionally specifying a custom channel name (not shown here) as the lone argument to the generateArtifacts.sh script: bcuser@ubuntu18042:~/zmarbles$ source ./generateArtifacts.sh # specify a custom channel name or accept the default value of 'mychannel' Using cryptogen - /home/bcuser/zmarbles/bin/cryptogen ########################################################## ##### Generate certificates using cryptogen tool ######### ########################################################## unitedmarbles.com marblesinc.com Using configtxgen - /home/bcuser/zmarbles/bin/configtxgen ########################################################## ######### Generating Orderer Genesis block ############## ########################################################## 2019-04-28 15:01:07.988 EDT [common.tools.configtxgen] main - WARN 001 Omitting the channel ID for configtxgen for output operations is deprecated. Explicitly passing the channel ID will be required in the future, defaulting to 'testchainid'. 2019-04-28 15:01:07.988 EDT [common.tools.configtxgen] main - INFO 002 Loading configuration 2019-04-28 15:01:08.000 EDT [common.tools.configtxgen.localconfig] completeInitialization - INFO 003 orderer type: solo 2019-04-28 15:01:08.000 EDT [common.tools.configtxgen.localconfig] Load - INFO 004 Loaded configuration: /home/bcuser/zmarbles/configtx.yaml 2019-04-28 15:01:08.012 EDT [common.tools.configtxgen.localconfig] completeInitialization - INFO 005 orderer type: solo 2019-04-28 15:01:08.012 EDT [common.tools.configtxgen.localconfig] LoadTopLevel - INFO 006 Loaded configuration: /home/bcuser/zmarbles/configtx.yaml 2019-04-28 15:01:08.013 EDT [common.tools.configtxgen] doOutputBlock - INFO 007 Generating genesis block 2019-04-28 15:01:08.014 EDT [common.tools.configtxgen] doOutputBlock - INFO 008 Writing genesis block ################################################################# ### Generating channel configuration transaction 'channel.tx' ### ################################################################# 2019-04-28 15:01:08.077 EDT [common.tools.configtxgen] main - INFO 001 Loading configuration 2019-04-28 15:01:08.088 EDT [common.tools.configtxgen.localconfig] Load - INFO 002 Loaded configuration: /home/bcuser/zmarbles/configtx.yaml 2019-04-28 15:01:08.102 EDT [common.tools.configtxgen.localconfig] completeInitialization - INFO 003 orderer type: solo 2019-04-28 15:01:08.102 EDT [common.tools.configtxgen.localconfig] LoadTopLevel - INFO 004 Loaded configuration: /home/bcuser/zmarbles/configtx.yaml 2019-04-28 15:01:08.102 EDT [common.tools.configtxgen] doOutputChannelCreateTx - INFO 005 Generating new channel configtx 2019-04-28 15:01:08.102 EDT [common.tools.configtxgen.encoder] NewChannelGroup - WARN 006 Default policy emission is deprecated, please include policy specifications for the channel group in configtx.yaml 2019-04-28 15:01:08.103 EDT [common.tools.configtxgen.encoder] NewChannelGroup - WARN 007 Default policy emission is deprecated, please include policy specifications for the channel group in configtx.yaml 2019-04-28 15:01:08.104 EDT [common.tools.configtxgen] doOutputChannelCreateTx - INFO 008 Writing new channel tx ################################################################# ####### Generating anchor peer update for Org0MSP ########## ################################################################# 2019-04-28 15:01:08.170 EDT [common.tools.configtxgen] main - INFO 001 Loading configuration 2019-04-28 15:01:08.181 EDT [common.tools.configtxgen.localconfig] Load - INFO 002 Loaded configuration: /home/bcuser/zmarbles/configtx.yaml 2019-04-28 15:01:08.193 EDT [common.tools.configtxgen.localconfig] completeInitialization - INFO 003 orderer type: solo 2019-04-28 15:01:08.193 EDT [common.tools.configtxgen.localconfig] LoadTopLevel - INFO 004 Loaded configuration: /home/bcuser/zmarbles/configtx.yaml 2019-04-28 15:01:08.193 EDT [common.tools.configtxgen] doOutputAnchorPeersUpdate - INFO 005 Generating anchor peer update 2019-04-28 15:01:08.193 EDT [common.tools.configtxgen] doOutputAnchorPeersUpdate - INFO 006 Writing anchor peer update ################################################################# ####### Generating anchor peer update for Org1MSP ########## ################################################################# 2019-04-28 15:01:08.255 EDT [common.tools.configtxgen] main - INFO 001 Loading configuration 2019-04-28 15:01:08.266 EDT [common.tools.configtxgen.localconfig] Load - INFO 002 Loaded configuration: /home/bcuser/zmarbles/configtx.yaml 2019-04-28 15:01:08.277 EDT [common.tools.configtxgen.localconfig] completeInitialization - INFO 003 orderer type: solo 2019-04-28 15:01:08.278 EDT [common.tools.configtxgen.localconfig] LoadTopLevel - INFO 004 Loaded configuration: /home/bcuser/zmarbles/configtx.yaml 2019-04-28 15:01:08.278 EDT [common.tools.configtxgen] doOutputAnchorPeersUpdate - INFO 005 Generating anchor peer update 2019-04-28 15:01:08.278 EDT [common.tools.configtxgen] doOutputAnchorPeersUpdate - INFO 006 Writing anchor peer update bcuser@ubuntu18042:~/zmarbles$ This script calls two Hyperledger Fabric utilites- cryptogen , which creates security material (certificates and keys) and configtxgen (Configuration Transaction Generator), which is called four times, to create four things: An orderer genesis block -- this will be the first block on the orderer's system channel. The location of this block is specified to the Orderer when it is started up via the ORDERER_GENERAL_GENESISFILE environment variable. A channel transaction -- later in the lab, this is sent to the orderer and will cause a new channel to be created when you run the peer channel create command. An anchor peer update for Org0MSP. An anchor peer is a peer that is set up so that peers from other organizations may communicate with it. The concept of anchor peers allows an organization to create multiple peers, perhaps to provide extra capacity or throughput or resilience (or all the above) but not have to advertise this to outside organizations. An anchor peer update for Org1MSP. You will perform the anchor peer updates for both Org0MSP and Org1MSP later in the lab via peer channel create commands. Step 4.3: Issue the following command which will show you all files that were created by the configtxgen utility when it was called from inside generateArtifacts.sh : bcuser@ubuntu18042:~/zmarbles$ ls -ltr channel-artifacts total 28 -rw-r--r-- 1 bcuser bcuser 12995 Apr 28 15:01 genesis.block -rw-r--r-- 1 bcuser bcuser 346 Apr 28 15:01 channel.tx -rw-r--r-- 1 bcuser bcuser 285 Apr 28 15:01 Org0MSPanchors.tx -rw-r--r-- 1 bcuser bcuser 282 Apr 28 15:01 Org1MSPanchors.tx bcuser@ubuntu18042:~/zmarbles$ genesis.block will be passed to the orderer at startup, and will be used to configure the orderer's system channel . This file contains the x.509 signing certificates for every organization defined within the consortia that were specified within the configtx.yaml file when configtxgen was run. The system channel contains other values such as parameters defining when a block of transactions is cut- e.g., based on time, number of transactions, or block size- and these values serve as a template, that is, as defaults, for any additional channels that might be created, if a new channel creation request does not provide its own custom values. channel.tx is the input for a configuration transaction that will create a channel. You will use this as input to a peer channel create request in Section 5 . Org0MSPanchors.tx and Org1MSPanchors.tx are inputs for configuration transactions that will define an anchor peer for Org0 and Org1 respectively. You will use these inputs in Section 7 . Step 4.4: Issue the following command which will show you all files that were created by the cryptogen utility when it was called from inside generateArtifacts.sh . This command will show one screen at a time and pause- press the space bar to scroll to the end, that is, until you get your command prompt back: bcuser@ubuntu18042:~/zmarbles$ ls -ltrR crypto-config | more . . (output not shown here) . Actually, these files were created before the files listed in the prior step, Step 4.3 , were created, because, among the many cryptographic artifacts created are the x.509 signing certificates for the organizations, which are baked into the genesis.block discussed in the prior step. You can see that there is a dizzying set of directories and files, containing things like CA root certificates, signing certificates, TLS certificates, corresponding private keys, and public keys, for certificate authorities, organizations, administrative and general users. A thorough discussion of them is beyond the scope of this lab. Note This utiltity created crypto material for both organizations, including private keys that each organization would keep secret and never share with the other organizations. You have created this for both organizations on a single server for purposes of this lab, but in a production implementation each organization would create their own material separately so that they could indeed keep their private keys to themselves. Their public certificates, which are meant to be shared, are baked into the channel definitions for channels in which they participate. This allows peer nodes from all organizations in a channel to verify digital signatures of transaction requests and transaction endorsements from other organizations that are members of the channel. Step 4.5: You are going to look inside the Docker Compose configuration file a little bit. Enter the following command: bcuser@ubuntu18042:~/zmarbles$ vi -R docker-compose.yaml You can enter Ctrl-f to scroll forward in the file and Ctrl-b to scroll back in the file. The -R flag opens the file in read-only mode, so if you accidentally change something in the file, it's okay. It will not be saved. The statements within docker-compose.yaml are in a markup language called YAML , which stands for Y et A nother M arkup L anguage. (Who says nerds do not have a sense of humor). We will go over some highlights here. There are twelve \"services\", or Docker containers, defined within this file. They all start in column 3 and have several statements to describe them. For example, the first service defined is ca0 , and there are image , environment , ports , command , volumes , and container_name statements that describe it. If you scroll down in the file with Ctrl-f you will see all the services. Not every service has the same statements describing it. The twelve services are: ca0 -- The certificate authority service for \"Organization 0\" (unitedmarbles.com) ca1 -- The certificate authority service for \"Organization 1\" (marblesinc.com) orderer.blockchain.com -- The single ordering service that both organizations will use peer0.unitedmarbles.com -- The first peer node for \"Organization 0\" peer1.unitedmarbles.com -- The second peer node for \"Organization 0\" peer0.marblesinc.com -- The first peer node for \"Organization 1\" peer1.marblesinc.com -- The second peer node for \"Organization 1\" couchdb0 -- The CouchDB server for peer0.unitedmarbles.com couchdb1 -- The CouchDB server for peer1.unitedmarbles.com couchdb2 -- The CouchDB server for peer0.marblesinc.com couchdb3 -- The CouchDB server for peer1.marblesinc.com cli -- The Docker container from which you will enter Hyperledger Fabric command line interface (CLI) commands targeted towards a peer node. I will describe how several statements work within the file, but time does not permit me to address every single line in the file! image statements define which Docker image file the Docker container will be created from. Basically, the Docker image file is a static file that, once created, is read-only. A Docker container is based on a Docker image, and any changes to the file system within a Docker container are stored within the container. So, multiple Docker containers can be based on the same Docker image, and each Docker container keeps track of its own changes. For example, the containers built for the ca0 and ca1 service will both be based on the hyperledger/fabric-ca:1.4.1 Docker image because they both have this statement in their definition: image: hyperledger/fabric-ca:1.4.1 environment statements define environment variables that are available to the Docker container. The Hyperledger Fabric processes make ample use of environment variables. In general, you will see that the certificate authority environment variables start with FABRIC_CA , the orderer's environment variables start with ORDERER_GENERAL , and the peer node's environment variables start with CORE . These variables control behavior of the Hyperledger Fabric code, and, in many cases, will override values that are specified in configuration files. All the peers and the orderer have an environment variable to specify that TLS is enabled- CORE_PEER_TLS_ENABLED=true for the peers and ORDERER_GENERAL_TLS_ENABLED=true for the orderer. You will notice there are other TLS-related variables to specify private keys, certificates and root certificates. Note Most of the TLS-related environment variables for the peer and orderer are specified in separate files that are brought in via the extends statement. Specifically, base/docker-compose.yaml for the orderer and base/peer-base.yaml for the peers. We'll discuss the extends statement shortly. ports statements map ports on our Linux on IBM Z host to ports within the Docker container. The syntax is host port : Docker container port . For example, the service for ca1 has this port statement: ports: - \"8054:7054\" This says that port 7054 in the Docker container for the ca1 node will be mapped to port 8054 on your Linux on IBM Z host. This is how you can run two CA nodes in two Docker containers and four peer nodes in four Docker containers and keep things straight- within each CA node they are both using port 7054, and within each peer node Docker container, they are all using port 7051 for the same thing, but if you want to get to one of the peers from your host or even the outside world, you would target the appropriate host-mapped port. Note: To see the port mappings for the peers you have to look in base/docker-compose.yaml . See if you can figure out why. container_name statements are used to create hostnames that the Docker containers spun up by the docker-compose command use to communicate with each other. A separate, private network will be created by Docker where the 12 Docker containers can communicate with each other via the names specified by container_name . So, they do not need to worry about the port mappings from the ports statements- those are used for trying to get to the Docker containers from outside the private network created by Docker. volumes statements are used to map file systems on the host to file systems within the Docker container. Just like with ports, the file system on the host system is on the left and the file system name mapped within the Docker container is on the right. For example, look at this statement from the ca0 service: volumes: - ./crypto-config/peerOrganizations/unitedmarbles.com/ca/:/etc/hyperledger/fabric-ca-server-config The security-related files that were created from the previous step where you ran generateArtifacts.sh were all within the crypto-config directory on your Linux on IBM Z host. The prior volumes statement is how this stuff is made accessible to the ca0 service that will run within the Docker container. Similar magic is done for the other services as well, except for the CouchDB services. extends statements are used by the peer nodes. What this does is merge in other statements from another file. For example, you may notice that the peer nodes do not contain an images statement. How does Docker know what Docker image file to base the container on? That is defined in the file, base/peer-base.yaml , specified in the extends section of base/docker-compose.yaml , which is specified in the extends section of docker-compose.yaml for the peer nodes. command statements define what command is run when the Docker container is started. This is how the actual Hyperledger Fabric processes get started. You can define default commands when you create the Docker image. This is why you do not see command statements for the cli service or for the CouchDB services. For the peer nodes, the command statement is specified in the base/peer-base.yaml file. working_dir statements define what directory the Docker container will be in when its startup commands are run. Again, defaults for this can be defined when the Docker image is created. When you are done reviewing the docker-compose.yaml file, exit the vi session by typing :q! (that's \"colon\", \"q\", \"exclamation point\") which will exit the file and discard any changes you may have accidentally made while browsing through the file. If :q! doesn't work right away, you may have to hit the escape key first before trying it. If that still doesn't work, ask an instructor for help- vi can be tricky if you are not used to it. If you would like to see what is in the base/docker-compose-base.yaml and base/peer-base.yaml files I mentioned, take a quick peek with vi -R base/docker-compose-base.yaml and vi -R base/peer-base.yaml and exit with the :q! key sequence when you have had enough. Step 4.6: Start the Hyperledger Fabric network by entering the command shown below: bcuser@ubuntu18042:~/zmarbles$ docker-compose up --detach Creating network \"zmarbles_default\" with the default driver Pulling orderer.blockchain.com (hyperledger/fabric-orderer:1.4.1)... 1.4.1: Pulling from hyperledger/fabric-orderer 39653445334d: Pull complete 329bdf3df601: Pull complete e1af42922173: Pull complete 4b9e5154055d: Pull complete 8ed6225295fd: Pull complete 11c7fddfdc0f: Pull complete Pulling ca1 (hyperledger/fabric-ca:1.4.1)... 1.4.1: Pulling from hyperledger/fabric-ca 39653445334d: Already exists 329bdf3df601: Already exists e1af42922173: Already exists a5b6cc1abc77: Pull complete 1d0fabac8892: Pull complete 6eae46c3b75a: Pull complete ce86d957bb82: Pull complete a089155eb52f: Pull complete Pulling ca0 (hyperledger/fabric-ca:1.4.1)... 1.4.1: Pulling from hyperledger/fabric-ca Pulling couchdb0 (hyperledger/fabric-couchdb:s390x-0.4.15)... s390x-0.4.15: Pulling from hyperledger/fabric-couchdb 39653445334d: Already exists 329bdf3df601: Already exists e1af42922173: Already exists 38375a01635c: Pull complete e0c199f48fe8: Pull complete 32ba5a82959e: Pull complete 7e91f8f93642: Pull complete 17039674b6c5: Pull complete 2ff3f86b6c77: Pull complete ce5364742c8c: Pull complete 8202e4590853: Pull complete 2f293014c84a: Pull complete 9779e3b3aa0f: Pull complete c78880840b57: Pull complete 66b99fceb3c4: Pull complete abe937827dde: Pull complete ad4c12835ee0: Pull complete Pulling peer0.unitedmarbles.com (hyperledger/fabric-peer:1.4.1)... 1.4.1: Pulling from hyperledger/fabric-peer 39653445334d: Already exists 329bdf3df601: Already exists e1af42922173: Already exists 4b9e5154055d: Already exists 22c8eabb9c48: Pull complete b536383fde82: Pull complete Pulling cli (hyperledger/fabric-tools:1.4.1)... 1.4.1: Pulling from hyperledger/fabric-tools 39653445334d: Already exists 329bdf3df601: Already exists e1af42922173: Already exists 38375a01635c: Already exists e0c199f48fe8: Already exists 32ba5a82959e: Already exists 7e91f8f93642: Already exists 5bcfc5abd027: Pull complete 3ff8871c88b1: Pull complete 9a7a331d670e: Pull complete Creating couchdb0 ... done Creating orderer.blockchain.com ... done Creating couchdb3 ... done Creating ca_Org1 ... done Creating couchdb2 ... done Creating ca_Org0 ... done Creating couchdb1 ... done Creating peer0.unitedmarbles.com ... done Creating peer1.marblesinc.com ... done Creating peer1.unitedmarbles.com ... done Creating peer0.marblesinc.com ... done Creating cli ... done bcuser@ubuntu18042:~/zmarbles$ Note: Depending upon the circumstances under which you run this lab, the Hyperledger Fabric Docker images required may already exist on your system, in which case you may not observe the messages shown above that show the progress of the downloads. Step 4.7: Verify that all twelve services are Up and none of them say Exited . The Exited status means something went wrong, and you should check with an instructor for help if you see any of them in Exited status. If, however, all twelve of your Docker containers are in Up status, as in the output below, you are ready to proceed to the next section: bcuser@ubuntu18042:~/zmarbles$ docker ps --all CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 84b6c0ee74aa hyperledger/fabric-tools:1.4.1 \"bash\" 2 minutes ago Up 2 minutes cli e6eabd9fd96d hyperledger/fabric-peer:1.4.1 \"peer node start\" 2 minutes ago Up 2 minutes 0.0.0.0:9051- 7051/tcp, 0.0.0.0:9052- 7052/tcp, 0.0.0.0:9053- 7053/tcp peer0.marblesinc.com 8174f3021744 hyperledger/fabric-peer:1.4.1 \"peer node start\" 2 minutes ago Up 2 minutes 0.0.0.0:8051- 7051/tcp, 0.0.0.0:8052- 7052/tcp, 0.0.0.0:8053- 7053/tcp peer1.unitedmarbles.com 1a22b9eb5be5 hyperledger/fabric-peer:1.4.1 \"peer node start\" 2 minutes ago Up 2 minutes 0.0.0.0:10051- 7051/tcp, 0.0.0.0:10052- 7052/tcp, 0.0.0.0:10053- 7053/tcp peer1.marblesinc.com 11423ca89763 hyperledger/fabric-peer:1.4.1 \"peer node start\" 2 minutes ago Up 2 minutes 0.0.0.0:7051-7053- 7051-7053/tcp peer0.unitedmarbles.com 18b9e5efbfc9 hyperledger/fabric-couchdb:s390x-0.4.15 \"tini -- /docker-ent\u2026\" 2 minutes ago Up 2 minutes 4369/tcp, 9100/tcp, 0.0.0.0:6984- 5984/tcp couchdb1 77288f8c0060 hyperledger/fabric-couchdb:s390x-0.4.15 \"tini -- /docker-ent\u2026\" 2 minutes ago Up 2 minutes 4369/tcp, 9100/tcp, 0.0.0.0:7984- 5984/tcp couchdb2 43214da184da hyperledger/fabric-ca:1.4.1 \"sh -c 'fabric-ca-se\u2026\" 2 minutes ago Up 2 minutes 0.0.0.0:7054- 7054/tcp ca_Org0 1ea639c77a3a hyperledger/fabric-ca:1.4.1 \"sh -c 'fabric-ca-se\u2026\" 2 minutes ago Up 2 minutes 0.0.0.0:8054- 7054/tcp ca_Org1 07df27e35368 hyperledger/fabric-couchdb:s390x-0.4.15 \"tini -- /docker-ent\u2026\" 2 minutes ago Up 2 minutes 4369/tcp, 9100/tcp, 0.0.0.0:8984- 5984/tcp couchdb3 93e0465394b6 hyperledger/fabric-orderer:1.4.1 \"orderer\" 2 minutes ago Up 2 minutes 0.0.0.0:7050- 7050/tcp orderer.blockchain.com 4201915cc3b2 hyperledger/fabric-couchdb:s390x-0.4.15 \"tini -- /docker-ent\u2026\" 2 minutes ago Up 2 minutes 4369/tcp, 9100/tcp, 0.0.0.0:5984- 5984/tcp couchdb0 bcuser@ubuntu18042:~/zmarbles$ Step 4.8: Try this variant of the docker ps command that uses the --format * option to show only a subset of the information shown in the previous caommand: bcuser@ubuntu18042:~/zmarbles$ docker ps --all --format '{{.Names}}\\t\\t {{.Status}}' cli Up About a minute peer1.unitedmarbles.com Up About a minute peer0.marblesinc.com Up About a minute peer0.unitedmarbles.com Up 2 minutes peer1.marblesinc.com Up About a minute couchdb1 Up About a minute couchdb2 Up About a minute ca_Org1 Up 2 minutes ca_Org0 Up 2 minutes orderer.blockchain.com Up 2 minutes couchdb3 Up 2 minutes couchdb0 Up 2 minutes","title":"Section 4 - Bring up the twelve Docker containers that comprise the Hyperledger Fabric network"},{"location":"hlf-part1/#section-5-create-a-channel-in-the-hyperledger-fabric-network","text":"In a Hyperledger Fabric v1.4.1 network, multiple channels can be created. Each channel can have its own policies for things such as requirements for endorsement and what organizations may join the channel. This allows for a subset of network participants to participate in their own channel. Imagine a scenario where OrgA, OrgB and OrgC are three organizations participating in the network. You could set up a channel in which all three organizations participate. You could also set up a channel where only OrgA and OrgB participate. In this case, the peers in OrgC would not see the transactions occurring in that channel. OrgA could participate in another channel with only OrgC, in which case OrgB does not have visibility. And so on. You could create channels with the same participants, but have different policies. For example, perhaps one channel with OrgA, OrgB, and OrgC could require all three organizations to endorse a transaction proposal, but another channel with OrgA, OrgB and OrgC could require just two, or even just one, of the three organizations to endorse a transaction proposal. Note A use case where only one organization would need to endorse a transaction proposal would be unusual, as the whole point of blockchain is for multiple organizations to agree on what is valid transaction, and allowing just one organization to consider a transaction valid sort of goes against the grain of that type of thinking, but I never say never (oops! I just said it twice) but it is technically possible. Most trust models would probably call for a majority, a super-majority (e.g. two-thirds), or even unanimous consent (100%) of the organizations in the channel to endorse a transaction proposal. Note A policy of requiring unanimous consent implies that each member organization should build an available and resilient infrastructure since if even one organization's peers are unavailable, then additions to the blockchain for that channel would grind to a halt. Then again, who runs in production without an available and resilient infrastructure anyway? The decision on how many channels to create and what policies they have will usually be driven by the requirements of the particular business problem being solved. Step 5.1: Access the cli Docker container: bcuser@ubuntu18042:~/zmarbles$ docker exec --interactive --tty cli bash root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Observe that your command prompt changes when you enter the Docker container's shell. The docker exec command runs a command against an existing Docker container. The --interactive and --tty arguments basically work together to say, \"we want an interactive terminal session with this Docker container\". cli is the name of the Docker container (this came from the container_name statement in the docker-compose.yaml file for the cli service). bash is the name of the command you want to enter. In other words, you are entering a Bash shell within the cli Docker container. For most of the rest of the lab, you will be entering commands within this Bash shell. Instead of working as user bcuser on the ubuntu18042 server in the ~/zmarbles directory, you are now inside the Docker container with ID aaaaf5aa2798 (your ID will differ), working in the /opt/gopath/src/github.com/hyperledger/fabric/peer directory. It is no coincidence that that directory is the value of the working_dir statement for the cli service in your docker-compose.yaml file. Step 5.2: There is no command to enter in this step, but read this explanation of convenience script that you will use repeatedly to point to a particular peer from the cli Docker container. Within the cli container, a convenience script named setpeer is provided in the scripts subdirectory of your current working directory. This script will set the environment variables to the values necessary to point to a particular peer. The script takes two arguments. The first argument is either 0 or 1 for Organization 0 or Organization 1 respectively, and the second argument is for either Peer 0 or Peer 1 of the organization selected by the first argument. Therefore, throughout the remainder of this lab, before sending commands to a peer, you will enter one of the following four valid combinations from within the cli Docker container, depending on which peer you want to run the command on: source scripts/setpeer 0 0 # to target Org 0, peer 0 (peer0.unitedmarbles.com) source scripts/setpeer 0 1 # to target Org 0, peer 1 (peer1.united marbles.com) source scripts/setpeer 1 0 # to target Org 1, peer 0 (peer0.marblesinc.com) source scripts/setpeer 1 1 # to target Org 1, peer 1 (peer1.marblesinc.com) Step 5.3: Choose your favorite peer and use one of the four source scripts/setpeer commands listed in the prior step. Although you are going to join all four peers to our channel, you only need to issue the channel creation command once. You can issue it from any of the four peers, so pick your favorite peer and issue the source command. In this screen snippet, I have chosen Org 1, peer 1. Issue the command below, leaving the arguments '1 1' as is, or change it to one of the other valid combinations as described in the previous step: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# source scripts/setpeer 1 1 CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.key CORE_PEER_LOCALMSPID=Org1MSP CORE_PEER_TLS_ENABLED=true CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.crt CORE_PEER_ID=cli CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/marblesinc.com/users/Admin@marblesinc.com/msp CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/marblesinc.com/peers/peer1.marblesinc.com/tls/ca.crt CORE_PEER_ADDRESS=peer1.marblesinc.com:7051 CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# The next to last environment variable listed, CORE_PEER_ADDRESS , determines to which peer your commands will be routed. Step 5.4: The Hyperledger Fabric network is configured to require TLS, so when you enter your peer commands, you need to add a flag that indicates TLS is enabled, and you need to add an argument that points to the root signer certificate of the certificate authority for the orderer service. Fortunately, an environment variable has been set for you within the CLI container that sets the flag ( --tls argument) and points to the appropriate certificate (the --cafile argument) so that you can simply pass both arguments by specifying the single short environment variable name instead of having to enter the two arguments and the tediously long argument value for --cafile . Enter this command now to see the value of this environment variable, and thank me later for setting this up for you: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# echo $FABRIC_TLS --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/blockchain.com/orderers/orderer.blockchain.com/msp/tlscacerts/tlsca.blockchain.com-cert.pem root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 5.5: Now enter this command: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer channel create -o orderer.blockchain.com:7050 -f channel-artifacts/channel.tx $FABRIC_TLS -c $CHANNEL_NAME 2019-04-28 19:12:13.144 UTC [channelCmd] InitCmdFactory - INFO 001 Endorser and orderer connections initialized 2019-04-28 19:12:13.180 UTC [cli.common] readBlock - INFO 002 Received block: 0 root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# The last line before you get your command prompt back will contain the words \"Received block: 0\". This indicates that your channel creation was successful, and the peer received the initial, or genesis block for the channel, which is block 0. Programmers love to start counting things at zero instead of one- it makes them feel special. Proceed to the next section where you will join each peer to the channel.","title":"Section 5 - Create a channel in the Hyperledger Fabric network"},{"location":"hlf-part1/#section-6-instruct-each-peer-node-to-join-the-channel","text":"In the last section, you issued the peer channel create command from one of the peers. Now any peer that you want to join the channel may join- you will issue the peer channel join command from each peer. For a peer to be eligible to join a channel, it must be a member of an organization that is authorized to join the channel. When you created your channel, you authorized Org0MSP and Org1MSP to join the channel. Each of your four peers belongs to one of those two organizations- two peers for each one- so they will be able to join successfully. If someone from an organization other than Org0MSP or Org1MSP attempted to join their peers to this channel, the attempt would fail. You are going to repeat the following steps for each of the four peer nodes, in order to show that the peer successfully joined the channel: Use the scripts/setpeer script to point the CLI to the peer Use the peer channel list command to show that the peer is not joined to any channels Use the peer channel join command to join the peer to your channel Use the peer channel list command again to see that the peer has joined your channel Step 6.1: Point the cli to peer0 for Org0MSP : root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# source scripts/setpeer 0 0 CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.key CORE_PEER_LOCALMSPID=Org0MSP CORE_PEER_TLS_ENABLED=true CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.crt CORE_PEER_ID=cli CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/users/Admin@unitedmarbles.com/msp CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/ca.crt CORE_PEER_ADDRESS=peer0.unitedmarbles.com:7051 CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 6.2: Enter peer channel list and observe that no channels are returned at the end of the output: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer channel list 2019-04-28 19:13:27.080 UTC [channelCmd] InitCmdFactory - INFO 001 Endorser and orderer connections initialized Channels peers has joined: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 6.3: Issue peer channel join -b $CHANNEL_NAME.block to join the channel you set up when you ran generateArtifacts.sh a little while ago. Among the many things that script did, it exported an environment variable named $CHANNEL_NAME set to the channel name you specified (or mychannel if you did not specify your own name), and then the Docker Compose file is set up to pass this environment variable to the cli container. If you are still on the happy path, your output will look similar to this: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer channel join -b $CHANNEL_NAME.block 2019-04-28 19:13:58.536 UTC [channelCmd] InitCmdFactory - INFO 001 Endorser and orderer connections initialized 2019-04-28 19:13:58.618 UTC [channelCmd] executeJoin - INFO 002 Successfully submitted proposal to join channel root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 6.4: Repeat the peer channel list command and now you should see your channel listed in the output: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer channel list 2019-04-28 19:14:23.186 UTC [channelCmd] InitCmdFactory - INFO 001 Endorser and orderer connections initialized Channels peers has joined: mychannel root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 6.5: Point the cli to peer1 for Org0MSP : root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# source scripts/setpeer 0 1 CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.key CORE_PEER_LOCALMSPID=Org0MSP CORE_PEER_TLS_ENABLED=true CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.crt CORE_PEER_ID=cli CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/users/Admin@unitedmarbles.com/msp CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer1.unitedmarbles.com/tls/ca.crt CORE_PEER_ADDRESS=peer1.unitedmarbles.com:7051 CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 6.6: Enter peer channel list and observe that no channels are returned at the end of the output: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer channel list 2019-04-28 19:15:21.894 UTC [channelCmd] InitCmdFactory - INFO 001 Endorser and orderer connections initialized Channels peers has joined: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 6.7: Issue peer channel join -b $CHANNEL_NAME.block to join your channel. Your output should look similar to this: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer channel join -b $CHANNEL_NAME.block 2019-04-28 19:15:53.751 UTC [channelCmd] InitCmdFactory - INFO 001 Endorser and orderer connections initialized 2019-04-28 19:15:53.851 UTC [channelCmd] executeJoin - INFO 002 Successfully submitted proposal to join channel root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 6.8: Repeat the peer channel list command and now you should see your channel listed: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer channel list 2019-04-28 19:16:19.287 UTC [channelCmd] InitCmdFactory - INFO 001 Endorser and orderer connections initialized Channels peers has joined: mychannel root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 6.9: Point the cli to peer0 for Org1MSP : root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# source scripts/setpeer 1 0 CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.key CORE_PEER_LOCALMSPID=Org1MSP CORE_PEER_TLS_ENABLED=true CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.crt CORE_PEER_ID=cli CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/marblesinc.com/users/Admin@marblesinc.com/msp CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/marblesinc.com/peers/peer0.marblesinc.com/tls/ca.crt CORE_PEER_ADDRESS=peer0.marblesinc.com:7051 CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 6.10: Enter peer channel list and observe that no channels are returned at the end of the output: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer channel list 2019-04-28 19:17:20.354 UTC [channelCmd] InitCmdFactory - INFO 001 Endorser and orderer connections initialized Channels peers has joined: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 6.11: Issue peer channel join -b $CHANNEL_NAME.block to join your channel. Your output should look similar to this: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer channel join -b $CHANNEL_NAME.block 2019-04-28 19:17:45.129 UTC [channelCmd] InitCmdFactory - INFO 001 Endorser and orderer connections initialized 2019-04-28 19:17:45.212 UTC [channelCmd] executeJoin - INFO 002 Successfully submitted proposal to join channel root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 6.12: Repeat the peer channel list command and now you should see your channel listed in the output: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer channel list 2019-04-28 19:18:14.491 UTC [channelCmd] InitCmdFactory - INFO 001 Endorser and orderer connections initialized Channels peers has joined: mychannel root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 6.13: Point the cli to peer1 for Org1MSP : root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# source scripts/setpeer 1 1 CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.key CORE_PEER_LOCALMSPID=Org1MSP CORE_PEER_TLS_ENABLED=true CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.crt CORE_PEER_ID=cli CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/marblesinc.com/users/Admin@marblesinc.com/msp CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/marblesinc.com/peers/peer1.marblesinc.com/tls/ca.crt CORE_PEER_ADDRESS=peer1.marblesinc.com:7051 CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 6.14: Enter peer channel list and observe that no channels are returned at the end of the output: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer channel list 2019-04-28 19:19:32.055 UTC [channelCmd] InitCmdFactory - INFO 001 Endorser and orderer connections initialized Channels peers has joined: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 6.15: Issue peer channel join -b $CHANNEL_NAME.block to join your channel. (Am I being redundant? Am I repeating myself? Am I saying the same thing over and over again?) Your output should look similar to this: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer channel join -b $CHANNEL_NAME.block 2019-04-28 19:19:51.856 UTC [channelCmd] InitCmdFactory - INFO 001 Endorser and orderer connections initialized 2019-04-28 19:19:51.953 UTC [channelCmd] executeJoin - INFO 002 Successfully submitted proposal to join channel root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 6.16: Repeat the peer channel list command and now you should see your channel listed in the output: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer channel list 2019-04-28 19:20:20.791 UTC [channelCmd] InitCmdFactory - INFO 001 Endorser and orderer connections initialized Channels peers has joined: mychannel root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer#s has joined: mychannel","title":"Section 6 - Instruct each peer node to join the channel"},{"location":"hlf-part1/#section-7-define-an-anchor-peer-for-each-organization-in-the-channel","text":"An anchor peer for an organization is a peer that can be known by all the other organizations in a channel. Not all peers for an organization need to be defined as anchor peers. Peers from other organizations will reach out to anchor peers which can then make information about the other peers available. In a production environment, an organization will typically define more than one peer as an anchor peer for availability and resilience. In our lab, we will just define one of the two peers for each organization as an anchor peer. The definition of an anchor peer took place back in section 4 when you ran the generateArtifacts.sh script. Two of the output files from that step were Org0MSPanchors.tx and Org1MSPanchors.tx. These are input files to define the anchor peers for Org0MSP and Org1MSP respectively. After the channel is created, each organization needs to run this command. You will do that now- this process is a little bit confusing in that the command to do this starts with peer channel create ... but the command will actually update the existing channel with the information about the desired anchor peer. Think of peer channel create here as meaning, \"create an update transaction for a channel\". Step 7.1: Switch to peer0 for Org0MSP : root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# source scripts/setpeer 0 0 # to switch to Peer 0 for Org0MSP CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.key CORE_PEER_LOCALMSPID=Org0MSP CORE_PEER_TLS_ENABLED=true CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.crt CORE_PEER_ID=cli CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/users/Admin@unitedmarbles.com/msp CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/ca.crt CORE_PEER_ADDRESS=peer0.unitedmarbles.com:7051 CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 7.2: Issue this command to create the anchor peer for Org0MSP : root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer channel create -o orderer.blockchain.com:7050 -f channel-artifacts/Org0MSPanchors.tx $FABRIC_TLS -c $CHANNEL_NAME 2019-04-28 19:23:09.479 UTC [channelCmd] InitCmdFactory - INFO 001 Endorser and orderer connections initialized 2019-04-28 19:23:09.495 UTC [cli.common] readBlock - INFO 002 Received block: 0 root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 7.3: Switch to peer0 for Org1MSP : root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# source scripts/setpeer 1 0 CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.key CORE_PEER_LOCALMSPID=Org1MSP CORE_PEER_TLS_ENABLED=true CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.crt CORE_PEER_ID=cli CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/marblesinc.com/users/Admin@marblesinc.com/msp CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/marblesinc.com/peers/peer0.marblesinc.com/tls/ca.crt CORE_PEER_ADDRESS=peer0.marblesinc.com:7051 CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 7.4: Issue this command to create the anchor peer for Org1MSP : root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer channel create -o orderer.blockchain.com:7050 -f channel-artifacts/Org1MSPanchors.tx $FABRIC_TLS -c $CHANNEL_NAME 2019-04-28 19:24:21.903 UTC [channelCmd] InitCmdFactory - INFO 001 Endorser and orderer connections initialized 2019-04-28 19:24:21.914 UTC [cli.common] readBlock - INFO 002 Received block: 0 root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer#","title":"Section 7 - Define an \"anchor\" peer for each organization in the channel"},{"location":"hlf-part1/#section-8-install-the-chaincode-on-the-peer-nodes","text":"Installing chaincode on the peer nodes puts the chaincode binary executable on a peer node. If you want the peer to be an endorser on a channel for a chaincode, then you must install the chaincode on that peer. If you only want the peer to be a committer on a channel for a chaincode, then you do not have to install the chaincode on that peer. In this section, you will install the chaincode on two of your peers. Step 8.1: Switch to peer0 in Org0MSP : root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# source scripts/setpeer 0 0 CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.key CORE_PEER_LOCALMSPID=Org0MSP CORE_PEER_TLS_ENABLED=true CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.crt CORE_PEER_ID=cli CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/users/Admin@unitedmarbles.com/msp CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/ca.crt CORE_PEER_ADDRESS=peer0.unitedmarbles.com:7051 CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 8.2: Try this command to list the chaincodes installed on the peer. It will return an empty list, as you haven't yet installed any chaincode on any of the peers: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode list --installed Get installed chaincodes on peer: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 8.3: Install the marbles chaincode on Peer0 in Org0MSP. You are looking for a message near the end of the output similar to what is shown here: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode install -n marbles -v 1.0 -p github.com/hyperledger/fabric/examples/chaincode/go/marbles 2019-04-28 19:25:59.811 UTC [chaincodeCmd] checkChaincodeCmdParams - INFO 001 Using default escc 2019-04-28 19:25:59.811 UTC [chaincodeCmd] checkChaincodeCmdParams - INFO 002 Using default vscc 2019-04-28 19:26:00.040 UTC [chaincodeCmd] install - INFO 003 Installed remotely response: status:200 payload:\"OK\" root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 8.4: Repeat the command from Step 8.2: - Tip: you could probably use the up arrow key a couple of times to retrieve that command as an alternative to doing a copy-and-paste here, but I'll leave it up to you: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode list --installed Get installed chaincodes on peer: Name: marbles, Version: 1.0, Path: github.com/hyperledger/fabric/examples/chaincode/go/marbles, Id: 19776f7d2a186d5188b748254a5767bd9689f3723672450c3fdd2daa62b4b746 root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Note: I won't have you repeat the \"before\" and \"after\" peer chaincode list --installed commands on any of the other peers on which you install it, but I won't take extraordinary measures to stop you if you insist on doing it. Step 8.5: Switch to peer0 in Org1MSP : root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# source scripts/setpeer 1 0 CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.key CORE_PEER_LOCALMSPID=Org1MSP CORE_PEER_TLS_ENABLED=true CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.crt CORE_PEER_ID=cli CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/marblesinc.com/users/Admin@marblesinc.com/msp CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/marblesinc.com/peers/peer0.marblesinc.com/tls/ca.crt CORE_PEER_ADDRESS=peer0.marblesinc.com:7051 CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 8.6: Install the marbles chaincode on Peer0 in Org1MSP. You are looking for a message near the end of the output similar to what is shown here: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode install -n marbles -v 1.0 -p github.com/hyperledger/fabric/examples/chaincode/go/marbles 2019-04-28 19:27:38.352 UTC [chaincodeCmd] checkChaincodeCmdParams - INFO 001 Using default escc 2019-04-28 19:27:38.352 UTC [chaincodeCmd] checkChaincodeCmdParams - INFO 002 Using default vscc 2019-04-28 19:27:38.570 UTC [chaincodeCmd] install - INFO 003 Installed remotely response: status:200 payload:\"OK\" root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# An interesting thing to note is that for the peer chaincode install command you did not need to specify the $FABRIC_TLS environment variable. This is because this operation does not cause the peer to communicate with the orderer. Also, you did not need to specify the $CHANNEL_NAME environment variable. This is because the peer chaincode install command only installs the chaincode on the peer node. You only need to do this once per peer. That is, even if you wanted to invoke the same chaincode on multiple channels on a peer, you only install the chaincode once on that peer. Installing chaincode on a peer is a necessary step, but not the only step needed, in order to execute chaincode on that peer. The chaincode must also be instantiated on a channel that the peer participates in. You will do that in the next section.","title":"Section 8 - Install the chaincode on the peer nodes"},{"location":"hlf-part1/#section-9-instantiate-the-chaincode-on-the-channel","text":"In the previous section, you installed chaincode on two of your four peers. Chaincode installation is a peer-level operation. Chaincode instantiation, however, is a channel-level operation. It only needs to be performed once on the channel, no matter how many peers have joined the channel. I'll try to prove it to you in this section. Chaincode instantiation causes a transaction to occur on the channel, so even if a peer on the channel does not have the chaincode installed, it will be made aware of the instantiate transaction, and thus be aware that the chaincode exists and be able to commit transactions from the chaincode to the ledger- it just would not be able to endorse a transaction on the chaincode. Step 9.1: You want to stay signed in to the cli Docker container; however, you will also want to issue some Docker commands from your Linux on IBM Z host, so at this time open up a second terminal session and sign in to your Linux on IBM Z host. For the remainder of this lab, I will refer to the session where you are in the cli Docker container as Terminal Session 1 , and this new session where you are at the Linux on IBM Z host as Terminal Session 2 . If you are running this lab from a Windows laptop you probably are using PuTTY. If you are running this lab from Linux or MacOS you are probably using terminal sessions and using ssh . Step 9.2: You are going to confirm that you do not have any chaincode Docker images created, nor any Docker chaincode containers running currently. From Terminal Session 2, enter this command and observe that all of your images begin with hyperledger : bcuser@ubuntu18042:~$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE hyperledger/fabric-ca 1.4.1 a836041637e8 2 weeks ago 220MB hyperledger/fabric-tools 1.4.1 330902566372 2 weeks ago 1.52GB hyperledger/fabric-orderer 1.4.1 1b709e319b2d 2 weeks ago 148MB hyperledger/fabric-peer 1.4.1 719392658c28 2 weeks ago 154MB hyperledger/fabric-couchdb s390x-0.4.15 81ee917e0be2 5 weeks ago 1.55GB bcuser@ubuntu18042:~$ You should not have any images which begin with dev- , which is what your Docker chaincode images will start with, and at this point in the lab Docker chaincode images have not been created yet. Step 9.3: Now do essentially the same thing with docker ps and you should see all of the Docker containers for the Hyperledger Fabric processes and CouchDB, but no chaincode-related Docker containers: bcuser@ubuntu18042:~$ docker ps --all CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 84b6c0ee74aa hyperledger/fabric-tools:1.4.1 \"bash\" 23 minutes ago Up 23 minutes cli e6eabd9fd96d hyperledger/fabric-peer:1.4.1 \"peer node start\" 23 minutes ago Up 23 minutes 0.0.0.0:9051- 7051/tcp, 0.0.0.0:9052- 7052/tcp, 0.0.0.0:9053- 7053/tcp peer0.marblesinc.com 8174f3021744 hyperledger/fabric-peer:1.4.1 \"peer node start\" 23 minutes ago Up 23 minutes 0.0.0.0:8051- 7051/tcp, 0.0.0.0:8052- 7052/tcp, 0.0.0.0:8053- 7053/tcp peer1.unitedmarbles.com 1a22b9eb5be5 hyperledger/fabric-peer:1.4.1 \"peer node start\" 23 minutes ago Up 23 minutes 0.0.0.0:10051- 7051/tcp, 0.0.0.0:10052- 7052/tcp, 0.0.0.0:10053- 7053/tcp peer1.marblesinc.com 11423ca89763 hyperledger/fabric-peer:1.4.1 \"peer node start\" 23 minutes ago Up 23 minutes 0.0.0.0:7051-7053- 7051-7053/tcp peer0.unitedmarbles.com 18b9e5efbfc9 hyperledger/fabric-couchdb:s390x-0.4.15 \"tini -- /docker-ent\u2026\" 23 minutes ago Up 23 minutes 4369/tcp, 9100/tcp, 0.0.0.0:6984- 5984/tcp couchdb1 77288f8c0060 hyperledger/fabric-couchdb:s390x-0.4.15 \"tini -- /docker-ent\u2026\" 23 minutes ago Up 23 minutes 4369/tcp, 9100/tcp, 0.0.0.0:7984- 5984/tcp couchdb2 43214da184da hyperledger/fabric-ca:1.4.1 \"sh -c 'fabric-ca-se\u2026\" 23 minutes ago Up 23 minutes 0.0.0.0:7054- 7054/tcp ca_Org0 1ea639c77a3a hyperledger/fabric-ca:1.4.1 \"sh -c 'fabric-ca-se\u2026\" 23 minutes ago Up 23 minutes 0.0.0.0:8054- 7054/tcp ca_Org1 07df27e35368 hyperledger/fabric-couchdb:s390x-0.4.15 \"tini -- /docker-ent\u2026\" 23 minutes ago Up 23 minutes 4369/tcp, 9100/tcp, 0.0.0.0:8984- 5984/tcp couchdb3 93e0465394b6 hyperledger/fabric-orderer:1.4.1 \"orderer\" 23 minutes ago Up 23 minutes 0.0.0.0:7050- 7050/tcp orderer.blockchain.com 4201915cc3b2 hyperledger/fabric-couchdb:s390x-0.4.15 \"tini -- /docker-ent\u2026\" 23 minutes ago Up 23 minutes 4369/tcp, 9100/tcp, 0.0.0.0:5984- 5984/tcp couchdb0 bcuser@ubuntu18042:~$ Step 9.4: Entering this will make this fact stand out more as you should only see column headers in your output. (The --invert-match argument for grep says \"do not show me anything that contains the string \"hyperledger\"): bcuser@ubuntu18042:~$ docker ps --all | grep --invert-match hyperledger CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES bcuser@ubuntu18042:~$ Now that you have established that you have no chaincode-related Docker images or containers present, try to instantiate the chaincode. Step 9.5: On Terminal Session 1, switch to Peer 0 of Org0MSP by entering: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# source scripts/setpeer 0 0 CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.key CORE_PEER_LOCALMSPID=Org0MSP CORE_PEER_TLS_ENABLED=true CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.crt CORE_PEER_ID=cli CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/users/Admin@unitedmarbles.com/msp CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/ca.crt CORE_PEER_ADDRESS=peer0.unitedmarbles.com:7051 CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 9.6: On Terminal Session 1, enter this command to list instantiated chaincodes on your channel. Spoiler alert- there aren't any, so you will get an empty list: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode list --instantiated --channelID ${CHANNEL_NAME} Get instantiated chaincodes on channel mychannel: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 9.7: On Terminal Session 1, issue the command to instantiate the chaincode on the channel: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode instantiate -o orderer.blockchain.com:7050 -n marbles -v 1.0 -c '{\"Args\":[\"init\",\"1\"]}' -P \"OR ('Org0MSP.member','Org1MSP.member')\" $FABRIC_TLS -C $CHANNEL_NAME 2019-04-28 19:32:27.208 UTC [chaincodeCmd] checkChaincodeCmdParams - INFO 001 Using default escc 2019-04-28 19:32:27.208 UTC [chaincodeCmd] checkChaincodeCmdParams - INFO 002 Using default vscc root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Note In your prior commands, when specifying the channel name, you used lowercase 'c' as the argument, e.g., -c $CHANNEL_NAME . In the peer chaincode instantiate command however, you use an uppercase 'C' as the argument to specify the channel name, e.g., -C mychannel , because -c is used to specify the arguments given to the chaincode. Why c for arguments you may ask? Well, the ' c ' is short for ' ctor ', which itself is an abbreviation for constructor , which is a fancy word object-oriented programmers use to refer to the initial arguments given when creating an object. Step 9.8: You may have noticed a longer than usual pause before you got your command prompt back while that last command was being run. The reason for this is that as part of the instantiate, a Docker image for the chaincode is created and then a Docker container is started from the image. To prove this to yourself, on Terminal Session 2, enter this to see the new Docker image: bcuser@ubuntu18042:~$ docker images dev-* REPOSITORY TAG IMAGE ID CREATED SIZE dev-peer0.unitedmarbles.com-marbles-1.0-7e92f069adb7469939a96dcba723fa2019745461f05a562e81cec38e46424aa1 latest d41acea306aa About a minute ago 137MB bcuser@ubuntu18042:~$ Step 9.9: And enter this to see the Docker chaincode container created from the new Docker image: bcuser@ubuntu18042:~$ docker ps | grep --invert-match hyperledger CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 62a185d148d2 dev-peer0.unitedmarbles.com-marbles-1.0-7e92f069adb7469939a96dcba723fa2019745461f05a562e81cec38e46424aa1 \"chaincode -peer.add\u2026\" About a minute ago Up About a minute dev-peer0.unitedmarbles.com-marbles-1.0 bcuser@ubuntu18042:~$ The naming convention used by Hyperledger Fabric v1.4.1 for the Docker images it creates for chaincode is HyperledgerFabricNetworkName-PeerName-ChaincodeName-ChaincodeVersion-SHA256Hash . In our case of dev-peer0.unitedmarbles.com-marbles-1.0- , the default name of a Hyperledger Fabric network is dev , and you did not change it. peer0.unitedmarbles.com is the peer name of peer0 of Org0MSP, and you specified this via the CORE_PEER_ID environment variable in the Docker Compose YAML file. marbles is the name you gave this chaincode in the -n argument of the peer chaincode install command, and 1.0 is the version of the chaincode you used in the -v argument of the peer chaincode install command. Note that a chaincode Docker container was only created for the peer on which you entered the peer chaincode instantiate command. Docker containers will not be created on the other peers until you run a peer chaincode invoke or peer chaincode query command on that peer. Step 9.10: In Terminal Session 1 repeat the command from Step 9.6 to see that your instantiated chaincode on your channel is now listed: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode list --instantiated --channelID ${CHANNEL_NAME} Get instantiated chaincodes on channel mychannel: Name: marbles, Version: 1.0, Path: github.com/hyperledger/fabric/examples/chaincode/go/marbles, Escc: escc, Vscc: vscc root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 9.11: Remember when I said at the beginning of this section that I would try to prove it to you that you only need to do the instantiate once on a channel, and not on every peer in the channel? Let's find out if I'm lying. You did the instantiate on peer \"0 0\". Switch to another peer: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# source scripts/setpeer 1 1 CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.key CORE_PEER_LOCALMSPID=Org1MSP CORE_PEER_TLS_ENABLED=true CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.crt CORE_PEER_ID=cli CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/marblesinc.com/users/Admin@marblesinc.com/msp CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/marblesinc.com/peers/peer1.marblesinc.com/tls/ca.crt CORE_PEER_ADDRESS=peer1.marblesinc.com:7051 CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 9.12: Repeat the command from Step 9.10 on this peer, and even though you did not run the peer chaincode instantiate on this peer, you will see that this peer is aware of the instantiation: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode list --instantiated --channelID ${CHANNEL_NAME} Get instantiated chaincodes on channel mychannel: Name: marbles, Version: 1.0, Escc: escc, Vscc: vscc root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# I would never lie to you.","title":"Section 9 - Instantiate the chaincode on the channel"},{"location":"hlf-part1/#section-10-invoke-chaincode-functions","text":"You are now ready to invoke chaincode functions that will create, read, update and delete data in the ledger. In this section, you will enter scripts/setpeer and peer chaincode commands in Terminal session 1, while you will enter docker ps and docker images commands in Terminal session 2. Step 10.1: Switch to peer0 of Org0MSP: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# source scripts/setpeer 0 0 CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.key CORE_PEER_LOCALMSPID=Org0MSP CORE_PEER_TLS_ENABLED=true CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.crt CORE_PEER_ID=cli CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/users/Admin@unitedmarbles.com/msp CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/ca.crt CORE_PEER_ADDRESS=peer0.unitedmarbles.com:7051 CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 10.2: You will use the marbles chaincode to create a new Marbles owner named John. If you would like to use a different name than John, that is fine but then there will be other places later where you would need to use your \"custom\" name instead of John. And John's the guy who first got this lab working about three years ago so I think he deserves a marble, don't you, so if you do want to show off and change the name then I'm going to let you figure out later where it might need to be changed. Enter this command in Terminal session 1: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode invoke -n marbles -c '{\"Args\":[\"init_owner\", \"o0000000000001\",\"John\",\"Marbles Inc\"]}' $FABRIC_TLS -C $CHANNEL_NAME 2019-04-28 19:37:38.570 UTC [chaincodeCmd] InitCmdFactory - INFO 001 Retrieved channel (mychannel) orderer endpoint: orderer.blockchain.com:7050 2019-04-28 19:37:38.585 UTC [chaincodeCmd] chaincodeInvokeOrQuery - INFO 002 Chaincode invoke successful. result: status:200 root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 10.3: Let's deconstruct the arguments to the chaincode: {\u201cArgs\u201d:[\u201cinit_owner\u201d, \u201co0000000000001\u201d, \u201cJohn\u201d, \u201cMarbles Inc\u201d]} This is in JSON format. JSON stands for JavaScript Object Notation, and is a very popular format for transmitting data in many languages, not just with JavaScript. What is shown above is a single name/value pair. The name is Args and the value is an array of four arguments. (The square brackets \"[\" and \"]\" specify an array in JSON). Note In the formal JSON definition the term ' name/value ' is used, but many programmers will also use the term ' key/value ' instead. You can consider these two terms as synonymous. (Many people use the phrase \"the same\" instead of the word \"synonymous\"). The Args name specifies the arguments passed to the chaincode invocation. There is an interface layer, also called a \"shim\", that gains control before passing it along to user-written chaincode functions- it expects this Args name/value pair. The shim also expects the first array value to be the name of the user-written chaincode function that it will pass control to, and then all remaining array values are the arguments to pass, in order, to that user-written chaincode function. So, in the command you just entered, the init_owner function is called, and it is passed three arguments, o0000000000001 , John , and Marbles Inc . It is logic within the init_owner function that cause updates to the channel's ledger- subject to the transaction flow in Hyperledger Fabric v1.4.1- that is, chaincode execution causes proposed updates to the ledger, which are only committed at the end of the transaction flow if everything is validated properly. But it all starts with function calls inside the chaincode functions that ask for ledger state to be created or updated. Step 10.4: Go to Terminal session 2, and enter this Docker command and you will observe that you still only have a Docker image and a Docker container for peer0 of Org0MSP: bcuser@ubuntu18042:~$ docker images dev-* REPOSITORY TAG IMAGE ID CREATED SIZE dev-peer0.unitedmarbles.com-marbles-1.0-7e92f069adb7469939a96dcba723fa2019745461f05a562e81cec38e46424aa1 latest d41acea306aa 5 minutes ago 137MB bcuser@ubuntu18042:~$ Step 10.5: Enter this command to see information about the chaincode container. I introduce here the --no-trunc option, which stands for no truncation , so you can see more information about the container: bcuser@ubuntu18042:~$ docker ps --no-trunc | grep dev- 62a185d148d2a0ead43120ca50e3ed459a2a005b08b10ece0c4ae205bf1f016a dev-peer0.unitedmarbles.com-marbles-1.0-7e92f069adb7469939a96dcba723fa2019745461f05a562e81cec38e46424aa1 \"chaincode -peer.address=peer0.unitedmarbles.com:7052\" 6 minutes ago Up 6 minutes dev-peer0.unitedmarbles.com-marbles-1.0 bcuser@ubuntu18042:~$ The takeaway is that the chaincode execution has only run on peer0 of Org0MSP so far, and this is also the peer on which you instantiated the chaincode, so the Docker image for the chaincode, and the corresponding Docker container based on the image, have been created for only this peer. You will see soon that other peers will have their own chaincode Docker image and Docker container built the first time they are needed. Step 10.6: You created a marble owner in the previous step. Now create a marble belonging to this owner. Perform this from peer0 of Org1, so from Terminal session 1, switch to Peer0 of Org1MSP: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# source scripts/setpeer 1 0 CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.key CORE_PEER_LOCALMSPID=Org1MSP CORE_PEER_TLS_ENABLED=true CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.crt CORE_PEER_ID=cli CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/marblesinc.com/users/Admin@marblesinc.com/msp CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/marblesinc.com/peers/peer0.marblesinc.com/tls/ca.crt CORE_PEER_ADDRESS=peer0.marblesinc.com:7051 CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 10.7: Now enter the command to create a new marble for John: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode invoke -n marbles -c '{\"Args\":[\"init_marble\",\"m0000000000001\",\"blue\",\"35\",\"o0000000000001\",\"Marbles Inc\"]}' $FABRIC_TLS -C $CHANNEL_NAME 2019-04-28 19:40:11.744 UTC [chaincodeCmd] InitCmdFactory - INFO 001 Retrieved channel (mychannel) orderer endpoint: orderer.blockchain.com:7050 2019-04-28 19:40:29.338 UTC [chaincodeCmd] chaincodeInvokeOrQuery - INFO 002 Chaincode invoke successful. result: status:200 root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# This time you called the init_marble function. Now you have created one owner, and one marble. The owner is John (or your custom name) and his id is o0000000000001 , and his marble has an id of m0000000000001 . I cleverly decided that the letter ' o ' stands for owner and the letter ' m ' stands for marbles. I put 12 leading zeros in front of the number 1 in case you wanted to stay late and create trillions of marbles and owners. Step 10.8: In Terminal session 2, issue the command to see that you have two Docker chaincode images: bcuser@ubuntu18042:~$ docker images dev-* REPOSITORY TAG IMAGE ID CREATED SIZE dev-peer0.marblesinc.com-marbles-1.0-4077677f13838bacbfd8ff943e7348c00f3c4d6ca6e2838efd14204ca87ea12b latest ab7f5fa821ee 36 seconds ago 137MB dev-peer0.unitedmarbles.com-marbles-1.0-7e92f069adb7469939a96dcba723fa2019745461f05a562e81cec38e46424aa1 latest d41acea306aa 8 minutes ago 137MB bcuser@ubuntu18042:~$ Step 10.9: In Terminal session 2, issue the command to see that you have two Docker chaincode containers: bcuser@ubuntu18042:~$ docker ps --no-trunc | grep dev-* a7d6b658a35a5f7f82d489f6f797a0463739cb7297cc083875cd6e232600a061 dev-peer0.marblesinc.com-marbles-1.0-4077677f13838bacbfd8ff943e7348c00f3c4d6ca6e2838efd14204ca87ea12b \"chaincode -peer.address=peer0.marblesinc.com:7052\" About a minute ago Up About a minute dev-peer0.marblesinc.com-marbles-1.0 62a185d148d2a0ead43120ca50e3ed459a2a005b08b10ece0c4ae205bf1f016a dev-peer0.unitedmarbles.com-marbles-1.0-7e92f069adb7469939a96dcba723fa2019745461f05a562e81cec38e46424aa1 \"chaincode -peer.address=peer0.unitedmarbles.com:7052\" 8 minutes ago Up 8 minutes dev-peer0.unitedmarbles.com-marbles-1.0 bcuser@ubuntu18042:~$ Step 10.10: You will create a new owner now. From Terminal Session 1, try it on Peer 1 of Org0MSP: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# source scripts/setpeer 0 1 CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.key CORE_PEER_LOCALMSPID=Org0MSP CORE_PEER_TLS_ENABLED=true CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/server.crt CORE_PEER_ID=cli CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/users/Admin@unitedmarbles.com/msp CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/unitedmarbles.com/peers/peer1.unitedmarbles.com/tls/ca.crt CORE_PEER_ADDRESS=peer1.unitedmarbles.com:7051 CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 10.11: Note The command in this step is intended to fail. Go ahead and enter it and then read on for why it failed and how to correct the failure Run this commnand to try to create a new owner: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode invoke -n marbles -c '{\"Args\":[\"init_owner\",\"o0000000000002\",\"Barry\",\"United Marbles\"]}' $FABRIC_TLS -C $CHANNEL_NAME 2019-04-28 19:43:18.425 UTC [chaincodeCmd] InitCmdFactory - INFO 001 Retrieved channel (mychannel) orderer endpoint: orderer.blockchain.com:7050 Error: endorsement failure during invoke. response: status:500 message:\"cannot retrieve package for chaincode marbles/1.0, error open /var/hyperledger/production/chaincodes/marbles.1.0: no such file or directory\" root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# What do you expect to happen when you enter this command? If you have followed these instructions exactly so far, the invoke will fail. It will fail because you have not yet installed the chaincode on Peer 1 of Org0. Here is the output which shows the error: 2019-04-28 19:43:18.425 UTC [chaincodeCmd] InitCmdFactory - INFO 001 Retrieved channel (mychannel) orderer endpoint: orderer.blockchain.com:7050 Error: endorsement failure during invoke. response: status:500 message:\"cannot retrieve package for chaincode marbles/1.0, error open /var/hyperledger/production/chaincodes/marbles.1.0: no such file or directory\" You must first install chaincode on a peer not only before you can do an instantiate from that peer, but also before you can do an invoke or query from that peer. If you want a peer to perform the endorsing function for a transaction, the chaincode for that transaction must be installed on that peer. If that peer is a member of the channel on which the chaincode is instantiated, but has not had the chaincode installed on it, it will still perform the committer function and update its copy of the channel's ledger when it receives valid transactions from the orderer, but it cannot endorse transaction proposals unless the chaincode has been installed on it. Step 10.12 : Correct things by installing the chaincode on peer1 of Org0. In Terminal session 1, enter this command, which should look familiar to you: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode install -n marbles -v1.0 -p github.com/hyperledger/fabric/examples/chaincode/go/marbles 2019-04-28 19:44:56.984 UTC [chaincodeCmd] checkChaincodeCmdParams - INFO 001 Using default escc 2019-04-28 19:44:56.984 UTC [chaincodeCmd] checkChaincodeCmdParams - INFO 002 Using default vscc 2019-04-28 19:44:57.189 UTC [chaincodeCmd] install - INFO 003 Installed remotely response: status:200 payload:\"OK\" root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 10.13: Now, in Terminal session 1, repeat the peer chaincode invoke command from Step 10.9 . It should work this time: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode invoke -n marbles -c '{\"Args\":[\"init_owner\",\"o0000000000002\",\"Barry\",\"United Marbles\"]}' $FABRIC_TLS -C $CHANNEL_NAME 2019-04-28 19:45:34.761 UTC [chaincodeCmd] InitCmdFactory - INFO 001 Retrieved channel (mychannel) orderer endpoint: orderer.blockchain.com:7050 2019-04-28 19:45:51.745 UTC [chaincodeCmd] chaincodeInvokeOrQuery - INFO 002 Chaincode invoke successful. result: status:200 root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# Step 10.14: Go back to Terminal session 2 and enter the Docker command that will show you that you now have your third chaincode-related Docker image, the one just built for peer1 of Org0: bcuser@ubuntu18042:~$ docker images dev-* REPOSITORY TAG IMAGE ID CREATED SIZE dev-peer1.unitedmarbles.com-marbles-1.0-dea1aa08dc7c6f282a31dd498670173c21d3e75ef0ef1d170b95e1212fbacb77 latest c0e41de218a2 30 seconds ago 137MB dev-peer0.marblesinc.com-marbles-1.0-4077677f13838bacbfd8ff943e7348c00f3c4d6ca6e2838efd14204ca87ea12b latest ab7f5fa821ee 5 minutes ago 137MB dev-peer0.unitedmarbles.com-marbles-1.0-7e92f069adb7469939a96dcba723fa2019745461f05a562e81cec38e46424aa1 latest d41acea306aa 13 minutes ago 137MB bcuser@ubuntu18042:~$ Step 10.15: Enter the Docker command that will show you that you now have your third chaincode-related Docker container, the one just built for peer1 of Org0: bcuser@ubuntu18042:~$ docker ps --no-trunc | grep dev- 1e5c05183d6f77f4ca1264bd26b996189c5665031ad007d3cdfa28fb5c1a81f9 dev-peer1.unitedmarbles.com-marbles-1.0-dea1aa08dc7c6f282a31dd498670173c21d3e75ef0ef1d170b95e1212fbacb77 \"chaincode -peer.address=peer1.unitedmarbles.com:7052\" 59 seconds ago Up 57 seconds dev-peer1.unitedmarbles.com-marbles-1.0 a7d6b658a35a5f7f82d489f6f797a0463739cb7297cc083875cd6e232600a061 dev-peer0.marblesinc.com-marbles-1.0-4077677f13838bacbfd8ff943e7348c00f3c4d6ca6e2838efd14204ca87ea12b \"chaincode -peer.address=peer0.marblesinc.com:7052\" 6 minutes ago Up 6 minutes dev-peer0.marblesinc.com-marbles-1.0 62a185d148d2a0ead43120ca50e3ed459a2a005b08b10ece0c4ae205bf1f016a dev-peer0.unitedmarbles.com-marbles-1.0-7e92f069adb7469939a96dcba723fa2019745461f05a562e81cec38e46424aa1 \"chaincode -peer.address=peer0.unitedmarbles.com:7052\" 14 minutes ago Up 14 minutes dev-peer0.unitedmarbles.com-marbles-1.0 bcuser@ubuntu18042:~$ Step 10.16: Try some additional chaincode invocations. You have had enough experience switching between peers with source scripts/setpeer and issuing the peer chaincode invoke command that I will not show the output, nor tell you from which peer you should enter your command. I will just list several more commands you can run against the marbles chaincode. Feel free to switch amongst the four peers as you see fit before you enter each command. Note however, that you have only installed the chaincode on three of the four peers, so if you choose that fourth peer, you will need to install the chaincode there first. I won't tell you which peer does not currently have the chaincode installed, but if you need a hint, it is the one that does not have a Docker image built yet for its chaincode. (Note that checking for the absence of a Docker image for a peer is not, by itself,proof that you have not installed the chaincode on that peer- the Docker image is not built until you first invoke a function against the chaincode on that peer). If you are ambitious and want to install the chaincode on that fourth peer, try the useful Docker commands I have shown you from Terminal Session 2 to see that the chaincode's Docker image and Docker container are created when you invoke a transaction on that fourth peer. Try some or all of these commands from Terminal session 1: Create a marble for Barry, i.e., owner o0000000000002: peer chaincode invoke -n marbles -c '{\"Args\":[\"init_marble\",\"m0000000000002\",\"green\",\"50\",\"o0000000000002\",\"United Marbles\"]}' $FABRIC_TLS -C $CHANNEL_NAME Obtain all marble information- marbles and owners: peer chaincode invoke -n marbles -c '{\"Args\":[\"read_everything\"]}' $FABRIC_TLS -C $CHANNEL_NAME Change marble ownership- 'Barry' is giving his marble to 'John': peer chaincode invoke -n marbles -c '{\"Args\":[\"set_owner\",\"m0000000000002\",\"o0000000000001\",\"United Marbles\"]}' $FABRIC_TLS -C $CHANNEL_NAME Get the history of marble 'm0000000000002': peer chaincode invoke -n marbles -c '{\"Args\":[\"getHistory\",\"m0000000000002\"]}' $FABRIC_TLS -C $CHANNEL_NAME Delete marble 'm0000000000002': peer chaincode invoke -n marbles -c '{\"Args\":[\"delete_marble\",\"m0000000000002\",\"Marbles Inc\"]}' $FABRIC_TLS -C $CHANNEL_NAME Try again to get the history of marble 'm0000000000002' after you just deleted it: peer chaincode invoke -n marbles -c '{\"Args\":[\"getHistory\",\"m0000000000002\"]}' $FABRIC_TLS -C $CHANNEL_NAME Obtain all marble information again. See if it matches your expectations based on the commands you have entered: peer chaincode invoke -n marbles -c '{\"Args\":[\"read_everything\"]}' $FABRIC_TLS -C $CHANNEL_NAME Step 10.17: Exit the cli Docker container from Terminal session 1. Your command prompt should change to reflect that you are now back at your Linux on IBM Z host prompt and no longer in the Docker container: root@84b6c0ee74aa:/opt/gopath/src/github.com/hyperledger/fabric/peer# exit exit bcuser@ubuntu18042:~/zmarbles$ Step 10.18: Congratulations for making it through the treacherous portion of the lab! Stay logged in to your two terminal sessions and leave your Hyperledger Fabric network and all the chaincode Docker containers up and running- you will use what you created here in Part 2 of the lab where you will install a front-end application offering a browser-based UI from which you will interact with the marbles chaincode that you have installed in here in Part 1. Continue to Part 2 of the lab now.","title":"Section 10 - Invoke chaincode functions"},{"location":"hlf-part2/","text":"Section 1: Lab Part 2 Overview In this part of the lab, you will use the Hyperledger Fabric network that you created in the Part 1 of the lab and configure the Marbles User Interface (UI) web application so that it will integrate with the marbles chaincode that you installed in the previous lab. You will use two browser sessions to simulate acting as a user for each of the two organizations in the network- United Marbles and Marbles Inc . Then you can explore the Marbles UI to execute chaincode transactions and see some of the Hyperledger Fabric concepts in action. Section 2: Marbles user interface setup Step 2.1: Switch to the ~/zmarbles/marblesUI directory: bcuser@ubuntu18042:~/zmarbles$ cd ~/zmarbles/marblesUI bcuser@ubuntu18042:~/zmarbles/marblesUI$ Step 2.2: You will need to do an npm install to install the packages needed by the Marbles user interface. First you will verify that the node_modules directory does not exist. This directory will be created when you run an npm install in the next step, so right now it shouldn't exist: bcuser@ubuntu18042:~/zmarbles/marblesUI$ ls -l node_modules ls: cannot access 'node_modules': No such file or directory bcuser@ubuntu18042:~/zmarbles/marblesUI$ Step 2.3: Now run the npm install : bcuser@ubuntu18042:~/zmarbles/marblesUI$ npm install . . (output not shown here) . Step 2.4: When this command ends, list the node_modules directory again. It is there now: bcuser@ubuntu18042:~/zmarbles/marblesUI$ ls -l node_modules . . (output not shown here) . bcuser@ubuntu18042:~/zmarbles/marblesUI$ Step 2.5: Change to the config directory: bcuser@ubuntu18042:~/zmarbles/marblesUI$ cd config bcuser@ubuntu18042:~/zmarbles/marblesUI/config$ Step 2.6: There are four files in this directory: bcuser@ubuntu18042:~/zmarbles/marblesUI/config$ ls connection_profile1.json connection_profile2.json marbles1.json marbles2.json bcuser@ubuntu18042:~/zmarbles/marblesUI/config$ Step 2.7: There are two files for the first fictitious company, United Marbles , and two files for the second fictitious company, Marbles Inc. Look at the marbles1.json file with the cat command: bcuser@ubuntu18042:~/zmarbles/marblesUI/config$ cat marbles1.json { \"cred_filename\": \"connection_profile1.json\", \"use_events\": false, \"keep_alive_secs\": 120, \"company\": \"United Marbles\", \"usernames\": [ \"amy\", \"alice\", \"ava\" ], \"port\": 3001, \"last_startup_hash\": \"\" } bcuser@ubuntu18042:~/zmarbles/marblesUI/config$ Step 2.8: Notice that this file points to one of the other existing files, connection_profile1.json , as the value of the cred_filename name/value pair. You will look at that in a moment. Take a note of the usernames array- amy , alice , and ava . If you are comfortable with the vi editor you could change those names to your favorite names if you would like. You can also use the sed command to change the name inline without entering vi . Here is an example of a command to change the name alice to vincent . This step is optional- you do not have to do this is you prefer the name alice to vincent : bcuser@ubuntu18042:~/zmarbles/marblesUI/config$ sed -i \"s/alice/vincent/\" marbles1.json # optional bcuser@ubuntu18042:~/zmarbles/marblesUI/config$ Step 2.9: Here is the file after I changed alice to vincent with the previous sed command: bcuser@ubuntu18042:~/zmarbles/marblesUI/config$ cat marbles1.json { \"cred_filename\": \"connection_profile1.json\", \"use_events\": false, \"keep_alive_secs\": 120, \"company\": \"United Marbles\", \"usernames\": [ \"amy\", \"vincent\", \"ava\" ], \"port\": 3001, \"last_startup_hash\": \"\" } bcuser@ubuntu18042:~/zmarbles/marblesUI/config$ NOTE: Your file will look different if you choose to skip the optional Step 2.9 or if you made changes other than the example change I showed. The purpose of this step is to ensure that your file changed the way you intended it to (if it changed at all). The other key thing to note is the port number. It is 3001 here. In the marbles2.json file for Marbles Inc , port 3002 will be specified. This is how, later in this lab, you will pretend to be a user of one company or the other- by using port 3001 in the URL to pretend to be a \"United Marbles\" user and by using port 3002 in the URL to pretend to be a \"Marbles Inc\" user. Step 2.10: It is time to look at the main configuration file the Marbles app uses. It is the file specified as the cred_filename value in the marbles1.json file. This name cred_filename for the JSON name/value pair and the filename, blockchain_creds1.json , indicate that security credentials are specified in this file, and they are, but actually information about the Hyperledger Fabric network itself is specified in this file as well. This file is too large to fit in one screen, so I will teach you one more Linux command, named more . (Pun intended). Type this: bcuser@ubuntu18042:~/zmarbles/marblesUI/config$ more connection_profile1.json . . (output not shown) . bcuser@ubuntu18042:~/zmarbles/marblesUI/config$ This command will print as much of the file as it can on your screen but will pause until you hit the space bar before displaying the rest of the file's contents. Here are the complete contents of this file: { \"name\": \"Docker Compose Network\", \"x-networkId\": \"not-important\", \"x-type\": \"hlfv1\", \"description\": \"Connection Profile for an IBM Blockchain Network\", \"version\": \"1.0.0\", \"client\": { \"organization\": \"Org0MSP\" }, \"channels\": { \"mychannel\": { \"orderers\": [ \"fabric-orderer\" ], \"peers\": { \"fabric-peer-org1\" : { \"x-chaincode\": {} } }, \"chaincodes\": [ \"marbles:v4\" ], \"x-blockDelay\": 1000 } }, \"organizations\": { \"Org0MSP\": { \"mspid\": \"Org0MSP\", \"peers\": [ \"fabric-peer-org1\" ], \"certificateAuthorities\": [ \"fabric-ca-org1\" ] } }, \"orderers\": { \"fabric-orderer\": { \"url\": \"grpcs://localhost:7050\", \"grpcOptions\": { \"ssl-target-name-override\": \"orderer.blockchain.com\", \"grpc.http2.keepalive_time\": 300, \"grpc.keepalive_time_ms\": 300000, \"grpc.http2.keepalive_timeout\": 35, \"grpc.keepalive_timeout_ms\": 3500 }, \"tlsCACerts\": { \"path\": \"../../crypto-config/ordererOrganizations/blockchain.com/orderers/orderer.blockchain.com/tls/ca.crt\" } } }, \"peers\": { \"fabric-peer-org1\": { \"url\": \"grpcs://localhost:7051\", \"eventUrl\": \"grpcs://localhost:7053\", \"grpcOptions\": { \"ssl-target-name-override\": \"peer0.unitedmarbles.com\", \"grpc.http2.keepalive_time\": 300, \"grpc.keepalive_time_ms\": 300000, \"grpc.http2.keepalive_timeout\": 35, \"grpc.keepalive_timeout_ms\": 3500 }, \"tlsCACerts\": { \"path\": \"../../crypto-config/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/ca.crt\" } } }, \"certificateAuthorities\": { \"fabric-ca-org1\": { \"url\": \"https://localhost:7054\", \"httpOptions\": { \"ssl-target-name-override\": \"ca.unitedmarbles.com\", \"verify\": true }, \"tlsCACerts\": { \"path\": \"../../crypto-config/peerOrganizations/unitedmarbles.com/ca/ca.unitedmarbles.com-cert.pem\" }, \"registrar\": [ { \"enrollId\": \"admin\", \"enrollSecret\": \"adminpw\" } ], \"caName\": \"ca-org0\" } } } This is a standard Hyperledger Fabric connection profile. This lab does not use Hyperledger Composer, but I think the Hyperledger Composer team did a nice job describing Hyperledger Fabric connection profiles, as they use them too. See https://hyperledger.github.io/composer/latest/reference/connectionprofile for their description. They also reference a link in the Hyperledger Fabric Node.js SDK documentation at https://fabric-sdk-node.github.io/tutorial-network-config.html which is a little more advanced, and it describes the profile in YAML form versus the JSON form that this Marbles demo app uses. Important If you used a channel name other than the default of mychannel, you must change this value from mychannel to the value you used. Either use the vi editor if you are comfortable with that, or, you could use sed . For example, below there is a sed command, to change the channel name from mychannel to tim , along with \"before\" and \"after\" grep commands to show the changes (These commands are examples and only needed if you did not use the default channel name of mychannel)** Warning This step is necessary only if you did not use this lab's default channel name of mychannel earlier in Part 1 of this lab. And of course, this example shows the steps for changing the channel name to tim , so tailor the command shown here according to whatever non-default channel name you may have chosen. Warning Unlike most steps in this lab, there are three commands to enter in this step, two greps and a sed (hey, that sounds like a good name for a television show). But, again, and I can't emphasize this enough, don't run the commands in this step if you kept your channel name as the default value of mychannel . bcuser@ubuntu18042:~/zmarbles/marblesUI/config$ grep mychannel connection_profile[12].json blockchain_creds1.json: channel_id : mychannel , blockchain_creds2.json: channel_id : mychannel , bcuser@ubuntu18042:~/zmarbles/marblesUI/config$ sed -i s/mychannel/tim/ connection_profile[12].json bcuser@ubuntu18042:~/zmarbles/marblesUI/config$ grep -1 channels connection_profile[12].json connection_profile1.json- }, connection_profile1.json: channels : { connection_profile1.json- tim : { -- connection_profile2.json- }, connection_profile2.json: channels : { connection_profile2.json- tim : { bcuser@ubuntu18042:~/zmarbles/marblesUI/config$ Step 2.11: The considerations for marbles2.json and connection_profile2.json are the same as for marbles1.json and connection_profile1.json except that they apply to \"Marbles Inc.\" instead of \"United Marbles\". If you would like to compare the differences between connection_profile1.json and connection_profile2.json , try the diff command and observe its output. This command lists sections of the two files that it finds different. The lines from the first file, blockchain_creds1.json , start with ' ' (added by the diff command output, not in the actual file), and the lines from the second file, blockchain_creds2.json , start with '>': bcuser@ubuntu18042:~/zmarbles/marblesUI/config$ diff connection_profile1.json connection_profile2.json 8c8 \"organization\": \"Org0MSP\" --- \"organization\": \"Org1MSP\" 16c16 \"fabric-peer-org1\" : { --- \"fabric-peer-org2\" : { 27,28c27,28 \"Org0MSP\": { \"mspid\": \"Org0MSP\", --- \"Org1MSP\": { \"mspid\": \"Org1MSP\", 30c30 \"fabric-peer-org1\" --- \"fabric-peer-org2\" 33c33 \"fabric-ca-org1\" --- \"fabric-ca-org2\" 54,56c54,56 \"fabric-peer-org1\": { \"url\": \"grpcs://localhost:7051\", \"eventUrl\": \"grpcs://localhost:7053\", --- \"fabric-peer-org2\": { \"url\": \"grpcs://localhost:9051\", \"eventUrl\": \"grpcs://localhost:9053\", 58c58 \"ssl-target-name-override\": \"peer0.unitedmarbles.com\", --- \"ssl-target-name-override\": \"peer0.marblesinc.com\", 65c65 \"path\": \"../../crypto-config/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/ca.crt\" --- \"path\": \"../../crypto-config/peerOrganizations/marblesinc.com/peers/peer0.marblesinc.com/tls/ca.crt\" 70,71c70,71 \"fabric-ca-org1\": { \"url\": \"https://localhost:7054\", --- \"fabric-ca-org2\": { \"url\": \"https://localhost:8054\", 73c73 \"ssl-target-name-override\": \"ca.unitedmarbles.com\", --- \"ssl-target-name-override\": \"ca.marblesinc.com\", 77c77 \"path\": \"../../crypto-config/peerOrganizations/unitedmarbles.com/ca/ca.unitedmarbles.com-cert.pem\" --- \"path\": \"../../crypto-config/peerOrganizations/marblesinc.com/ca/ca.marblesinc.com-cert.pem\" 81,82c81,82 \"enrollId\": \"admin\", \"enrollSecret\": \"adminpw\" --- \"enrollId\": \"admin2\", \"enrollSecret\": \"adminpw2\" 85c85 \"caName\": \"ca-org0\" --- \"caName\": \"ca-org1\" bcuser@ubuntu18042:~/zmarbles/marblesUI/config$ Section 3: Start the Marbles user interface In this section, you will use the Marbles user interface. You will start two browser sessions- one will be as a \"United Marbles\" user, and the other as a \"Marbles Inc\" user. Here in this lab, you are serving both companies' applications from the same server, so you will differentiate between the two companies by the port number. You will connect to port 3001 when acting as a United Marbles user, and you will connect to port 3002 when acting as a Marbles Inc user. In the real world, each of the two companies would probably either serve the user interface from their own server, or perhaps both companies would log in to a server provided by a service provider- think \"Blockchain-as-a-service\". The chosen topology is use-case dependent and beyond the scope of this lab. Step 3.1: You are now ready to start the server for UnitedMarbles. Back up to the ~/zmarbles/marblesUI directory: bcuser@ubuntu18042:~/zmarbles/marblesUI/config$ cd .. bcuser@ubuntu18042:~/zmarbles/marblesUI$ Step 3.2: You will now use gulp to start up the server, with this command: bcuser@ubuntu18042:~/zmarbles/marblesUI$ gulp marbles1 [16:02:03] Using gulpfile ~/zmarbles/marblesUI/gulpfile.js [16:02:03] Starting 'env_tls'... [16:02:03] Finished 'env_tls' after 50 \u03bcs [16:02:03] Starting 'build-sass'... [16:02:03] Finished 'build-sass' after 6.07 ms [16:02:03] Starting 'watch-sass'... [16:02:03] Finished 'watch-sass' after 6.36 ms [16:02:03] Starting 'watch-server'... [16:02:03] Finished 'watch-server' after 1.98 ms [16:02:03] Starting 'server'... info: Checking connection profile is done info: Loaded config file /home/bcuser/zmarbles/marblesUI/config/marbles1.json info: Loaded connection profile file /home/bcuser/zmarbles/marblesUI/config/connection_profile1.json Connection Profile Lib Functions:() getNetworkName() getNetworkCredFileName() buildTlsOpts() getFirstChannelId() getChannelId() loadPem() getMarblesField() getChaincodeId() getChaincodeVersion() getFirstCaName() getCA() getCasUrl() getAllCaUrls() getCaName() getCaTlsCertOpts() getEnrollObj() getFirstPeerName() getPeer() getPeersUrl() getAllPeerUrls() getPeerEventUrl() getPeerTlsCertOpts() getMarbleUsernamesConfig() getCompanyNameFromFile() getMarblesPort() getEventsSetting() getKeepAliveMs() getFirstOrdererName() getOrderer() getOrderersUrl() getOrdererTlsCertOpts() getBlockDelay() getKvsPath() getFirstOrg() getClientsOrgName() getClientOrg() getMarbleUsernames() getOrgsMSPid() getAdminPrivateKeyPEM() getAdminSignedCertPEM() ----------------------------------- Server Up - localhost:3001 ----------------------------------- Welcome aboard: United Marbles Channel: mychannel Org: Org0MSP CA: fabric-ca-org1 Orderer: fabric-orderer Peer: fabric-peer-org1 Chaincode ID: marbles Chaincode Version: v4 ------------------------------------------ Websocket Up ------------------------------------------ debug: loading pem from a path: /home/bcuser/zmarbles/crypto-config/peerOrganizations/unitedmarbles.com/ca/ca.unitedmarbles.com-cert.pem debug: loading pem from a path: /home/bcuser/zmarbles/crypto-config/ordererOrganizations/blockchain.com/orderers/orderer.blockchain.com/tls/ca.crt debug: loading pem from a path: /home/bcuser/zmarbles/crypto-config/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/ca.crt info: [fcw] Going to enroll peer_urls=[grpcs://localhost:7051], channel_id=mychannel, uuid=marblesDockerComposeNetworkmychannelOrg0MSPfabricpeerorg1, ca_url=https://localhost:7054, orderer_url=grpcs://localhost:7050, enroll_id=admin, enroll_secret=adminpw, msp_id=Org0MSP, kvs_path=/home/bcuser/.hfc-key-store/marblesDockerComposeNetworkmychannelOrg0MSPfabricpeerorg1 debug: enroll id: \"admin\", secret: \"adminpw\" debug: msp_id: Org0MSP ca_name: ca-org0 info: [fcw] Successfully enrolled user 'admin' debug: added peer grpcs://localhost:7051 debug: [fcw] Successfully got enrollment marblesDockerComposeNetworkmychannelOrg0MSPfabricpeerorg1 info: Success enrolling admin debug: loading pem from a path: /home/bcuser/zmarbles/crypto-config/peerOrganizations/unitedmarbles.com/ca/ca.unitedmarbles.com-cert.pem debug: loading pem from a path: /home/bcuser/zmarbles/crypto-config/ordererOrganizations/blockchain.com/orderers/orderer.blockchain.com/tls/ca.crt debug: loading pem from a path: /home/bcuser/zmarbles/crypto-config/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/ca.crt debug: Checking if chaincode is already instantiated or not 1 info: Checking for chaincode... debug: [fcw] Querying Chaincode: read() debug: [fcw] Sending query req: chaincodeId=marbles, fcn=read, args=[selftest], txId=null debug: [fcw] Peer Query Response - len: 1 type: number debug: [fcw] Successful query transaction. ----------------------------- Chaincode found on channel \"mychannel\" ----------------------------- info: Checking chaincode and ui compatibility... debug: [fcw] Querying Chaincode: read() debug: [fcw] Sending query req: chaincodeId=marbles, fcn=read, args=[marbles_ui], txId=null warn: [fcw] warning - query resp is not json, might be okay: string 4.0.1 debug: [fcw] Successful query transaction. info: Chaincode version is good info: Checking ledger for marble owners listed in the config file info: Fetching EVERYTHING... debug: [fcw] Querying Chaincode: read_everything() debug: [fcw] Sending query req: chaincodeId=marbles, fcn=read_everything, args=[], txId=null debug: [fcw] Peer Query Response - len: 529 type: object debug: [fcw] Successful query transaction. debug: This company has registered marble owners debug: Looking for marble owner: amy debug: Did not find marble username: amy info: We need to make marble owners - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - info: Detected that we have NOT launched successfully yet debug: Open your browser to http://localhost:3001 and login as \"admin\" to initiate startup - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - The first line of the output just listed reads: [16:02:03] Using gulpfile ~/zmarbles/marblesUI/gulpfile.js I am not going to go into detail on the gulp tool here, but if you are curious, if you look into the gulpfile.js file (you would have to use another PuTTY or SSH session as this one is now tied up) you would find that a marbles1 task ( marbles1 being your argument to the gulp command) is defined: gulp.task('marbles1', ['env_tls', 'watch-sass', 'watch-server', 'server']); The marbles1 task specifies four more tasks to run, the first of which is env_tls . This task is adding a value to a map named env . This value points to the marbles1.json file: gulp.task('env_tls', function () { env['creds_filename'] = 'marbles1.json'; }); The last of the tasks, server , when it is started, is receiving this map named env as part of its invocation: gulp.task('server', function(a, b) { if(node) node.kill(); node = spawn('node', ['app.js'], {env: env, stdio: 'inherit'}); //command, file, options }); The syntax is a bit arcane, and this is not a course in JavaScript, but there is a line in the main file for the server, app.js , that reads this creds_filename value: var cp = require(__dirname + '/utils/connection_profile_lib/index.js')(process.env.creds_filename, logger); Then within utils/connection_profile_lib/index.js is where all the magic, a.k.a. code, happens to make use of the values specified in that file. You did not need to know all this to run the application, but you might need to know where to start looking when your boss asks you to tailor the marbles application because she wants a return on the time and money you spent taking this lab- assuming you don't get off the hook when you tell her that nowhere was JavaScript mentioned on the agenda. Step 3.3: Open up a web browser window or tab and point to http:// your_IP_goes_here>:3001 . Substitute your team's assigned IP address instead of your_IP_goes_here> . You should see a window pop up that looks like this: Step 3.4: You are given a choice between Express and Guided for setting up the demo. Don't short-change yourself- pick Guided , you'll learn more. After you click Guided , you will see this: Read the text in the window to see what's going on. Step 3.5: If you do not see Step 1 Complete , ask an instructor for help. Otherwise, click Next Step and you should see this: Click the '+' sign if you wish to see the settings used to contact the Fabric Certificate Authority. Step 3.6: If you do not see Step 2 Complete , ask an instructor for help. Otherwise, click Next Step and you should see this: Click the '+' sign to see information about your environment and your marbles chaincode. Step 3.7: If you do not see Step 3 Complete , ask an instructor for help. Otherwise, click Next Step and you should see this: Step 3.8: Unlike the first three steps, which did not require further input from you to complete, this step will not proceed until you click the Create button. Before you do that you have an opportunity to review and change the names that you use for new marbles owners in addition to the owner named 'Barry' that should already exist (though not evident from this screen) if you created it in the first part of this lab. Click the Create button when you are ready and after several seconds you should see Step 4 Complete on the screen: Step 3.9: If you do not see Step 4 Complete , ask an instructor for help. Otherwise, click Next Step and you should see this: This should just give you a smiley face and a message saying that setup is complete. Step 3.10: Click Enter and you should be returned to a screen that looks similar to this (your names may differ): Step 3.11: What about John's marble for Marbles Inc.? You only started up the server for United Marbles, so why does Marbles Inc show up and why is John so lonely? When you did the previous lab, the first two commands I had you do were an init_owner for John, tying him to Marbles Inc, and then an init_marble , giving him a marble. Remember, the \"blockchain\" is shared among all participants of the channel, so United Marbles and Marbles Inc both see the same chain- they see each other's marbles. But the user names specified in config/marbles2.json are not created until you start the server for marbles2 and log in the first time. List the contents of marbles2.json file (switch to a free terminal session or start a new one), e.g.: bcuser@ubuntu18042:~$ cd ~/zmarbles/marblesUI bcuser@ubuntu18042:~/zmarbles/marblesUI$ cat config/marbles2.json { \"cred_filename\": \"connection_profile2.json\", \"use_events\": false, \"keep_alive_secs\": 120, \"company\": \"Marbles Inc\", \"usernames\": [ \"cliff\", \"cody\", \"chuck\" ], \"port\": 3002, \"last_startup_hash\": \"\" } bcuser@ubuntu18042:~/zmarbles/marblesUI$ Step 3.12: Start the second server, the one for Marbles Inc: bcuser@ubuntu18042:~/zmarbles/marblesUI$ gulp marbles2 [16:07:49] Using gulpfile ~/zmarbles/marblesUI/gulpfile.js [16:07:49] Starting 'env_tls2'... [16:07:49] Finished 'env_tls2' after 50 \u03bcs [16:07:49] Starting 'build-sass'... [16:07:49] Finished 'build-sass' after 7.9 ms [16:07:49] Starting 'watch-sass'... [16:07:49] Finished 'watch-sass' after 6.38 ms [16:07:49] Starting 'watch-server'... [16:07:49] Finished 'watch-server' after 1.9 ms [16:07:49] Starting 'server'... info: Checking connection profile is done info: Loaded config file /home/bcuser/zmarbles/marblesUI/config/marbles2.json info: Loaded connection profile file /home/bcuser/zmarbles/marblesUI/config/connection_profile2.json Connection Profile Lib Functions:() getNetworkName() getNetworkCredFileName() buildTlsOpts() getFirstChannelId() getChannelId() loadPem() getMarblesField() getChaincodeId() getChaincodeVersion() getFirstCaName() getCA() getCasUrl() getAllCaUrls() getCaName() getCaTlsCertOpts() getEnrollObj() getFirstPeerName() getPeer() getPeersUrl() getAllPeerUrls() getPeerEventUrl() getPeerTlsCertOpts() getMarbleUsernamesConfig() getCompanyNameFromFile() getMarblesPort() getEventsSetting() getKeepAliveMs() getFirstOrdererName() getOrderer() getOrderersUrl() getOrdererTlsCertOpts() getBlockDelay() getKvsPath() getFirstOrg() getClientsOrgName() getClientOrg() getMarbleUsernames() getOrgsMSPid() getAdminPrivateKeyPEM() getAdminSignedCertPEM() ----------------------------------- Server Up - localhost:3002 ----------------------------------- Welcome aboard: Marbles Inc Channel: mychannel Org: Org1MSP CA: fabric-ca-org2 Orderer: fabric-orderer Peer: fabric-peer-org2 Chaincode ID: marbles Chaincode Version: v4 ------------------------------------------ Websocket Up ------------------------------------------ debug: loading pem from a path: /home/bcuser/zmarbles/crypto-config/peerOrganizations/marblesinc.com/ca/ca.marblesinc.com-cert.pem debug: loading pem from a path: /home/bcuser/zmarbles/crypto-config/ordererOrganizations/blockchain.com/orderers/orderer.blockchain.com/tls/ca.crt debug: loading pem from a path: /home/bcuser/zmarbles/crypto-config/peerOrganizations/marblesinc.com/peers/peer0.marblesinc.com/tls/ca.crt info: [fcw] Going to enroll peer_urls=[grpcs://localhost:9051], channel_id=mychannel, uuid=marblesDockerComposeNetworkmychannelOrg1MSPfabricpeerorg2, ca_url=https://localhost:8054, orderer_url=grpcs://localhost:7050, enroll_id=admin2, enroll_secret=adminpw2, msp_id=Org1MSP, kvs_path=/home/bcuser/.hfc-key-store/marblesDockerComposeNetworkmychannelOrg1MSPfabricpeerorg2 debug: enroll id: \"admin2\", secret: \"adminpw2\" debug: msp_id: Org1MSP ca_name: ca-org1 info: [fcw] Successfully enrolled user 'admin2' debug: added peer grpcs://localhost:9051 debug: [fcw] Successfully got enrollment marblesDockerComposeNetworkmychannelOrg1MSPfabricpeerorg2 info: Success enrolling admin debug: loading pem from a path: /home/bcuser/zmarbles/crypto-config/peerOrganizations/marblesinc.com/ca/ca.marblesinc.com-cert.pem debug: loading pem from a path: /home/bcuser/zmarbles/crypto-config/ordererOrganizations/blockchain.com/orderers/orderer.blockchain.com/tls/ca.crt debug: loading pem from a path: /home/bcuser/zmarbles/crypto-config/peerOrganizations/marblesinc.com/peers/peer0.marblesinc.com/tls/ca.crt debug: Checking if chaincode is already instantiated or not 1 info: Checking for chaincode... debug: [fcw] Querying Chaincode: read() debug: [fcw] Sending query req: chaincodeId=marbles, fcn=read, args=[selftest], txId=null debug: [fcw] Peer Query Response - len: 1 type: number debug: [fcw] Successful query transaction. ----------------------------- Chaincode found on channel \"mychannel\" ----------------------------- info: Checking chaincode and ui compatibility... debug: [fcw] Querying Chaincode: read() debug: [fcw] Sending query req: chaincodeId=marbles, fcn=read, args=[marbles_ui], txId=null warn: [fcw] warning - query resp is not json, might be okay: string 4.0.1 debug: [fcw] Successful query transaction. info: Chaincode version is good info: Checking ledger for marble owners listed in the config file info: Fetching EVERYTHING... debug: [fcw] Querying Chaincode: read_everything() debug: [fcw] Sending query req: chaincodeId=marbles, fcn=read_everything, args=[], txId=null debug: [fcw] Peer Query Response - len: 2291 type: object debug: [fcw] Successful query transaction. debug: This company has registered marble owners debug: Looking for marble owner: cliff debug: Did not find marble username: cliff info: We need to make marble owners - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - info: Detected that we have NOT launched successfully yet debug: Open your browser to http://localhost:3002 and login as \"admin\" to initiate startup - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - If you peek at your browser session from United Marbles, (port 3001), you will not notice any changes yet. Step 3.13: Open a browser tab or window and navigate to http:// your_IP_here>:3002 . You will again be given a choice of Express or Guided and feel free to choose whichever path suits your fancy. If you choose Express , everything should hopefully sail through until you see a screen with all Marbles Inc. owners and marbles, as well as all United Marbles owners and marbles: Step 3.14: If you go back to your screen for United Marbles (port 3001) you should observe that it has been updated to show the owners and marbles for Marbles Inc. in addition to United Marbles' own owners and marbles: Remember, you are looking at the United Marbles session but you see all the new users and marbles created by the Marbles Inc administrator. Step 3.15: Play with your marbles!! Here are some things you can do. When you do things as one user, e.g. as the United Marbles admin, go to the other user's screen to see that the changes one organization makes are visible to the other organization: On two different browser sessions, you should be logged in as the administrator for each of the two fictitious companies. When you are the United Marbles administrator, you can create marbles for you or anybody in United Marbles. You can delete marbles for you or anybody in United Marbles. You can take marbles from anybody in United Marbles and give them to anybody in the network, even to Marbles Inc people. (And vice versa when you are a Marbles Inc administrator). Try clicking on the little magnifying glass to the left of the browser window and follow the directions Right click on a marble (Hint: this is the same as using the magnifying glass) Click on the Settings button and Enable story mode. Try an action that is allowed, and try an action that shouldn't be allowed, such as trying to steal a marble from the other company. Disable story mode when it gets too tedious, which shouldn't take long. Step 3.16: If you want that extra rush, try these optional advanced assignments: Break out the previous lab's material and enter the cli container and issue some commands to create, update or delete marbles. See if the Marbles UI reflects your changes Look at some of the marbles chaincode container logs while you work with the Marbles UI - Hint: docker logs [-f] container_name will show a container's log. Try it without the optional -f argument first and then try it with it. -f ties up your terminal session but then shows new log messages as they are created. Press Ctrl-c to get out of it. Look at the peer or orderer logs while you work with the Marbles UI Click the Start Up Help button in the upper left in the Marbles UI and then number 4 in the window that pops up. Edit the list of names at the bottom and click Create . Do your new users show up in both companies' sessions? What happens if you add a name that exists already? Section 4: Lab cleanup Step 4.1: In both of your terminals sessions that were used to start each Web UI, press Crtl-c to end the Web UI process. You can also close the tabs in your browser that were displaying the Web UI. Step 4.2: Navigate to the zmarbles directory: bcuser@ubuntu18042:~/zmarbles/marblesUI$ cd ~/zmarbles bcuser@ubuntu18042:~/zmarbles$ Step 4.3: Enter this Docker command to show the running Docker containers that make up your Hyperledger Fabric network: bcuser@ubuntu18042:~/zmarbles$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1e5c05183d6f dev-peer1.unitedmarbles.com-marbles-1.0-dea1aa08dc7c6f282a31dd498670173c21d3e75ef0ef1d170b95e1212fbacb77 \"chaincode -peer.add\u2026\" 26 minutes ago Up 26 minutes dev-peer1.unitedmarbles.com-marbles-1.0 a7d6b658a35a dev-peer0.marblesinc.com-marbles-1.0-4077677f13838bacbfd8ff943e7348c00f3c4d6ca6e2838efd14204ca87ea12b \"chaincode -peer.add\u2026\" 31 minutes ago Up 31 minutes dev-peer0.marblesinc.com-marbles-1.0 62a185d148d2 dev-peer0.unitedmarbles.com-marbles-1.0-7e92f069adb7469939a96dcba723fa2019745461f05a562e81cec38e46424aa1 \"chaincode -peer.add\u2026\" 39 minutes ago Up 39 minutes dev-peer0.unitedmarbles.com-marbles-1.0 84b6c0ee74aa hyperledger/fabric-tools:1.4.1 \"bash\" About an hour ago Up About an hour cli e6eabd9fd96d hyperledger/fabric-peer:1.4.1 \"peer node start\" About an hour ago Up About an hour 0.0.0.0:9051- 7051/tcp, 0.0.0.0:9052- 7052/tcp, 0.0.0.0:9053- 7053/tcp peer0.marblesinc.com 8174f3021744 hyperledger/fabric-peer:1.4.1 \"peer node start\" About an hour ago Up About an hour 0.0.0.0:8051- 7051/tcp, 0.0.0.0:8052- 7052/tcp, 0.0.0.0:8053- 7053/tcp peer1.unitedmarbles.com 1a22b9eb5be5 hyperledger/fabric-peer:1.4.1 \"peer node start\" About an hour ago Up About an hour 0.0.0.0:10051- 7051/tcp, 0.0.0.0:10052- 7052/tcp, 0.0.0.0:10053- 7053/tcp peer1.marblesinc.com 11423ca89763 hyperledger/fabric-peer:1.4.1 \"peer node start\" About an hour ago Up About an hour 0.0.0.0:7051-7053- 7051-7053/tcp peer0.unitedmarbles.com 18b9e5efbfc9 hyperledger/fabric-couchdb:s390x-0.4.15 \"tini -- /docker-ent\u2026\" About an hour ago Up About an hour 4369/tcp, 9100/tcp, 0.0.0.0:6984- 5984/tcp couchdb1 77288f8c0060 hyperledger/fabric-couchdb:s390x-0.4.15 \"tini -- /docker-ent\u2026\" About an hour ago Up About an hour 4369/tcp, 9100/tcp, 0.0.0.0:7984- 5984/tcp couchdb2 43214da184da hyperledger/fabric-ca:1.4.1 \"sh -c 'fabric-ca-se\u2026\" About an hour ago Up About an hour 0.0.0.0:7054- 7054/tcp ca_Org0 1ea639c77a3a hyperledger/fabric-ca:1.4.1 \"sh -c 'fabric-ca-se\u2026\" About an hour ago Up About an hour 0.0.0.0:8054- 7054/tcp ca_Org1 07df27e35368 hyperledger/fabric-couchdb:s390x-0.4.15 \"tini -- /docker-ent\u2026\" About an hour ago Up About an hour 4369/tcp, 9100/tcp, 0.0.0.0:8984- 5984/tcp couchdb3 93e0465394b6 hyperledger/fabric-orderer:1.4.1 \"orderer\" About an hour ago Up About an hour 0.0.0.0:7050- 7050/tcp orderer.blockchain.com 4201915cc3b2 hyperledger/fabric-couchdb:s390x-0.4.15 \"tini -- /docker-ent\u2026\" About an hour ago Up About an hour 4369/tcp, 9100/tcp, 0.0.0.0:5984- 5984/tcp couchdb0 bcuser@ubuntu18042:~/zmarbles$ Step 4.4: Enter this command to bring down your Hyperledger Fabric network: bcuser@ubuntu18042:~/zmarbles$ docker-compose down WARNING: The CHANNEL_NAME variable is not set. Defaulting to a blank string. Stopping cli ... done Stopping peer0.marblesinc.com ... done Stopping peer1.unitedmarbles.com ... done Stopping peer1.marblesinc.com ... done Stopping peer0.unitedmarbles.com ... done Stopping couchdb1 ... done Stopping couchdb2 ... done Stopping ca_Org0 ... done Stopping ca_Org1 ... done Stopping couchdb3 ... done Stopping orderer.blockchain.com ... done Stopping couchdb0 ... done Removing cli ... done Removing peer0.marblesinc.com ... done Removing peer1.unitedmarbles.com ... done Removing peer1.marblesinc.com ... done Removing peer0.unitedmarbles.com ... done Removing couchdb1 ... done Removing couchdb2 ... done Removing ca_Org0 ... done Removing ca_Org1 ... done Removing couchdb3 ... done Removing orderer.blockchain.com ... done Removing couchdb0 ... done Removing network zmarbles_default bcuser@ubuntu18042:~/zmarbles$ Step 4.5: Enter this and you should not see any running Docker containers: bcuser@ubuntu18042:~/zmarbles$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES bcuser@ubuntu18042:~/zmarbles$ Step 4.6: Add the --all argument to the prior command and you will see some Exited Docker containers: bcuser@ubuntu18042:~/zmarbles$ docker ps --all CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1e5c05183d6f dev-peer1.unitedmarbles.com-marbles-1.0-dea1aa08dc7c6f282a31dd498670173c21d3e75ef0ef1d170b95e1212fbacb77 \"chaincode -peer.add\u2026\" 28 minutes ago Exited (0) About a minute ago dev-peer1.unitedmarbles.com-marbles-1.0 a7d6b658a35a dev-peer0.marblesinc.com-marbles-1.0-4077677f13838bacbfd8ff943e7348c00f3c4d6ca6e2838efd14204ca87ea12b \"chaincode -peer.add\u2026\" 33 minutes ago Exited (0) About a minute ago dev-peer0.marblesinc.com-marbles-1.0 62a185d148d2 dev-peer0.unitedmarbles.com-marbles-1.0-7e92f069adb7469939a96dcba723fa2019745461f05a562e81cec38e46424aa1 \"chaincode -peer.add\u2026\" 41 minutes ago Exited (0) About a minute ago dev-peer0.unitedmarbles.com-marbles-1.0 bcuser@ubuntu18042:~/zmarbles$ Step 4.7: Enter this command to remove these containers: bcuser@ubuntu18042:~/zmarbles$ docker rm $(docker ps --all --quiet) 1e5c05183d6f a7d6b658a35a 62a185d148d2 bcuser@ubuntu18042:~/zmarbles$ Step 4.8: Repeat the command from Step 4.6 and you should not see any containers: bcuser@ubuntu18042:~/zmarbles$ docker ps --all CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES bcuser@ubuntu18042:~/zmarbles$ Step 4.9: List your Docker images: bcuser@ubuntu18042:~/zmarbles$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE dev-peer1.unitedmarbles.com-marbles-1.0-dea1aa08dc7c6f282a31dd498670173c21d3e75ef0ef1d170b95e1212fbacb77 latest c0e41de218a2 30 minutes ago 137MB dev-peer0.marblesinc.com-marbles-1.0-4077677f13838bacbfd8ff943e7348c00f3c4d6ca6e2838efd14204ca87ea12b latest ab7f5fa821ee 35 minutes ago 137MB dev-peer0.unitedmarbles.com-marbles-1.0-7e92f069adb7469939a96dcba723fa2019745461f05a562e81cec38e46424aa1 latest d41acea306aa 43 minutes ago 137MB hyperledger/fabric-ca 1.4.1 a836041637e8 2 weeks ago 220MB hyperledger/fabric-tools 1.4.1 330902566372 2 weeks ago 1.52GB hyperledger/fabric-ccenv latest 8583516cfc43 2 weeks ago 1.41GB hyperledger/fabric-orderer 1.4.1 1b709e319b2d 2 weeks ago 148MB hyperledger/fabric-peer 1.4.1 719392658c28 2 weeks ago 154MB hyperledger/fabric-couchdb s390x-0.4.15 81ee917e0be2 5 weeks ago 1.55GB hyperledger/fabric-baseos s390x-0.4.15 d4eb16b952d6 5 weeks ago 120MB bcuser@ubuntu18042:~/zmarbles$ Step 4.10: This command will format the output from docker images : bcuser@ubuntu18042:~/zmarbles$ docker images --format '{{.Repository}}:{{.Tag}}' dev-peer1.unitedmarbles.com-marbles-1.0-dea1aa08dc7c6f282a31dd498670173c21d3e75ef0ef1d170b95e1212fbacb77:latest dev-peer0.marblesinc.com-marbles-1.0-4077677f13838bacbfd8ff943e7348c00f3c4d6ca6e2838efd14204ca87ea12b:latest dev-peer0.unitedmarbles.com-marbles-1.0-7e92f069adb7469939a96dcba723fa2019745461f05a562e81cec38e46424aa1:latest hyperledger/fabric-ca:1.4.1 hyperledger/fabric-tools:1.4.1 hyperledger/fabric-ccenv:latest hyperledger/fabric-orderer:1.4.1 hyperledger/fabric-peer:1.4.1 hyperledger/fabric-couchdb:s390x-0.4.15 hyperledger/fabric-baseos:s390x-0.4.15 bcuser@ubuntu18042:~/zmarbles$ Step 4.11: The output from the prior step is in a format acceptable to the Docker command to remove images, so this command will feed that output into the Docker rmi command, and remove these images: bcuser@ubuntu18042:~/zmarbles$ docker rmi $(docker images --format '{{.Repository}}:{{.Tag}}') Untagged: dev-peer1.unitedmarbles.com-marbles-1.0-dea1aa08dc7c6f282a31dd498670173c21d3e75ef0ef1d170b95e1212fbacb77:latest Deleted: sha256:c0e41de218a260a73053d538aa45ca0f925cd3ee7d8898151ea7df39dc1ac813 Deleted: sha256:40fc70560501ded0fbf1d7bc6a2e77de321041a62770822f692977cd363f16be Deleted: sha256:4a8c59ccf0d503088d13b041260d4741509656336b431e6bb7e64b20a91b90fb Deleted: sha256:8ce2cde820ef4ccfef99f8389315141614441b89219de487da33db3494874c8b Untagged: dev-peer0.marblesinc.com-marbles-1.0-4077677f13838bacbfd8ff943e7348c00f3c4d6ca6e2838efd14204ca87ea12b:latest Deleted: sha256:ab7f5fa821ee42c139722b2360909c95c1b2586cb437686122af1e571bd34802 Deleted: sha256:f7a0e17801a42a44340f27cb7c7332314534d1ed2d4573cb5334f27289dc5ff0 Deleted: sha256:8085444130169915f706aecfac10aaeee4d3e641e63e4686258c513e6fe85830 Deleted: sha256:e0f59705093caa197dde37fba5d05aa4635465b5d42e8d48234b9a28d3423a48 Untagged: dev-peer0.unitedmarbles.com-marbles-1.0-7e92f069adb7469939a96dcba723fa2019745461f05a562e81cec38e46424aa1:latest Deleted: sha256:d41acea306aa6d858cca4f55bb92b20335da5a588550411d32fc77def25d3775 Deleted: sha256:493804d997703675b48104eed5e6868b1e6f14bf954fbb56ac5784a82838ccbf Deleted: sha256:3504ecc13cf81ec4947132a9261600f1e9cdeee94672df62469f2061bd1a4b2a Deleted: sha256:8267b35c52b6b78b7341b95c5c044a69feb53075c704b2eea87a4d4b6036be06 Untagged: hyperledger/fabric-ca:1.4.1 Untagged: hyperledger/fabric-ca@sha256:f77aa0ff885c572b090d1ff7564780daafd50d9e839b6241c2ab12c37f47b94a Deleted: sha256:a836041637e817846f71541e47e8749f6188676a1ac282f006ca03758290f4ff Deleted: sha256:8fa3260318e50be92f0118657fa3aa395e264cfa2fbe0dbedb9419fff1547bfd Deleted: sha256:f0c44e96c65ce80eaeb561f89fa23ae82c5af54b1b1b050ecadd827b45bebd23 Deleted: sha256:e2e8ca9c5a2fb8c69e32428be2f27d6bb0c1e1b7e58af5d4d5aa788ce8d9fd68 Deleted: sha256:a353d8ddb009e3c0dd6bd0558a1e3ed847951f42ae632a91ad49029bb69b9fc0 Deleted: sha256:f1079f0f139b61ea01f32de10d58de81e1fc393038d3fa774221a736f942023f Deleted: sha256:165d46e0e538aacfcecf19a4088c2e7b490384e7b3cecb090a16b19cba8722d9 Deleted: sha256:85fb95169355a4e6fcd52672b1e60739f120ee9e541413732cb53d8e5c97beae Untagged: hyperledger/fabric-tools:1.4.1 Untagged: hyperledger/fabric-tools@sha256:c458ddc3109d3519b209baaf9abff113641267ec2adb01dfdcf8f4c9e77a2fa0 Deleted: sha256:330902566372ecfc06a396c05d026a0d17fa40379dc1327894869ad370023637 Deleted: sha256:1021b7b3b232c0954f944c6d2baec3ef80dc9481bcabea5a12db4f7d276c86f7 Deleted: sha256:9427db3491c3adcb8cecfcf50bb3c8deeab27d3739538c2cd246ee6b856515a9 Deleted: sha256:dba040b6371fcdc2b78128d10e952cc716b75ba67f2dc330086c908fb830fa1d Untagged: hyperledger/fabric-ccenv:latest Untagged: hyperledger/fabric-ccenv@sha256:bb929eef560b50e0fbd730c6b195e49fece28dd4612ec30db0ce2cc096483463 Deleted: sha256:8583516cfc43491e2db2e393408121b85636f622d39d2a8e3c46ac278d3d3ce2 Deleted: sha256:3d53a661451588e08ea4f0b1e6fac40633b4dcef9fb895ad12f9309453d85dfa Deleted: sha256:04e554cb54244558f5567c17ebcb7a02b64822036ece595fefb4f98d2ab31a7a Deleted: sha256:a2ec3c9f4ab3e2a789239638d99aa4a760998c8424d29313d5461bcfd2929612 Untagged: hyperledger/fabric-orderer:1.4.1 Untagged: hyperledger/fabric-orderer@sha256:09f31ca4dabe1eb2af870ea062561ca6686fc59a296ecc3b4bd7e32102c48934 Deleted: sha256:1b709e319b2d2e7d137112ff5e24b7b6a0ddf0a5bf8843c47adfc9095b3f8778 Deleted: sha256:43747e128cff58f58f5642bce1b27613ecb3dec5aa8fc7caf0ce5e2397415371 Deleted: sha256:fb1a267f0371757e83dcf6221291269b29a7089a0f7a8545ff3f538509e19e0e Untagged: hyperledger/fabric-peer:1.4.1 Untagged: hyperledger/fabric-peer@sha256:05315d05b2892d34b4ed48f6502d28fe15a71090c36a39c97022a44475a984ad Deleted: sha256:719392658c28f69bb25ccc71a8da86050f646f4ffaf51a279cdcea079b5f993e Deleted: sha256:04d6dbf6b6fcdaaedb6d55a021bd1dcb0695ecfbe9e2538fe2dd1365987eea0b Deleted: sha256:4c58d7859aeaf30d72dada842ce28df9d542e2ffc1ab2213b81483f080adceef Deleted: sha256:6299707a98af34860777b48b86df6ec7ae8cf45ae76cbf4cbedcb1dc55888061 Untagged: hyperledger/fabric-couchdb:s390x-0.4.15 Untagged: hyperledger/fabric-couchdb@sha256:e8701a2dd7400d200a6c3b1ffd42331e2d5255d30c1efb117fc5a10bbf9063b6 Deleted: sha256:81ee917e0be2fe0b5f46cf6ed34d32169118c8d995cee636ce47ffb96d3afd95 Deleted: sha256:e4cdccb03102bce02d4e9179cf1eed5808e97bb77fb7bf7596776900caf3f22a Deleted: sha256:12e70245586bf85d0f2eabc4ba33c1df77d51e604c294551e43c9dec425f619c Deleted: sha256:f7a35da6c7b30fa6fa11e2f6e44938ea4df158db403064832a73d1e9b11aa719 Deleted: sha256:1b774897931652fde3bb2609e0f46fa4c3a3f522db395359a2aeee1a218aab54 Deleted: sha256:1132017bbb8c969f03a11ec80e77eea71a3fc54dbae9e2b588b01fc5c0502972 Deleted: sha256:de23c4b00ab7d92310f73b45cacf5b861a8f40c5b069c0660eb1bc6d472c98e7 Deleted: sha256:62306dc38b9fc0fb7922d4d1358d135e1c7411b01e51bb631fc5269308387c42 Deleted: sha256:8bc0cb77c66908a5059433ca0b41f453721de3bc529ecc258ff91818ce19e87f Deleted: sha256:8445d7f0d5111f5ee7fe4ada50d718df0977e9b071045e09b3d619effd16d7e0 Deleted: sha256:f593f65839abaaf5f0c18604b7f065b4cab58bfeafa867b7be75fc6ca52e187a Deleted: sha256:18eaede2be21b8fdba162857cbf79ce9a04cb2671da8c40dc804280e791e9742 Deleted: sha256:ef88e98e5731409ad689aec3233fcca8d5f1b38e435558308d8289fb3d5a5383 Deleted: sha256:9941b43bff58fff3234b1f356d65f1d383265156c82ba90805a00ba758e5fa14 Deleted: sha256:31699b2e24542ffbc8cf9678644e62ab195263be033713327992314d59ddffbb Untagged: hyperledger/fabric-baseos:s390x-0.4.15 Untagged: hyperledger/fabric-baseos@sha256:94fefcbeb2c0da7ac6371ad589b66b2bbe7cfb76bf28ba7aaf85790bed82c839 Deleted: sha256:d4eb16b952d6c8b742cbe47caf6522c71f9b1654a31abc582918905d64db07e7 Deleted: sha256:234cfc5f3368cd92d65d03e5da6bc0bd985ab94c4931e692faa758bd6d811c7b Deleted: sha256:3e2d2d75f895801cefdecac9e2584d964caf0ed7fb1d8afeffeaea5e287ea9cb Deleted: sha256:d8e11f36fc45b7073d3b0eb3636428dedebb40f392bea9fa5751ed92848ca875 bcuser@ubuntu18042:~/zmarbles$ Step 4.12: Now you should not see any images: bcuser@ubuntu18042:~/zmarbles$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE bcuser@ubuntu18042:~/zmarbles$ IMAGE ID CREATED SIZE Step 4.13: You may type exit from your terminal session(s) to log out of the system bcuser@ubuntu18042:~/zmarbles$ exit logout Connection to 192.168.22.1xx closed. Barrys-MacBook-Pro:ImmersionWorkshop silliman$ End of lab!","title":"Hlf part2"},{"location":"hlf-part2/#section-1-lab-part-2-overview","text":"In this part of the lab, you will use the Hyperledger Fabric network that you created in the Part 1 of the lab and configure the Marbles User Interface (UI) web application so that it will integrate with the marbles chaincode that you installed in the previous lab. You will use two browser sessions to simulate acting as a user for each of the two organizations in the network- United Marbles and Marbles Inc . Then you can explore the Marbles UI to execute chaincode transactions and see some of the Hyperledger Fabric concepts in action.","title":"Section 1: Lab Part 2 Overview"},{"location":"hlf-part2/#section-2-marbles-user-interface-setup","text":"Step 2.1: Switch to the ~/zmarbles/marblesUI directory: bcuser@ubuntu18042:~/zmarbles$ cd ~/zmarbles/marblesUI bcuser@ubuntu18042:~/zmarbles/marblesUI$ Step 2.2: You will need to do an npm install to install the packages needed by the Marbles user interface. First you will verify that the node_modules directory does not exist. This directory will be created when you run an npm install in the next step, so right now it shouldn't exist: bcuser@ubuntu18042:~/zmarbles/marblesUI$ ls -l node_modules ls: cannot access 'node_modules': No such file or directory bcuser@ubuntu18042:~/zmarbles/marblesUI$ Step 2.3: Now run the npm install : bcuser@ubuntu18042:~/zmarbles/marblesUI$ npm install . . (output not shown here) . Step 2.4: When this command ends, list the node_modules directory again. It is there now: bcuser@ubuntu18042:~/zmarbles/marblesUI$ ls -l node_modules . . (output not shown here) . bcuser@ubuntu18042:~/zmarbles/marblesUI$ Step 2.5: Change to the config directory: bcuser@ubuntu18042:~/zmarbles/marblesUI$ cd config bcuser@ubuntu18042:~/zmarbles/marblesUI/config$ Step 2.6: There are four files in this directory: bcuser@ubuntu18042:~/zmarbles/marblesUI/config$ ls connection_profile1.json connection_profile2.json marbles1.json marbles2.json bcuser@ubuntu18042:~/zmarbles/marblesUI/config$ Step 2.7: There are two files for the first fictitious company, United Marbles , and two files for the second fictitious company, Marbles Inc. Look at the marbles1.json file with the cat command: bcuser@ubuntu18042:~/zmarbles/marblesUI/config$ cat marbles1.json { \"cred_filename\": \"connection_profile1.json\", \"use_events\": false, \"keep_alive_secs\": 120, \"company\": \"United Marbles\", \"usernames\": [ \"amy\", \"alice\", \"ava\" ], \"port\": 3001, \"last_startup_hash\": \"\" } bcuser@ubuntu18042:~/zmarbles/marblesUI/config$ Step 2.8: Notice that this file points to one of the other existing files, connection_profile1.json , as the value of the cred_filename name/value pair. You will look at that in a moment. Take a note of the usernames array- amy , alice , and ava . If you are comfortable with the vi editor you could change those names to your favorite names if you would like. You can also use the sed command to change the name inline without entering vi . Here is an example of a command to change the name alice to vincent . This step is optional- you do not have to do this is you prefer the name alice to vincent : bcuser@ubuntu18042:~/zmarbles/marblesUI/config$ sed -i \"s/alice/vincent/\" marbles1.json # optional bcuser@ubuntu18042:~/zmarbles/marblesUI/config$ Step 2.9: Here is the file after I changed alice to vincent with the previous sed command: bcuser@ubuntu18042:~/zmarbles/marblesUI/config$ cat marbles1.json { \"cred_filename\": \"connection_profile1.json\", \"use_events\": false, \"keep_alive_secs\": 120, \"company\": \"United Marbles\", \"usernames\": [ \"amy\", \"vincent\", \"ava\" ], \"port\": 3001, \"last_startup_hash\": \"\" } bcuser@ubuntu18042:~/zmarbles/marblesUI/config$ NOTE: Your file will look different if you choose to skip the optional Step 2.9 or if you made changes other than the example change I showed. The purpose of this step is to ensure that your file changed the way you intended it to (if it changed at all). The other key thing to note is the port number. It is 3001 here. In the marbles2.json file for Marbles Inc , port 3002 will be specified. This is how, later in this lab, you will pretend to be a user of one company or the other- by using port 3001 in the URL to pretend to be a \"United Marbles\" user and by using port 3002 in the URL to pretend to be a \"Marbles Inc\" user. Step 2.10: It is time to look at the main configuration file the Marbles app uses. It is the file specified as the cred_filename value in the marbles1.json file. This name cred_filename for the JSON name/value pair and the filename, blockchain_creds1.json , indicate that security credentials are specified in this file, and they are, but actually information about the Hyperledger Fabric network itself is specified in this file as well. This file is too large to fit in one screen, so I will teach you one more Linux command, named more . (Pun intended). Type this: bcuser@ubuntu18042:~/zmarbles/marblesUI/config$ more connection_profile1.json . . (output not shown) . bcuser@ubuntu18042:~/zmarbles/marblesUI/config$ This command will print as much of the file as it can on your screen but will pause until you hit the space bar before displaying the rest of the file's contents. Here are the complete contents of this file: { \"name\": \"Docker Compose Network\", \"x-networkId\": \"not-important\", \"x-type\": \"hlfv1\", \"description\": \"Connection Profile for an IBM Blockchain Network\", \"version\": \"1.0.0\", \"client\": { \"organization\": \"Org0MSP\" }, \"channels\": { \"mychannel\": { \"orderers\": [ \"fabric-orderer\" ], \"peers\": { \"fabric-peer-org1\" : { \"x-chaincode\": {} } }, \"chaincodes\": [ \"marbles:v4\" ], \"x-blockDelay\": 1000 } }, \"organizations\": { \"Org0MSP\": { \"mspid\": \"Org0MSP\", \"peers\": [ \"fabric-peer-org1\" ], \"certificateAuthorities\": [ \"fabric-ca-org1\" ] } }, \"orderers\": { \"fabric-orderer\": { \"url\": \"grpcs://localhost:7050\", \"grpcOptions\": { \"ssl-target-name-override\": \"orderer.blockchain.com\", \"grpc.http2.keepalive_time\": 300, \"grpc.keepalive_time_ms\": 300000, \"grpc.http2.keepalive_timeout\": 35, \"grpc.keepalive_timeout_ms\": 3500 }, \"tlsCACerts\": { \"path\": \"../../crypto-config/ordererOrganizations/blockchain.com/orderers/orderer.blockchain.com/tls/ca.crt\" } } }, \"peers\": { \"fabric-peer-org1\": { \"url\": \"grpcs://localhost:7051\", \"eventUrl\": \"grpcs://localhost:7053\", \"grpcOptions\": { \"ssl-target-name-override\": \"peer0.unitedmarbles.com\", \"grpc.http2.keepalive_time\": 300, \"grpc.keepalive_time_ms\": 300000, \"grpc.http2.keepalive_timeout\": 35, \"grpc.keepalive_timeout_ms\": 3500 }, \"tlsCACerts\": { \"path\": \"../../crypto-config/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/ca.crt\" } } }, \"certificateAuthorities\": { \"fabric-ca-org1\": { \"url\": \"https://localhost:7054\", \"httpOptions\": { \"ssl-target-name-override\": \"ca.unitedmarbles.com\", \"verify\": true }, \"tlsCACerts\": { \"path\": \"../../crypto-config/peerOrganizations/unitedmarbles.com/ca/ca.unitedmarbles.com-cert.pem\" }, \"registrar\": [ { \"enrollId\": \"admin\", \"enrollSecret\": \"adminpw\" } ], \"caName\": \"ca-org0\" } } } This is a standard Hyperledger Fabric connection profile. This lab does not use Hyperledger Composer, but I think the Hyperledger Composer team did a nice job describing Hyperledger Fabric connection profiles, as they use them too. See https://hyperledger.github.io/composer/latest/reference/connectionprofile for their description. They also reference a link in the Hyperledger Fabric Node.js SDK documentation at https://fabric-sdk-node.github.io/tutorial-network-config.html which is a little more advanced, and it describes the profile in YAML form versus the JSON form that this Marbles demo app uses. Important If you used a channel name other than the default of mychannel, you must change this value from mychannel to the value you used. Either use the vi editor if you are comfortable with that, or, you could use sed . For example, below there is a sed command, to change the channel name from mychannel to tim , along with \"before\" and \"after\" grep commands to show the changes (These commands are examples and only needed if you did not use the default channel name of mychannel)** Warning This step is necessary only if you did not use this lab's default channel name of mychannel earlier in Part 1 of this lab. And of course, this example shows the steps for changing the channel name to tim , so tailor the command shown here according to whatever non-default channel name you may have chosen. Warning Unlike most steps in this lab, there are three commands to enter in this step, two greps and a sed (hey, that sounds like a good name for a television show). But, again, and I can't emphasize this enough, don't run the commands in this step if you kept your channel name as the default value of mychannel . bcuser@ubuntu18042:~/zmarbles/marblesUI/config$ grep mychannel connection_profile[12].json blockchain_creds1.json: channel_id : mychannel , blockchain_creds2.json: channel_id : mychannel , bcuser@ubuntu18042:~/zmarbles/marblesUI/config$ sed -i s/mychannel/tim/ connection_profile[12].json bcuser@ubuntu18042:~/zmarbles/marblesUI/config$ grep -1 channels connection_profile[12].json connection_profile1.json- }, connection_profile1.json: channels : { connection_profile1.json- tim : { -- connection_profile2.json- }, connection_profile2.json: channels : { connection_profile2.json- tim : { bcuser@ubuntu18042:~/zmarbles/marblesUI/config$ Step 2.11: The considerations for marbles2.json and connection_profile2.json are the same as for marbles1.json and connection_profile1.json except that they apply to \"Marbles Inc.\" instead of \"United Marbles\". If you would like to compare the differences between connection_profile1.json and connection_profile2.json , try the diff command and observe its output. This command lists sections of the two files that it finds different. The lines from the first file, blockchain_creds1.json , start with ' ' (added by the diff command output, not in the actual file), and the lines from the second file, blockchain_creds2.json , start with '>': bcuser@ubuntu18042:~/zmarbles/marblesUI/config$ diff connection_profile1.json connection_profile2.json 8c8 \"organization\": \"Org0MSP\" --- \"organization\": \"Org1MSP\" 16c16 \"fabric-peer-org1\" : { --- \"fabric-peer-org2\" : { 27,28c27,28 \"Org0MSP\": { \"mspid\": \"Org0MSP\", --- \"Org1MSP\": { \"mspid\": \"Org1MSP\", 30c30 \"fabric-peer-org1\" --- \"fabric-peer-org2\" 33c33 \"fabric-ca-org1\" --- \"fabric-ca-org2\" 54,56c54,56 \"fabric-peer-org1\": { \"url\": \"grpcs://localhost:7051\", \"eventUrl\": \"grpcs://localhost:7053\", --- \"fabric-peer-org2\": { \"url\": \"grpcs://localhost:9051\", \"eventUrl\": \"grpcs://localhost:9053\", 58c58 \"ssl-target-name-override\": \"peer0.unitedmarbles.com\", --- \"ssl-target-name-override\": \"peer0.marblesinc.com\", 65c65 \"path\": \"../../crypto-config/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/ca.crt\" --- \"path\": \"../../crypto-config/peerOrganizations/marblesinc.com/peers/peer0.marblesinc.com/tls/ca.crt\" 70,71c70,71 \"fabric-ca-org1\": { \"url\": \"https://localhost:7054\", --- \"fabric-ca-org2\": { \"url\": \"https://localhost:8054\", 73c73 \"ssl-target-name-override\": \"ca.unitedmarbles.com\", --- \"ssl-target-name-override\": \"ca.marblesinc.com\", 77c77 \"path\": \"../../crypto-config/peerOrganizations/unitedmarbles.com/ca/ca.unitedmarbles.com-cert.pem\" --- \"path\": \"../../crypto-config/peerOrganizations/marblesinc.com/ca/ca.marblesinc.com-cert.pem\" 81,82c81,82 \"enrollId\": \"admin\", \"enrollSecret\": \"adminpw\" --- \"enrollId\": \"admin2\", \"enrollSecret\": \"adminpw2\" 85c85 \"caName\": \"ca-org0\" --- \"caName\": \"ca-org1\" bcuser@ubuntu18042:~/zmarbles/marblesUI/config$","title":"Section 2: Marbles user interface setup"},{"location":"hlf-part2/#section-3-start-the-marbles-user-interface","text":"In this section, you will use the Marbles user interface. You will start two browser sessions- one will be as a \"United Marbles\" user, and the other as a \"Marbles Inc\" user. Here in this lab, you are serving both companies' applications from the same server, so you will differentiate between the two companies by the port number. You will connect to port 3001 when acting as a United Marbles user, and you will connect to port 3002 when acting as a Marbles Inc user. In the real world, each of the two companies would probably either serve the user interface from their own server, or perhaps both companies would log in to a server provided by a service provider- think \"Blockchain-as-a-service\". The chosen topology is use-case dependent and beyond the scope of this lab. Step 3.1: You are now ready to start the server for UnitedMarbles. Back up to the ~/zmarbles/marblesUI directory: bcuser@ubuntu18042:~/zmarbles/marblesUI/config$ cd .. bcuser@ubuntu18042:~/zmarbles/marblesUI$ Step 3.2: You will now use gulp to start up the server, with this command: bcuser@ubuntu18042:~/zmarbles/marblesUI$ gulp marbles1 [16:02:03] Using gulpfile ~/zmarbles/marblesUI/gulpfile.js [16:02:03] Starting 'env_tls'... [16:02:03] Finished 'env_tls' after 50 \u03bcs [16:02:03] Starting 'build-sass'... [16:02:03] Finished 'build-sass' after 6.07 ms [16:02:03] Starting 'watch-sass'... [16:02:03] Finished 'watch-sass' after 6.36 ms [16:02:03] Starting 'watch-server'... [16:02:03] Finished 'watch-server' after 1.98 ms [16:02:03] Starting 'server'... info: Checking connection profile is done info: Loaded config file /home/bcuser/zmarbles/marblesUI/config/marbles1.json info: Loaded connection profile file /home/bcuser/zmarbles/marblesUI/config/connection_profile1.json Connection Profile Lib Functions:() getNetworkName() getNetworkCredFileName() buildTlsOpts() getFirstChannelId() getChannelId() loadPem() getMarblesField() getChaincodeId() getChaincodeVersion() getFirstCaName() getCA() getCasUrl() getAllCaUrls() getCaName() getCaTlsCertOpts() getEnrollObj() getFirstPeerName() getPeer() getPeersUrl() getAllPeerUrls() getPeerEventUrl() getPeerTlsCertOpts() getMarbleUsernamesConfig() getCompanyNameFromFile() getMarblesPort() getEventsSetting() getKeepAliveMs() getFirstOrdererName() getOrderer() getOrderersUrl() getOrdererTlsCertOpts() getBlockDelay() getKvsPath() getFirstOrg() getClientsOrgName() getClientOrg() getMarbleUsernames() getOrgsMSPid() getAdminPrivateKeyPEM() getAdminSignedCertPEM() ----------------------------------- Server Up - localhost:3001 ----------------------------------- Welcome aboard: United Marbles Channel: mychannel Org: Org0MSP CA: fabric-ca-org1 Orderer: fabric-orderer Peer: fabric-peer-org1 Chaincode ID: marbles Chaincode Version: v4 ------------------------------------------ Websocket Up ------------------------------------------ debug: loading pem from a path: /home/bcuser/zmarbles/crypto-config/peerOrganizations/unitedmarbles.com/ca/ca.unitedmarbles.com-cert.pem debug: loading pem from a path: /home/bcuser/zmarbles/crypto-config/ordererOrganizations/blockchain.com/orderers/orderer.blockchain.com/tls/ca.crt debug: loading pem from a path: /home/bcuser/zmarbles/crypto-config/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/ca.crt info: [fcw] Going to enroll peer_urls=[grpcs://localhost:7051], channel_id=mychannel, uuid=marblesDockerComposeNetworkmychannelOrg0MSPfabricpeerorg1, ca_url=https://localhost:7054, orderer_url=grpcs://localhost:7050, enroll_id=admin, enroll_secret=adminpw, msp_id=Org0MSP, kvs_path=/home/bcuser/.hfc-key-store/marblesDockerComposeNetworkmychannelOrg0MSPfabricpeerorg1 debug: enroll id: \"admin\", secret: \"adminpw\" debug: msp_id: Org0MSP ca_name: ca-org0 info: [fcw] Successfully enrolled user 'admin' debug: added peer grpcs://localhost:7051 debug: [fcw] Successfully got enrollment marblesDockerComposeNetworkmychannelOrg0MSPfabricpeerorg1 info: Success enrolling admin debug: loading pem from a path: /home/bcuser/zmarbles/crypto-config/peerOrganizations/unitedmarbles.com/ca/ca.unitedmarbles.com-cert.pem debug: loading pem from a path: /home/bcuser/zmarbles/crypto-config/ordererOrganizations/blockchain.com/orderers/orderer.blockchain.com/tls/ca.crt debug: loading pem from a path: /home/bcuser/zmarbles/crypto-config/peerOrganizations/unitedmarbles.com/peers/peer0.unitedmarbles.com/tls/ca.crt debug: Checking if chaincode is already instantiated or not 1 info: Checking for chaincode... debug: [fcw] Querying Chaincode: read() debug: [fcw] Sending query req: chaincodeId=marbles, fcn=read, args=[selftest], txId=null debug: [fcw] Peer Query Response - len: 1 type: number debug: [fcw] Successful query transaction. ----------------------------- Chaincode found on channel \"mychannel\" ----------------------------- info: Checking chaincode and ui compatibility... debug: [fcw] Querying Chaincode: read() debug: [fcw] Sending query req: chaincodeId=marbles, fcn=read, args=[marbles_ui], txId=null warn: [fcw] warning - query resp is not json, might be okay: string 4.0.1 debug: [fcw] Successful query transaction. info: Chaincode version is good info: Checking ledger for marble owners listed in the config file info: Fetching EVERYTHING... debug: [fcw] Querying Chaincode: read_everything() debug: [fcw] Sending query req: chaincodeId=marbles, fcn=read_everything, args=[], txId=null debug: [fcw] Peer Query Response - len: 529 type: object debug: [fcw] Successful query transaction. debug: This company has registered marble owners debug: Looking for marble owner: amy debug: Did not find marble username: amy info: We need to make marble owners - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - info: Detected that we have NOT launched successfully yet debug: Open your browser to http://localhost:3001 and login as \"admin\" to initiate startup - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - The first line of the output just listed reads: [16:02:03] Using gulpfile ~/zmarbles/marblesUI/gulpfile.js I am not going to go into detail on the gulp tool here, but if you are curious, if you look into the gulpfile.js file (you would have to use another PuTTY or SSH session as this one is now tied up) you would find that a marbles1 task ( marbles1 being your argument to the gulp command) is defined: gulp.task('marbles1', ['env_tls', 'watch-sass', 'watch-server', 'server']); The marbles1 task specifies four more tasks to run, the first of which is env_tls . This task is adding a value to a map named env . This value points to the marbles1.json file: gulp.task('env_tls', function () { env['creds_filename'] = 'marbles1.json'; }); The last of the tasks, server , when it is started, is receiving this map named env as part of its invocation: gulp.task('server', function(a, b) { if(node) node.kill(); node = spawn('node', ['app.js'], {env: env, stdio: 'inherit'}); //command, file, options }); The syntax is a bit arcane, and this is not a course in JavaScript, but there is a line in the main file for the server, app.js , that reads this creds_filename value: var cp = require(__dirname + '/utils/connection_profile_lib/index.js')(process.env.creds_filename, logger); Then within utils/connection_profile_lib/index.js is where all the magic, a.k.a. code, happens to make use of the values specified in that file. You did not need to know all this to run the application, but you might need to know where to start looking when your boss asks you to tailor the marbles application because she wants a return on the time and money you spent taking this lab- assuming you don't get off the hook when you tell her that nowhere was JavaScript mentioned on the agenda. Step 3.3: Open up a web browser window or tab and point to http:// your_IP_goes_here>:3001 . Substitute your team's assigned IP address instead of your_IP_goes_here> . You should see a window pop up that looks like this: Step 3.4: You are given a choice between Express and Guided for setting up the demo. Don't short-change yourself- pick Guided , you'll learn more. After you click Guided , you will see this: Read the text in the window to see what's going on. Step 3.5: If you do not see Step 1 Complete , ask an instructor for help. Otherwise, click Next Step and you should see this: Click the '+' sign if you wish to see the settings used to contact the Fabric Certificate Authority. Step 3.6: If you do not see Step 2 Complete , ask an instructor for help. Otherwise, click Next Step and you should see this: Click the '+' sign to see information about your environment and your marbles chaincode. Step 3.7: If you do not see Step 3 Complete , ask an instructor for help. Otherwise, click Next Step and you should see this: Step 3.8: Unlike the first three steps, which did not require further input from you to complete, this step will not proceed until you click the Create button. Before you do that you have an opportunity to review and change the names that you use for new marbles owners in addition to the owner named 'Barry' that should already exist (though not evident from this screen) if you created it in the first part of this lab. Click the Create button when you are ready and after several seconds you should see Step 4 Complete on the screen: Step 3.9: If you do not see Step 4 Complete , ask an instructor for help. Otherwise, click Next Step and you should see this: This should just give you a smiley face and a message saying that setup is complete. Step 3.10: Click Enter and you should be returned to a screen that looks similar to this (your names may differ): Step 3.11: What about John's marble for Marbles Inc.? You only started up the server for United Marbles, so why does Marbles Inc show up and why is John so lonely? When you did the previous lab, the first two commands I had you do were an init_owner for John, tying him to Marbles Inc, and then an init_marble , giving him a marble. Remember, the \"blockchain\" is shared among all participants of the channel, so United Marbles and Marbles Inc both see the same chain- they see each other's marbles. But the user names specified in config/marbles2.json are not created until you start the server for marbles2 and log in the first time. List the contents of marbles2.json file (switch to a free terminal session or start a new one), e.g.: bcuser@ubuntu18042:~$ cd ~/zmarbles/marblesUI bcuser@ubuntu18042:~/zmarbles/marblesUI$ cat config/marbles2.json { \"cred_filename\": \"connection_profile2.json\", \"use_events\": false, \"keep_alive_secs\": 120, \"company\": \"Marbles Inc\", \"usernames\": [ \"cliff\", \"cody\", \"chuck\" ], \"port\": 3002, \"last_startup_hash\": \"\" } bcuser@ubuntu18042:~/zmarbles/marblesUI$ Step 3.12: Start the second server, the one for Marbles Inc: bcuser@ubuntu18042:~/zmarbles/marblesUI$ gulp marbles2 [16:07:49] Using gulpfile ~/zmarbles/marblesUI/gulpfile.js [16:07:49] Starting 'env_tls2'... [16:07:49] Finished 'env_tls2' after 50 \u03bcs [16:07:49] Starting 'build-sass'... [16:07:49] Finished 'build-sass' after 7.9 ms [16:07:49] Starting 'watch-sass'... [16:07:49] Finished 'watch-sass' after 6.38 ms [16:07:49] Starting 'watch-server'... [16:07:49] Finished 'watch-server' after 1.9 ms [16:07:49] Starting 'server'... info: Checking connection profile is done info: Loaded config file /home/bcuser/zmarbles/marblesUI/config/marbles2.json info: Loaded connection profile file /home/bcuser/zmarbles/marblesUI/config/connection_profile2.json Connection Profile Lib Functions:() getNetworkName() getNetworkCredFileName() buildTlsOpts() getFirstChannelId() getChannelId() loadPem() getMarblesField() getChaincodeId() getChaincodeVersion() getFirstCaName() getCA() getCasUrl() getAllCaUrls() getCaName() getCaTlsCertOpts() getEnrollObj() getFirstPeerName() getPeer() getPeersUrl() getAllPeerUrls() getPeerEventUrl() getPeerTlsCertOpts() getMarbleUsernamesConfig() getCompanyNameFromFile() getMarblesPort() getEventsSetting() getKeepAliveMs() getFirstOrdererName() getOrderer() getOrderersUrl() getOrdererTlsCertOpts() getBlockDelay() getKvsPath() getFirstOrg() getClientsOrgName() getClientOrg() getMarbleUsernames() getOrgsMSPid() getAdminPrivateKeyPEM() getAdminSignedCertPEM() ----------------------------------- Server Up - localhost:3002 ----------------------------------- Welcome aboard: Marbles Inc Channel: mychannel Org: Org1MSP CA: fabric-ca-org2 Orderer: fabric-orderer Peer: fabric-peer-org2 Chaincode ID: marbles Chaincode Version: v4 ------------------------------------------ Websocket Up ------------------------------------------ debug: loading pem from a path: /home/bcuser/zmarbles/crypto-config/peerOrganizations/marblesinc.com/ca/ca.marblesinc.com-cert.pem debug: loading pem from a path: /home/bcuser/zmarbles/crypto-config/ordererOrganizations/blockchain.com/orderers/orderer.blockchain.com/tls/ca.crt debug: loading pem from a path: /home/bcuser/zmarbles/crypto-config/peerOrganizations/marblesinc.com/peers/peer0.marblesinc.com/tls/ca.crt info: [fcw] Going to enroll peer_urls=[grpcs://localhost:9051], channel_id=mychannel, uuid=marblesDockerComposeNetworkmychannelOrg1MSPfabricpeerorg2, ca_url=https://localhost:8054, orderer_url=grpcs://localhost:7050, enroll_id=admin2, enroll_secret=adminpw2, msp_id=Org1MSP, kvs_path=/home/bcuser/.hfc-key-store/marblesDockerComposeNetworkmychannelOrg1MSPfabricpeerorg2 debug: enroll id: \"admin2\", secret: \"adminpw2\" debug: msp_id: Org1MSP ca_name: ca-org1 info: [fcw] Successfully enrolled user 'admin2' debug: added peer grpcs://localhost:9051 debug: [fcw] Successfully got enrollment marblesDockerComposeNetworkmychannelOrg1MSPfabricpeerorg2 info: Success enrolling admin debug: loading pem from a path: /home/bcuser/zmarbles/crypto-config/peerOrganizations/marblesinc.com/ca/ca.marblesinc.com-cert.pem debug: loading pem from a path: /home/bcuser/zmarbles/crypto-config/ordererOrganizations/blockchain.com/orderers/orderer.blockchain.com/tls/ca.crt debug: loading pem from a path: /home/bcuser/zmarbles/crypto-config/peerOrganizations/marblesinc.com/peers/peer0.marblesinc.com/tls/ca.crt debug: Checking if chaincode is already instantiated or not 1 info: Checking for chaincode... debug: [fcw] Querying Chaincode: read() debug: [fcw] Sending query req: chaincodeId=marbles, fcn=read, args=[selftest], txId=null debug: [fcw] Peer Query Response - len: 1 type: number debug: [fcw] Successful query transaction. ----------------------------- Chaincode found on channel \"mychannel\" ----------------------------- info: Checking chaincode and ui compatibility... debug: [fcw] Querying Chaincode: read() debug: [fcw] Sending query req: chaincodeId=marbles, fcn=read, args=[marbles_ui], txId=null warn: [fcw] warning - query resp is not json, might be okay: string 4.0.1 debug: [fcw] Successful query transaction. info: Chaincode version is good info: Checking ledger for marble owners listed in the config file info: Fetching EVERYTHING... debug: [fcw] Querying Chaincode: read_everything() debug: [fcw] Sending query req: chaincodeId=marbles, fcn=read_everything, args=[], txId=null debug: [fcw] Peer Query Response - len: 2291 type: object debug: [fcw] Successful query transaction. debug: This company has registered marble owners debug: Looking for marble owner: cliff debug: Did not find marble username: cliff info: We need to make marble owners - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - info: Detected that we have NOT launched successfully yet debug: Open your browser to http://localhost:3002 and login as \"admin\" to initiate startup - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - If you peek at your browser session from United Marbles, (port 3001), you will not notice any changes yet. Step 3.13: Open a browser tab or window and navigate to http:// your_IP_here>:3002 . You will again be given a choice of Express or Guided and feel free to choose whichever path suits your fancy. If you choose Express , everything should hopefully sail through until you see a screen with all Marbles Inc. owners and marbles, as well as all United Marbles owners and marbles: Step 3.14: If you go back to your screen for United Marbles (port 3001) you should observe that it has been updated to show the owners and marbles for Marbles Inc. in addition to United Marbles' own owners and marbles: Remember, you are looking at the United Marbles session but you see all the new users and marbles created by the Marbles Inc administrator. Step 3.15: Play with your marbles!! Here are some things you can do. When you do things as one user, e.g. as the United Marbles admin, go to the other user's screen to see that the changes one organization makes are visible to the other organization: On two different browser sessions, you should be logged in as the administrator for each of the two fictitious companies. When you are the United Marbles administrator, you can create marbles for you or anybody in United Marbles. You can delete marbles for you or anybody in United Marbles. You can take marbles from anybody in United Marbles and give them to anybody in the network, even to Marbles Inc people. (And vice versa when you are a Marbles Inc administrator). Try clicking on the little magnifying glass to the left of the browser window and follow the directions Right click on a marble (Hint: this is the same as using the magnifying glass) Click on the Settings button and Enable story mode. Try an action that is allowed, and try an action that shouldn't be allowed, such as trying to steal a marble from the other company. Disable story mode when it gets too tedious, which shouldn't take long. Step 3.16: If you want that extra rush, try these optional advanced assignments: Break out the previous lab's material and enter the cli container and issue some commands to create, update or delete marbles. See if the Marbles UI reflects your changes Look at some of the marbles chaincode container logs while you work with the Marbles UI - Hint: docker logs [-f] container_name will show a container's log. Try it without the optional -f argument first and then try it with it. -f ties up your terminal session but then shows new log messages as they are created. Press Ctrl-c to get out of it. Look at the peer or orderer logs while you work with the Marbles UI Click the Start Up Help button in the upper left in the Marbles UI and then number 4 in the window that pops up. Edit the list of names at the bottom and click Create . Do your new users show up in both companies' sessions? What happens if you add a name that exists already?","title":"Section 3: Start the Marbles user interface"},{"location":"hlf-part2/#section-4-lab-cleanup","text":"Step 4.1: In both of your terminals sessions that were used to start each Web UI, press Crtl-c to end the Web UI process. You can also close the tabs in your browser that were displaying the Web UI. Step 4.2: Navigate to the zmarbles directory: bcuser@ubuntu18042:~/zmarbles/marblesUI$ cd ~/zmarbles bcuser@ubuntu18042:~/zmarbles$ Step 4.3: Enter this Docker command to show the running Docker containers that make up your Hyperledger Fabric network: bcuser@ubuntu18042:~/zmarbles$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1e5c05183d6f dev-peer1.unitedmarbles.com-marbles-1.0-dea1aa08dc7c6f282a31dd498670173c21d3e75ef0ef1d170b95e1212fbacb77 \"chaincode -peer.add\u2026\" 26 minutes ago Up 26 minutes dev-peer1.unitedmarbles.com-marbles-1.0 a7d6b658a35a dev-peer0.marblesinc.com-marbles-1.0-4077677f13838bacbfd8ff943e7348c00f3c4d6ca6e2838efd14204ca87ea12b \"chaincode -peer.add\u2026\" 31 minutes ago Up 31 minutes dev-peer0.marblesinc.com-marbles-1.0 62a185d148d2 dev-peer0.unitedmarbles.com-marbles-1.0-7e92f069adb7469939a96dcba723fa2019745461f05a562e81cec38e46424aa1 \"chaincode -peer.add\u2026\" 39 minutes ago Up 39 minutes dev-peer0.unitedmarbles.com-marbles-1.0 84b6c0ee74aa hyperledger/fabric-tools:1.4.1 \"bash\" About an hour ago Up About an hour cli e6eabd9fd96d hyperledger/fabric-peer:1.4.1 \"peer node start\" About an hour ago Up About an hour 0.0.0.0:9051- 7051/tcp, 0.0.0.0:9052- 7052/tcp, 0.0.0.0:9053- 7053/tcp peer0.marblesinc.com 8174f3021744 hyperledger/fabric-peer:1.4.1 \"peer node start\" About an hour ago Up About an hour 0.0.0.0:8051- 7051/tcp, 0.0.0.0:8052- 7052/tcp, 0.0.0.0:8053- 7053/tcp peer1.unitedmarbles.com 1a22b9eb5be5 hyperledger/fabric-peer:1.4.1 \"peer node start\" About an hour ago Up About an hour 0.0.0.0:10051- 7051/tcp, 0.0.0.0:10052- 7052/tcp, 0.0.0.0:10053- 7053/tcp peer1.marblesinc.com 11423ca89763 hyperledger/fabric-peer:1.4.1 \"peer node start\" About an hour ago Up About an hour 0.0.0.0:7051-7053- 7051-7053/tcp peer0.unitedmarbles.com 18b9e5efbfc9 hyperledger/fabric-couchdb:s390x-0.4.15 \"tini -- /docker-ent\u2026\" About an hour ago Up About an hour 4369/tcp, 9100/tcp, 0.0.0.0:6984- 5984/tcp couchdb1 77288f8c0060 hyperledger/fabric-couchdb:s390x-0.4.15 \"tini -- /docker-ent\u2026\" About an hour ago Up About an hour 4369/tcp, 9100/tcp, 0.0.0.0:7984- 5984/tcp couchdb2 43214da184da hyperledger/fabric-ca:1.4.1 \"sh -c 'fabric-ca-se\u2026\" About an hour ago Up About an hour 0.0.0.0:7054- 7054/tcp ca_Org0 1ea639c77a3a hyperledger/fabric-ca:1.4.1 \"sh -c 'fabric-ca-se\u2026\" About an hour ago Up About an hour 0.0.0.0:8054- 7054/tcp ca_Org1 07df27e35368 hyperledger/fabric-couchdb:s390x-0.4.15 \"tini -- /docker-ent\u2026\" About an hour ago Up About an hour 4369/tcp, 9100/tcp, 0.0.0.0:8984- 5984/tcp couchdb3 93e0465394b6 hyperledger/fabric-orderer:1.4.1 \"orderer\" About an hour ago Up About an hour 0.0.0.0:7050- 7050/tcp orderer.blockchain.com 4201915cc3b2 hyperledger/fabric-couchdb:s390x-0.4.15 \"tini -- /docker-ent\u2026\" About an hour ago Up About an hour 4369/tcp, 9100/tcp, 0.0.0.0:5984- 5984/tcp couchdb0 bcuser@ubuntu18042:~/zmarbles$ Step 4.4: Enter this command to bring down your Hyperledger Fabric network: bcuser@ubuntu18042:~/zmarbles$ docker-compose down WARNING: The CHANNEL_NAME variable is not set. Defaulting to a blank string. Stopping cli ... done Stopping peer0.marblesinc.com ... done Stopping peer1.unitedmarbles.com ... done Stopping peer1.marblesinc.com ... done Stopping peer0.unitedmarbles.com ... done Stopping couchdb1 ... done Stopping couchdb2 ... done Stopping ca_Org0 ... done Stopping ca_Org1 ... done Stopping couchdb3 ... done Stopping orderer.blockchain.com ... done Stopping couchdb0 ... done Removing cli ... done Removing peer0.marblesinc.com ... done Removing peer1.unitedmarbles.com ... done Removing peer1.marblesinc.com ... done Removing peer0.unitedmarbles.com ... done Removing couchdb1 ... done Removing couchdb2 ... done Removing ca_Org0 ... done Removing ca_Org1 ... done Removing couchdb3 ... done Removing orderer.blockchain.com ... done Removing couchdb0 ... done Removing network zmarbles_default bcuser@ubuntu18042:~/zmarbles$ Step 4.5: Enter this and you should not see any running Docker containers: bcuser@ubuntu18042:~/zmarbles$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES bcuser@ubuntu18042:~/zmarbles$ Step 4.6: Add the --all argument to the prior command and you will see some Exited Docker containers: bcuser@ubuntu18042:~/zmarbles$ docker ps --all CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1e5c05183d6f dev-peer1.unitedmarbles.com-marbles-1.0-dea1aa08dc7c6f282a31dd498670173c21d3e75ef0ef1d170b95e1212fbacb77 \"chaincode -peer.add\u2026\" 28 minutes ago Exited (0) About a minute ago dev-peer1.unitedmarbles.com-marbles-1.0 a7d6b658a35a dev-peer0.marblesinc.com-marbles-1.0-4077677f13838bacbfd8ff943e7348c00f3c4d6ca6e2838efd14204ca87ea12b \"chaincode -peer.add\u2026\" 33 minutes ago Exited (0) About a minute ago dev-peer0.marblesinc.com-marbles-1.0 62a185d148d2 dev-peer0.unitedmarbles.com-marbles-1.0-7e92f069adb7469939a96dcba723fa2019745461f05a562e81cec38e46424aa1 \"chaincode -peer.add\u2026\" 41 minutes ago Exited (0) About a minute ago dev-peer0.unitedmarbles.com-marbles-1.0 bcuser@ubuntu18042:~/zmarbles$ Step 4.7: Enter this command to remove these containers: bcuser@ubuntu18042:~/zmarbles$ docker rm $(docker ps --all --quiet) 1e5c05183d6f a7d6b658a35a 62a185d148d2 bcuser@ubuntu18042:~/zmarbles$ Step 4.8: Repeat the command from Step 4.6 and you should not see any containers: bcuser@ubuntu18042:~/zmarbles$ docker ps --all CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES bcuser@ubuntu18042:~/zmarbles$ Step 4.9: List your Docker images: bcuser@ubuntu18042:~/zmarbles$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE dev-peer1.unitedmarbles.com-marbles-1.0-dea1aa08dc7c6f282a31dd498670173c21d3e75ef0ef1d170b95e1212fbacb77 latest c0e41de218a2 30 minutes ago 137MB dev-peer0.marblesinc.com-marbles-1.0-4077677f13838bacbfd8ff943e7348c00f3c4d6ca6e2838efd14204ca87ea12b latest ab7f5fa821ee 35 minutes ago 137MB dev-peer0.unitedmarbles.com-marbles-1.0-7e92f069adb7469939a96dcba723fa2019745461f05a562e81cec38e46424aa1 latest d41acea306aa 43 minutes ago 137MB hyperledger/fabric-ca 1.4.1 a836041637e8 2 weeks ago 220MB hyperledger/fabric-tools 1.4.1 330902566372 2 weeks ago 1.52GB hyperledger/fabric-ccenv latest 8583516cfc43 2 weeks ago 1.41GB hyperledger/fabric-orderer 1.4.1 1b709e319b2d 2 weeks ago 148MB hyperledger/fabric-peer 1.4.1 719392658c28 2 weeks ago 154MB hyperledger/fabric-couchdb s390x-0.4.15 81ee917e0be2 5 weeks ago 1.55GB hyperledger/fabric-baseos s390x-0.4.15 d4eb16b952d6 5 weeks ago 120MB bcuser@ubuntu18042:~/zmarbles$ Step 4.10: This command will format the output from docker images : bcuser@ubuntu18042:~/zmarbles$ docker images --format '{{.Repository}}:{{.Tag}}' dev-peer1.unitedmarbles.com-marbles-1.0-dea1aa08dc7c6f282a31dd498670173c21d3e75ef0ef1d170b95e1212fbacb77:latest dev-peer0.marblesinc.com-marbles-1.0-4077677f13838bacbfd8ff943e7348c00f3c4d6ca6e2838efd14204ca87ea12b:latest dev-peer0.unitedmarbles.com-marbles-1.0-7e92f069adb7469939a96dcba723fa2019745461f05a562e81cec38e46424aa1:latest hyperledger/fabric-ca:1.4.1 hyperledger/fabric-tools:1.4.1 hyperledger/fabric-ccenv:latest hyperledger/fabric-orderer:1.4.1 hyperledger/fabric-peer:1.4.1 hyperledger/fabric-couchdb:s390x-0.4.15 hyperledger/fabric-baseos:s390x-0.4.15 bcuser@ubuntu18042:~/zmarbles$ Step 4.11: The output from the prior step is in a format acceptable to the Docker command to remove images, so this command will feed that output into the Docker rmi command, and remove these images: bcuser@ubuntu18042:~/zmarbles$ docker rmi $(docker images --format '{{.Repository}}:{{.Tag}}') Untagged: dev-peer1.unitedmarbles.com-marbles-1.0-dea1aa08dc7c6f282a31dd498670173c21d3e75ef0ef1d170b95e1212fbacb77:latest Deleted: sha256:c0e41de218a260a73053d538aa45ca0f925cd3ee7d8898151ea7df39dc1ac813 Deleted: sha256:40fc70560501ded0fbf1d7bc6a2e77de321041a62770822f692977cd363f16be Deleted: sha256:4a8c59ccf0d503088d13b041260d4741509656336b431e6bb7e64b20a91b90fb Deleted: sha256:8ce2cde820ef4ccfef99f8389315141614441b89219de487da33db3494874c8b Untagged: dev-peer0.marblesinc.com-marbles-1.0-4077677f13838bacbfd8ff943e7348c00f3c4d6ca6e2838efd14204ca87ea12b:latest Deleted: sha256:ab7f5fa821ee42c139722b2360909c95c1b2586cb437686122af1e571bd34802 Deleted: sha256:f7a0e17801a42a44340f27cb7c7332314534d1ed2d4573cb5334f27289dc5ff0 Deleted: sha256:8085444130169915f706aecfac10aaeee4d3e641e63e4686258c513e6fe85830 Deleted: sha256:e0f59705093caa197dde37fba5d05aa4635465b5d42e8d48234b9a28d3423a48 Untagged: dev-peer0.unitedmarbles.com-marbles-1.0-7e92f069adb7469939a96dcba723fa2019745461f05a562e81cec38e46424aa1:latest Deleted: sha256:d41acea306aa6d858cca4f55bb92b20335da5a588550411d32fc77def25d3775 Deleted: sha256:493804d997703675b48104eed5e6868b1e6f14bf954fbb56ac5784a82838ccbf Deleted: sha256:3504ecc13cf81ec4947132a9261600f1e9cdeee94672df62469f2061bd1a4b2a Deleted: sha256:8267b35c52b6b78b7341b95c5c044a69feb53075c704b2eea87a4d4b6036be06 Untagged: hyperledger/fabric-ca:1.4.1 Untagged: hyperledger/fabric-ca@sha256:f77aa0ff885c572b090d1ff7564780daafd50d9e839b6241c2ab12c37f47b94a Deleted: sha256:a836041637e817846f71541e47e8749f6188676a1ac282f006ca03758290f4ff Deleted: sha256:8fa3260318e50be92f0118657fa3aa395e264cfa2fbe0dbedb9419fff1547bfd Deleted: sha256:f0c44e96c65ce80eaeb561f89fa23ae82c5af54b1b1b050ecadd827b45bebd23 Deleted: sha256:e2e8ca9c5a2fb8c69e32428be2f27d6bb0c1e1b7e58af5d4d5aa788ce8d9fd68 Deleted: sha256:a353d8ddb009e3c0dd6bd0558a1e3ed847951f42ae632a91ad49029bb69b9fc0 Deleted: sha256:f1079f0f139b61ea01f32de10d58de81e1fc393038d3fa774221a736f942023f Deleted: sha256:165d46e0e538aacfcecf19a4088c2e7b490384e7b3cecb090a16b19cba8722d9 Deleted: sha256:85fb95169355a4e6fcd52672b1e60739f120ee9e541413732cb53d8e5c97beae Untagged: hyperledger/fabric-tools:1.4.1 Untagged: hyperledger/fabric-tools@sha256:c458ddc3109d3519b209baaf9abff113641267ec2adb01dfdcf8f4c9e77a2fa0 Deleted: sha256:330902566372ecfc06a396c05d026a0d17fa40379dc1327894869ad370023637 Deleted: sha256:1021b7b3b232c0954f944c6d2baec3ef80dc9481bcabea5a12db4f7d276c86f7 Deleted: sha256:9427db3491c3adcb8cecfcf50bb3c8deeab27d3739538c2cd246ee6b856515a9 Deleted: sha256:dba040b6371fcdc2b78128d10e952cc716b75ba67f2dc330086c908fb830fa1d Untagged: hyperledger/fabric-ccenv:latest Untagged: hyperledger/fabric-ccenv@sha256:bb929eef560b50e0fbd730c6b195e49fece28dd4612ec30db0ce2cc096483463 Deleted: sha256:8583516cfc43491e2db2e393408121b85636f622d39d2a8e3c46ac278d3d3ce2 Deleted: sha256:3d53a661451588e08ea4f0b1e6fac40633b4dcef9fb895ad12f9309453d85dfa Deleted: sha256:04e554cb54244558f5567c17ebcb7a02b64822036ece595fefb4f98d2ab31a7a Deleted: sha256:a2ec3c9f4ab3e2a789239638d99aa4a760998c8424d29313d5461bcfd2929612 Untagged: hyperledger/fabric-orderer:1.4.1 Untagged: hyperledger/fabric-orderer@sha256:09f31ca4dabe1eb2af870ea062561ca6686fc59a296ecc3b4bd7e32102c48934 Deleted: sha256:1b709e319b2d2e7d137112ff5e24b7b6a0ddf0a5bf8843c47adfc9095b3f8778 Deleted: sha256:43747e128cff58f58f5642bce1b27613ecb3dec5aa8fc7caf0ce5e2397415371 Deleted: sha256:fb1a267f0371757e83dcf6221291269b29a7089a0f7a8545ff3f538509e19e0e Untagged: hyperledger/fabric-peer:1.4.1 Untagged: hyperledger/fabric-peer@sha256:05315d05b2892d34b4ed48f6502d28fe15a71090c36a39c97022a44475a984ad Deleted: sha256:719392658c28f69bb25ccc71a8da86050f646f4ffaf51a279cdcea079b5f993e Deleted: sha256:04d6dbf6b6fcdaaedb6d55a021bd1dcb0695ecfbe9e2538fe2dd1365987eea0b Deleted: sha256:4c58d7859aeaf30d72dada842ce28df9d542e2ffc1ab2213b81483f080adceef Deleted: sha256:6299707a98af34860777b48b86df6ec7ae8cf45ae76cbf4cbedcb1dc55888061 Untagged: hyperledger/fabric-couchdb:s390x-0.4.15 Untagged: hyperledger/fabric-couchdb@sha256:e8701a2dd7400d200a6c3b1ffd42331e2d5255d30c1efb117fc5a10bbf9063b6 Deleted: sha256:81ee917e0be2fe0b5f46cf6ed34d32169118c8d995cee636ce47ffb96d3afd95 Deleted: sha256:e4cdccb03102bce02d4e9179cf1eed5808e97bb77fb7bf7596776900caf3f22a Deleted: sha256:12e70245586bf85d0f2eabc4ba33c1df77d51e604c294551e43c9dec425f619c Deleted: sha256:f7a35da6c7b30fa6fa11e2f6e44938ea4df158db403064832a73d1e9b11aa719 Deleted: sha256:1b774897931652fde3bb2609e0f46fa4c3a3f522db395359a2aeee1a218aab54 Deleted: sha256:1132017bbb8c969f03a11ec80e77eea71a3fc54dbae9e2b588b01fc5c0502972 Deleted: sha256:de23c4b00ab7d92310f73b45cacf5b861a8f40c5b069c0660eb1bc6d472c98e7 Deleted: sha256:62306dc38b9fc0fb7922d4d1358d135e1c7411b01e51bb631fc5269308387c42 Deleted: sha256:8bc0cb77c66908a5059433ca0b41f453721de3bc529ecc258ff91818ce19e87f Deleted: sha256:8445d7f0d5111f5ee7fe4ada50d718df0977e9b071045e09b3d619effd16d7e0 Deleted: sha256:f593f65839abaaf5f0c18604b7f065b4cab58bfeafa867b7be75fc6ca52e187a Deleted: sha256:18eaede2be21b8fdba162857cbf79ce9a04cb2671da8c40dc804280e791e9742 Deleted: sha256:ef88e98e5731409ad689aec3233fcca8d5f1b38e435558308d8289fb3d5a5383 Deleted: sha256:9941b43bff58fff3234b1f356d65f1d383265156c82ba90805a00ba758e5fa14 Deleted: sha256:31699b2e24542ffbc8cf9678644e62ab195263be033713327992314d59ddffbb Untagged: hyperledger/fabric-baseos:s390x-0.4.15 Untagged: hyperledger/fabric-baseos@sha256:94fefcbeb2c0da7ac6371ad589b66b2bbe7cfb76bf28ba7aaf85790bed82c839 Deleted: sha256:d4eb16b952d6c8b742cbe47caf6522c71f9b1654a31abc582918905d64db07e7 Deleted: sha256:234cfc5f3368cd92d65d03e5da6bc0bd985ab94c4931e692faa758bd6d811c7b Deleted: sha256:3e2d2d75f895801cefdecac9e2584d964caf0ed7fb1d8afeffeaea5e287ea9cb Deleted: sha256:d8e11f36fc45b7073d3b0eb3636428dedebb40f392bea9fa5751ed92848ca875 bcuser@ubuntu18042:~/zmarbles$ Step 4.12: Now you should not see any images: bcuser@ubuntu18042:~/zmarbles$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE bcuser@ubuntu18042:~/zmarbles$ IMAGE ID CREATED SIZE Step 4.13: You may type exit from your terminal session(s) to log out of the system bcuser@ubuntu18042:~/zmarbles$ exit logout Connection to 192.168.22.1xx closed. Barrys-MacBook-Pro:ImmersionWorkshop silliman$ End of lab!","title":"Section 4: Lab cleanup"},{"location":"ibpconsole/","text":"IBM Blockchain Platform v2.1.3 Lab Part 1 - Create a Blockchain Network Section 1: Create a Blockchain Network lab overview You will use the IBM Blockchain Platform console in this lab to create a blockchain network. The network will consist of three organizations. Two of these organizations will represent organizations that want to participate in the blockchain network and submit transactions. They will be referred to as peer organizations throughout the lab. The third organization is the organization that provides the ordering service. First you will create one peer organization. Then you will create an ordering service organization, create a channel and add your first peer organization to the channel. Then you will create a second peer organization, and add it to the channel. Each high-level task is detailed in a separate section, with multiple steps per task. The diagram below provides a view of what your blockchain network will look like upon completion of the lab: Important You will be assigned a two-digit team ID by your instructor, and everywhere in this lab where you see Team xx in the instructions, you must substitute xx with the two-digit id you have been assigned. The sections in this lab are as follows: Section 1: This overview Section 2: Logging in to the IBM Blockchain Platform console Section 3: Creating a Certificate Authority for your first peer organization, \"Team xx Org1\" Section 4: Adding new users using your Team xx Org1 Certificate Authority Section 5: Creating an MSP for your Team xx Org1 organization Section 6: Creating a peer node for your Team xx Org1 organization Section 7: Creating a Certificate Authority for an Ordering Service organization Section 8: Adding new users using your Ordering Service Certificate Authority Section 9: Creating an MSP for your Ordering Service organization Section 10: Creating an ordering service node for your Ordering Service organization Section 11: Adding your Team xx Org1 organization to a consortium Section 12: Creating a channel Section 13: Joining your Team xx Org1 peer to the channel Section 14: Creating a Certificate Authority for your second peer organization, \"Team xx Org2\" Section 15: Adding new users using your Team xx Org2 Certificate Authority Section 16: Creating an MSP for your Team xx Org2 organization Section 17: Creating a peer node for your Team* xx Org2 organization Section 18: Adding your Team xx Org2 organization to the consortium Section 19: Adding your Team xx Org2 organization to the channel Section 20: Joining your Team xx Org2 peer to the channel Section 2: Log in to the IBM Blockchain Platform console Important The lab environment is using self-signed SSL certificates and your browser will not trust them without explicit action on your part so part of this initial section on logging in involves establishing this trust. You will first need to go to the URL address provided by your instructor. Step 2.1: Open a new tab in your Firefox browser window and enter the unique URL for your IBM Blockchain Platform console. This URL will be provided to you by your instructor. Note Your URL will similar to https://workshop-00-ibpconsole-console.apps.atsocpd3.dmz:443 , but this is just an example, so make sure you use the actual URL given to you by your instructor! If you see a security warning after entering the URL, click the Advanced button, which is highlighted in the below screen snippet: Step 2.2: The reason you are seeing these security messages is because of a self-signed certificate in our lab environment. Go ahead and click on the Accept the Risk and Continue button that is shown below: Step 2.3: Enter your team's userid and password, which will have been provided to you by the instructor, and click the Login button: Step 2.4: You may be presented with a screen asking you to change your password. If not, skip ahead to Step 2.5 . If so, enter your current password, and then a new password twice. Click the Change password button, which will turn blue and be enabled once you have entered matching values in the New password and the Confirm new password fields. Your new password must be at least eight characters in length. Upon successful password change, you will be presented with the Login screen again, as in Step 2.3 . Log in again with your new password. Step 2.5: You may be presented with a welcome screen with some informative interactive graphics. Move your cursor around a bit to see them, and then click the Let's get started button in the lower right corner. Note If you do not see this welcome screen with the graphics, you can view it at any time by clicking the Get started link at the top of your screen, and then clicking the Understand box on the left. Section 3: Create a Certificate Authority for your first peer organization, \"Teamxx Org1\" In a Hyperledger Fabric network, each organization will typically have their own certificate authority. The certificate authority is used to issue identities- consisting of X.509 public certificates and matching private keys- for end users, client applications, administrators, and peer and ordering service nodes. In most uses cases each organization will want to have control over the identities they issue, so the typical practice is that each organization provides their own certificate authority. We will follow that practice in this lab. You are starting with a blank slate, and our first component to add is the certificate authority for our first peer organization. In relation to the diagram in the overview section that showed our finished network upon successful lab completion, here is the component that will be added in this section: Step 3.1: You will be on a screen which lets you define three types of nodes- Peers , Certificate Authorities , and Ordering services . Click the blue Add Certificate Authority button: Information This will be transparent to you as a user of the IBM Blockchain Platform Console, but each individual node that you create during the lab will result in the creation of a Kubernetes pod , which is a collection of one or more containers , on a worker node in a Red Hat OpenShift Container Platform cluster. Step 3.2: Click Create a Certificate Authority and then click the blue Next button: Step 3.3: Fill in the Step 2 of 3 screen as follows, and then click the blue Next button: Field label Value Comments CA display name Team xx Org1 CA Substitute your two-digit team ID for xx CA administrator enroll ID admin CA administrator enroll secret adminpw Important Leave the checkboxes in the Advanced deployment options section unchecked. You may click on the small information icon to the right of each choice if you would like to learn about each option, but you do not need to do so to successfully complete the lab. This advice is applicable for all steps throughout this lab that offer advanced deployment option choices. Step 3.4: Review your settings on the Step 3 of 3 screen and click the Add Certificate Authority button: Note Throughout this lab, when passwords are entered, you can click the icon that looks like an eye to see the password you have entered. It is recommended that you do this for the lab to ensure you have entered the intended password. The screenshots shown in this lab will show the passwords that you should enter. Step 3.5: You will see a tile for your new certificate authority. Observe the box in the upper right corner of the tile. If it is gray, and you hover your cursor over it, you may see a message indicating that the status is pending. In about a minute, the box in the upper right should turn green, indicating that the certificate authority is running. Note If the box in the upper right corner of the tile does not turn green in a minute or two, try reloading the page in your browser. Contact an instructor for help if it does not turn green and show the running status when you hover your cursor over this box. Once your certificate authority is running, click on its tile so that you can proceed to the next section where you will add users. Section 4: Add new users using your Team xx Org1 Certificate Authority Step 4.1: You must first associate an administrative identity with your certificate authority, so click the Associate identity button as shown in this screen snippet: Step 4.2: Ensure that the Enroll ID Button is selected in the Associate Identity sidebar panel, fill out the panel as directed in the below table, and then click the blue Associate Identity button: Field label Value Comments Enroll ID admin Enroll secret adminpw click the \"eye\" icon to see the password Identity display name Team xx Org1 CA Admin substitute your two-digit team ID for xx Step 4.3: You should now see the admin userid in the list of registered users. This userid is intended to be used by a person acting as the registrar of this Certificate Authority. Next you will create a userid for use by a person who will be the blockchain network administrator for the organization. Click the Register user button on the right side of the screen: Step 4.4: In the Step 1 of 2 panel, fill it out as guided by the following table, and then click the blue Next button: Field label Value Comments Enroll ID org1admin Enroll secret org1adminpw click the \"eye\" icon to see the password Type admin Choose from dropdown list Step 4.5: We will not be using custom attributes in this lab, so all you have to do on this screen is click the Register user button: Step 4.6: You should now see the userid you just registered, org1admin , listed on the screen. You also need to create a userid that your peer node will operate as, so click the Register user button again: Step 4.7: In the Step 1 of 2 panel, fill it out as guided by the following table, and then click the blue Next button: Important It is critical that you change the value of the Type field from client to peer for this userid! Field label Value Comments Enroll ID peer1 Enroll secret peer1pw click the \"eye\" icon to see the password Type peer Choose from dropdown list Step 4.8: Just click the Register user button at the bottom of the screen: Step 4.9: You should now see the peer1 userid listed along with the others on this screen. Click the Organizations icon on the palette on the left of your screen and continue to the next section of the lab: Section 5: Create an MSP for your organization The Membership Service Provider (MSP) component is integral to the private and permissioned Hyperledger Fabric as it provides the authentication- \"who are you?\"- and authorization - \"ok, we believe you are whom you say you are, but are you permitted to do what you are asking to do?\"- services. The infrastructure that the MSP needs to do its job must be in place before you create your peer node. This step will create this for your \"Team xx Org1\" organization. As we add components throughout the lab, the diagram that maps to our final goal will be shown, with the new component to be added in any given section annotated with a bright red star, as in the below diagram which shows that we will be adding your Team xx Org1 's MSP: Step 5.1: You should see a screen that looks like below, indicating that you have yet to create a Membership Service Provider (MSP) definition for your organization. Click the Create MSP definition button: Step 5.2: Enter the following values as instructed here on the MSP definition details screen and click the Next button: Field label Value Comments MSP display name Team xx Org1 MSP substitute your two-digit team ID for xx MSP ID teamxxorg1msp substitute your two-digit team ID for xx Step 5.3: On the Root Certificate Authority details screen, select Team xx Org1 CA from the dropdown list. Once you have selected the root certificate authority, you will see that the Root certificates and TLS root certificates fields appear and are populated with apparent nonsense that is actually base64-encoded X.509 certificates. Click the Next button: Step 5.4: On the Admin certificates screen, fill out the three fields beneath this in accordance with the below table, and then click the Generate button, which should become active once you enter values for the three fields: Field label Value Comments Enroll ID org1admin Select from dropdown list. It will not be the default presented to you, so make sure you select it. Enroll secret org1adminpw Identity name Team xx Org1 MSP Admin substitute your team ID for xx Step 5.5: The prior step generated a public certificate and a matching private key. This private key is stored by the IBM Blockchain Platform console in your local browser storage and nowhere else. In order to ensure that you can retrieve your private key later, you must now click the Export button which will prompt you to save your private key (along with the public certificate) in a JSON file on your hard drive. Step 5.6: Select the Save File radio button in the dialog window that appears, and click the OK button: Step 5.7: Save the exported JSON file in a location that you can remember. The sample screenshot below shows it being saved to a folder named Downloads . Note You probably won't need this saved file for this lab if you use the same browser window for the duration of the lab, but the saved file may be necessary if, for whatever reason, you do have to use a new browser window or session, so go ahead and save it! Step 5.8: Now that you have saved the exported certificate, click the blue Next button to proceed: Step 5.9: On the Review MSP information screen, ensure that the values you entered match what is shown in the following table, taking into account that xx should be your two-digit team ID: Left column (labels) Right column (values your provided) MSP display name Team xx Org1 MSP MSP ID teamxxorg1msp Admin certificate Team xx Org1 MSP Admin Selected CA Team xx Org1 CA Note If you entered some values incorrectly, click the Back button as necessary to navigate back through the screen flow until you get to the screen(s) necessary to correct your mistakes, and then navigate forward again with the Next button until you return to this Review MSP information screen and verify you have entered the expected values. Ask an instructor for help if necessary. When you have ensured that you have entered the right values, click the blue Create MSP definition button in the lower right of your screen: Step 5.10: You should now see the definition for your new MSP listed on your screen. Click the Nodes icon in the icon palette on your left- it is the topmost icon on this palette, and you will be ready to proceed to the next section: Section 6: Create a peer node for your Teamxx Org1 organization A peer node is where smart contracts- in essence, your blockchain business transactions- run. Peer nodes also store the ledgers. We will create a peer for your Team xx Org1 in this section and our fledgling network will then look like this: Step 6.1: Click the Add peer button: Step 6.2: Click the Create a peer button and then click the blue Next button: Step 6.3: Leave all of the Advanced deployment options unchecked. Type Team xx Org1 Peer , where xx is your two-digit team ID, in the Peer display name field and then click the blue Next button: Step 6.4: Enter or select the following values on the Step 3 of 5 panel as directed by the following table, and then click the blue Next button: Field label Value Comments Certificate Authority Team xx Org1 CA Select from dropdown list if this choice is not already presented to you, where xx is your two-digit team ID Peer enroll ID peer1 Select from dropdown list Peer enroll secret peer1pw Organization MSP Team xx Org1 MSP Select from dropdown list, where xx is your two-digit team ID TLS CSR hostname leave blank Step 6.5: On the Associate Identity screen, select Team xx Org1 MSP Admin , where xx is your two-digit team ID, for the Peer administrator identity field, and click Next : Step 6.6: The Summary panel provides a review of the values you entered or selected in the prior panels. You may need to scroll down to see all of the values. The values you entered should match up with the table below. If not, use the Back button as necessary to correct your entries. The table below shows the expected value (where xx is your two-digit team ID) and which of the seven panels in the Add Peer flow was used to set this value: Field label Expected Value Comments Peer display name Team xx Org1 Peer Set in Step 2 of 5 panel State database CouchDB Not set by you- default value Certificate Authority Team xx Org1 CA Set in Step 3 of 5 panel Peer enroll ID peer1 Set in Step 3 of 5 panel Peer enroll secret peer1pw Set in Step 3 of 5 panel Organization MSP Team xx Org1 MSP Set in Step 3 of 5 panel CPU (VPC) usage total 1.6 Not set by you- calculated from defaults Memory usage total 2,800M Not set by you- calculated from defaults Storage usage total 200Gi Not set by you- calculated from defaults Associated identity Team xx Org1 MSP Admin Set in Step 4 of 5 panel Note If you have to use the Back button to make any corrections, you can return to the summary on Step 5 of 5 by clicking Next the necessary number of times. When you have ensured that you have entered the right values, click the blue Add peer button in the lower right of your screen: Step 6.7: Similarly to when you created the certificate authority earlier, you should see your new peer listed, along with a gray box in the upper right of its tile, showing that the status of this peer is \"pending\" if you hover your cursor over the gray box. It can take a minute or two on our lab system for the peer to come up completely, and you may need to refresh your browser in order to see the box turn green. If your peer is still not ready after a couple of minutes and after you have tried refreshing your browser, ask an instructor for help. The peer must be ready, as indicated by a green box in the upper right of the peer's tile, similar to what is shown below, before you can continue: Section 7: Create a Certificate Authority for an Ordering Service organization In this lab you will create three organizations- two organizations will run peer nodes and run smart contracts. One of the organizations will provide the ordering service for the blockchain network. In the real world each of the three organizations would likely use their own instance of the IBM Blockchain Platform console to create their necessary artifacts. (You have already done much of this for the first peer organization, Team xx Org1 , in the previous sections of this lab). Note You will carry out activities for all three organizations from your browser for purposes of this lab. This will somewhat simplify the steps you'll need to perform versus the real-world scenario where this activity is being carried out separately by each organization. The procedure to perform the tasks in the \"real world\" case are outlined in the IBM Blockchain Platform documentation- basically, it involves exporting information about your organization into JSON files, and providing this information \"out-of-band\" to the other organizations. In an earlier step you exported your generated certificate and its private key. While it is a JSON file, this is not a file you would ever send to another organization, as it contains your private key which should never be shared with other organizations. The exported JSON files that are used for inter-organizational tasks contain only public information which is safe to share. Our network will look like this at the completion of this section: Step 7.1: Click the Add Certificate Authority button: Step 7.2: Click Create a Certificate Authority and then click the blue Next button: Note The steps in this section are essentially the same as in Section 3 , just with different values being entered as appropriate. Step 7.3: Fill in the Step 2 of 3 screen as follows, and then click the blue Next button: Field label Value Comments CA display name Team xx Ordering Service CA Substitute your two-digit team ID for xx CA administrator enroll ID admin CA administrator enroll secret adminpw Step 7.4: Review your settings and click the Add Certificate Authority button: Step 7.5: You will see a tile for your new certificate authority. Observe the box in the upper right corner of the tile. If it is gray, and you hover your cursor over it, you may see a message indicating that the status is pending. In about a minute, the box in the upper right should turn green, indicating that the certificate authority is running. Note If the box in the upper right corner of the tile does not turn green in a minute or two, try reloading the page in your browser. Contact an instructor for help if it does not turn green and show the running status when you hover your cursor over this box. Once your Ordering Service certificate authority is running, click on its tile so that you can proceed to the next section where you will add users. Section 8: Add new users using your Ordering Service Certificate Authority Step 8.1: You must first associate an administrative identity with your certificate authority, so click the Associate identity button as shown in this screen snippet: Step 8.2: Ensure that the Enroll ID Button is selected in the Associate Identity sidebar panel, fill out the panel as directed in the below table, and then click the blue Associate Identity button: Field label Value Comments Enroll ID admin Enroll secret adminpw click the \"eye\" icon to see the password Identity display name Team xx Ordering Service CA Admin substitute your two-digit team ID for xx Step 8.3: You should now see the admin userid in the list of registered users. This userid is intended to be used by a person acting as the registrar of this Certificate Authority. Next you will create a userid for use by a person who will be the blockchain network administrator for the organization. Click the Register user button on the right side of the screen: Step 8.4: In the Step 1 of 2 panel, fill it out as guided by the following table, and then click the blue Next button: Field label Value Comments Enroll ID osadmin Enroll secret osadminpw click the \"eye\" icon to see the password Type admin Choose from dropdown list Step 8.5: We will not be using custom attributes in this lab, so all you have to do on this screen is click the Register user button: Step 8.6: You should now see the userid you just registered, osadmin , listed on the screen. You also need to create a userid that your ordering service node will operate as, so click the Register user button again: Step 8.7: In the Step 1 of 2 panel, fill it out as guided by the following table, and then click the blue Next button: Important It is critical that you change the value of the Type field from client to orderer for this userid! Field label Value Comments Enroll ID os1 Enroll secret os1pw click the \"eye\" icon to see the password Type orderer Choose from dropdown list Step 8.8: Just click the Register user button at the bottom of the screen: Step 8.9: You should now see the os1 userid listed along with the others on this screen. Click the Organizations icon on the palette on the left of your screen and continue to the next section of the lab: Section 9: Create an MSP for your Ordering Service organization Our trusty lodestar shows us what will be added to our nascent network now: Step 9.1: You should see a screen that looks like below. You now need to create an MSP definition for your Ordering Service organization, just as you did earlier for your peer ( Team xx Org1 MSP ) organization. Click the Create MSP definition button to get started: Step 9.2: Enter the following values as instructed here on the MSP definition details screen and click the Next button: Field label Value Comments MSP display name Team xx Ordering Service MSP substitute your two-digit team ID for xx MSP ID teamxxosmsp substitute your two-digit team ID for xx The sidebar panel contains more information than will likely fit in your browser window, so review the values you have entered per the above list, and then scroll down within the sidebar panel: Step 9.3: On the Root Certificate Authority details screen, select Team xx Ordering Service CA from the dropdown list. Once you have selected the root certificate authority, you will see that the Root certificates and TLS root certificates fields appear and are populated with apparent nonsense that is actually base64-encoded X.509 certificates. Click the Next button: Step 9.4: On the Admin certificates screen, fill out the three fields beneath this in accordance with the below table, and then click the Generate button, which should become active once you enter values for the three fields: Field label Value Comments Enroll ID osadmin Select from dropdown list. It will not be the default presented to you, so make sure you select it. Enroll secret osadminpw Identity name Team xx Ordering Service MSP Admin substitute your team ID for xx Step 9.5: The prior step generated a public certificate and a matching private key. This private key is stored by the IBM Blockchain Platform console in your local browser storage and nowhere else. In order to ensure that you can retrieve your private key later, you must now click the Export button which will prompt you to save your private key (along with the public certificate) in a JSON file on your hard drive. Step 9.6: Select the Save File radio button in the dialog window that appears, and click the OK button: Step 9.7: Save the exported JSON file in a location that you can remember. The sample screenshot below shows it being saved to a folder named Downloads . Note You probably won't need this saved file for this lab if you use the same browser window for the duration of the lab, but the saved file may be necessary if, for whatever reason, you do have to use a new browser window or session, so go ahead and save it! Step 9.8: Now that you have saved the exported certificate, click the blue Next button to proceed: Step 9.9: On the Review MSP information screen, ensure that the values you entered match what is shown in the following table, taking into account that xx should be your two-digit team ID: Left column (labels) Right column (values your provided) MSP display name Team xx Ordering Service MSP MSP ID teamxxosmsp Admin certificate Team xx Ordering Service MSP Admin Selected CA Team xx Ordering Service CA Note If you entered some values incorrectly, click the Back button as necessary to navigate back through the screen flow until you get to the screen(s) necessary to correct your mistakes, and then navigate forward again with the Next button until you return to this Review MSP information screen and verify you have entered the expected values. Ask an instructor for help if necessary. When you have ensured that you have entered the right values, click the blue Create MSP definition button in the lower right of your screen: Step 9.10: You should now see the definition for your new MSP listed on your screen. Click the Nodes icon in the icon palette on your left- it is the topmost icon on this palette, and you will be ready to proceed to the next section: Section 10: Create an ordering service node for your Ordering Service organization Having created the MSP, you may now create the ordering service node. Ordering service nodes receive proposed transactions from peer nodes, package them into blocks, and then deliver these blocks to peer nodes to commit to the ledger. Ordering service nodes are pretty important, in other words. Our star is running out of leg room all cramped up by the circle in our drawing but hopefully you can see what she is trying to highlight in this iteration of our journey: Step 10.1: Click the Add ordering service button: Step 10.2: Click the Create an Ordering service button and then click the blue Next button: Step 10.3: Type Team xx Ordering Service , where xx is your two-digit team ID, in the Ordering service display name field, leave the Number of ordering nodes field set to One ordering node , and then click the blue Next button: Step 10.4: Enter or select the following values on the Step 3 of 5 panel using the following table as a guide, and then click the blue Next button: Field label Value Comments Certificate Authority Team xx Ordering Service CA Select from dropdown list if this choice is not already presented to you, where xx is your two-digit team ID Ordering service enroll ID os1 Select from dropdown list. It will not be the default presented to you, so make sure you select it. Ordering service enroll secret os1pw Organization MSP Team xx Ordering Service MSP Select from dropdown list, where xx is your two-digit team ID Step 10.5: On the Associate Identity screen, select Team xx Ordering Service MSP Admin , where xx is your two-digit team ID, for the Orderer administrator identity field, and click Next : Step 10.6: The Summary panel provides a review of the values you entered or selected in the prior panels. You may need to scroll down to see all of the values. The values you entered should match up with the table below. If not, use the Back button as necessary to correct your entries. The table below shows the expected value (where xx is your two-digit team ID) and which of the seven panels in the Add ordering service flow was used to set this value: Field label Expected Value Comments Ordering service display name Team xx Ordering Service Set in Step 2 of 5 panel Number of ordering nodes 1 Default value from Step 2 of 5 panel Certificate Authority Team xx Ordering Service CA Set in Step 3 of 5 panel Ordering service enroll ID os1 Set in Step 3 of 5 panel Ordering service enroll secret os1pw Set in Step 3 of 5 panel Organization MSP Team xx Ordering Service MSP Set in Step 3 of 5 panel CPU (VPC) usage total 0.35 Not set by you- calculated from defaults Memory usage total 700 M Not set by you- calculated from defaults Storage usage total 100 Gi Not set by you- default value Associated identity Team xx Ordering Service MSP Admin Set in Step 4 of 5 panel Note If you have to use the Back button to make any corrections, you can return to the summary on Step 5 of 5 by clicking Next the necessary number of times. When you have ensured that you have entered the right values, click the blue Add ordering service button in the lower right of your screen: Step 10.7: You should see your new ordering service listed, along with a gray box in the upper right of its tile, showing that the status of this ordering service is \"pending\" if you hover your cursor over the gray box. It can take a minute or two on our lab system for the ordering service to come up completely, and you may need to refresh your browser in order to see the box turn green. If your ordering service is still not ready after a couple of minutes and after you have tried refreshing your browser, ask an instructor for help. The ordering service must be ready, as indicated by a green box in the upper right of its tile, similar to what is shown below, before you can continue. Caution This step pertains to the tile listed in the Ordering services section, not to the similarly named tile in the Certificate Authorities section Once it is ready, click on its tile and continue to the next section of the lab. Section 11: Add your Teamxx Org1 organization to a consortium Step 11.1: In the Consortium members section, which is below the Ordering service administrators section, click the Add organization button: Step 11.2: Click the Existing MSP ID button, select Team xx Org1 MSP (teamxxorg1msp) where xx is your two-digit team ID, and then click the Add organization button: Important Ensure that you select Team xx Org1 MSP (teamxxorg1msp) from the dropdown list. This will probably not be the default choice provided to you. Step 11.3: You should now see your peer organization, team xx org1msp , listed as a member of your consortium: Section 12: Create a channel You won't get very far without an ordering service node, because they are the animals that create blocks. You won't get very far without a peer, as peers run smart contracts, which create transactions that are sent to an ordering service node. Well, you won't get much stuff done without a channel either, because a transaction proposal is sent from a peer to an ordering service node over a channel. You will define a channel in this section and in its definition you will make your Team xx Org1 peer organization a member of the channel. The actual definition of the channel is verified at the ordering service node and it keeps track of all channels. (You can define multiple channels in a Hyperledger Fabric network but for simplicity this lab will only have you define one). The line between the ordering service node and your first peer organization node represents that our ordering service knows about our new channel and that our peer organization is a member of the new channel: Step 12.1: Click the Channels icon in the icon palette on the left. The screenshot below shows which icon to click: Step 12.2: Click the Create channel button: Step 12.3: You may read the information on the Prerequisites panel, but you will not have to do anything- the prior sections of the lab have met the prerequisites! Click on the blue Next button to continue: Step 12.4: On the Channel details panel, enter team xx -channel1 in the Channel name field, and select Team xx Ordering Service for the Ordering service field, where xx is your two-digit team ID, then click the Next button to continue: Step 12.5: On the Organizations panel, select Team xx Org1 MSP (team xx org1msp) for the Channel member field and click the Add button to the right of your selection: Step 12.6: You should now see team xx org1msp listed in the Organizations section. Select the checkbox to the left of the word Operator in order to give your organization operator privileges on the channel. The Next button should become enabled once you do this, so click on it to continue: Step 12.7: On the Update policy panel, ensure that 1 out of 1 is selected in the Policy field and then click the Next button: Step 12.8: On the Organization creating channel panel, select Team xx Org1 MSP (team xx org1msp) from the dropdown list for the Channel creator MSP field, and select Team xx Org1 MSP Admin from the dropdown list for the Identity field, and then click the Next button: Step 12.9: On the Review channel information screen, ensure that the values you entered match what is shown in the following table, taking into account that xx should be your two-digit team ID: Left column (labels) Right column (values your provided) Channel name team xx -channel1 Ordering service Team xx Ordering Service_1 Organizations team xx org1msp Policy 1 out of 1 Organization creating channel Team xx Org1 MSP Identity for organization creating channel Team xx Org1 MSP Admin Note If you entered some values incorrectly, click the Back button as necessary to navigate back through the screen flow until you get to the screen(s) necessary to correct your mistakes, and then navigate forward again with the Next button until you return to this Review MSP information screen and verify you have entered the expected values. Ask an instructor for help if necessary. When you have ensured that you have entered the right values, click the blue Create MSP definition button in the lower right of your screen: Step 12.10: You should now see your channel listed. Click where it says Pending- add peer and continue to the next section: Section 13: Join your Teamxx Org1 peer to the channel In the previous section you defined a channel, team xx channel1 , and made your Team xx Org1 organization a member of the channel. However, in order for a particular peer within that organization to participate in the channel, that peer has to join the channel. Our simple lab network only has one peer in the organization, but in most production implementations an organization will have multiple peers. When the peer joins a channel, it will receive all of the blocks in the channel that were created prior to the time the peer joined the channel, until it catches up. Our evolving network diagram only gets a subtle change from this section- the line from the ordering service node to the circle representing our organization, indicating that our organization is a member of the channel, has been extended with a line segment from the circle to our peer, indicating that our peer has now joined the channel: Step 13.1: For the Choose from available peers field, select Team xx Org1 Peer , where xx is your two-digit team ID, and click the Join channel button in the lower right: Note The Join channel button will not be enabled until you click on the peer name. Step 13.2: You should now see that instead of the Pending- add peer message at the bottom of the tile for your channel, it now says 2 Blocks . This indicates that the channel has been successfully created and you have joined a peer to it. Information The first block created in a channel is called the genesis block , and it contains configuration data for the channel. The second block in this channel is for a configuration transaction that defined Team xx Org1 Peer as an anchor peer for the Team xx Org1 organization. An anchor peer is a peer whose external endpoint address is published in the channel configuration. This way other organizations can reach this peer. An organization must provide at least one anchor peer for service discovery or private data collections to work. Section 14: Create a Certificate Authority for your second peer organization, \"Teamxx Org2\" You have now already defined two organizations- Team xx Org1 and Team xx Ordering Service . The Ordering Service organization provides the ordering service and does not itself initiate blockchain transactions. Most, if not all, realistic blockchain networks will involve multiple organizations initiating blockchain transactions. So you will now define a second peer organization to participate in the network. Your network will thus have three organizations- two peer organizations that are collaborating in the blockchain network, and the ordering service organization which is, essentially, a service provider. You are changing hats again, this time from your Team xx Ordering Service administrator hat to your Team xx Org2 administrator hat. Our network diagram is coming along quite nicely: We will define the second peer organization now. The pattern is identical to what you did earlier for the first organization. Note This will be the third Certificate Authority you define in this lab, so we will show fewer screenshots of repetitive tasks, in this section and in subsequent sections. Step 14.1: Click the Nodes icon on the icon palette on the left, and then click the blue Add Certificate Authority button. Step 14.2: On the Step 1 of 3 sidebar panel, click Create a Certificate Authority and then click the blue Next button. Step 14.3: Fill in the Step 2 of 3 sidebar panel as follows, and then click the blue Next button: Field label Value Comments CA display name Team xx Org2 CA Substitute your two-digit team ID for xx CA administrator enroll ID admin CA administrator enroll secret adminpw Step 14.4: Review your settings on the Step 3 of 3 sidebar panel and click the Add Certificate Authority button: Step 14.5: You will see a tile for your new certificate authority. Observe the box in the upper right corner of the tile. If it is gray, and you hover your cursor over it, you may see a message indicating that the status is pending. In about a minute, the box in the upper right should turn green, indicating that the certificate authority is running. Note If the box in the upper right corner of the tile does not turn green in a minute or two, try reloading the page in your browser. Contact an instructor for help if it does not turn green and show the running status when you hover your cursor over this box. Once your certificate authority is running, click on its tile so that you can proceed to the next section where you will add users. Section 15: Add new users using your Teamxx Org2 Certificate Authority Step 15.1: You must first associate an administrative identity with your certificate authority, so click the Associate identity button as shown in this screen snippet: Step 15.2: Ensure that the Enroll ID Button is selected in the Associate Identity sidebar panel, fill out the panel as directed in the below table, and then click the blue Associate Identity button: Field label Value Comments Enroll ID admin Enroll secret adminpw click the \"eye\" icon to see the password Identity display name Team xx Org2 CA Admin substitute your two-digit team ID for xx Step 15.3: You should now see the admin userid in the list of registered users. This userid is intended to be used by a person acting as the registrar of this Certificate Authority. Next you will create a userid for use by a person who will be the blockchain network administrator for the organization. Click the Register user button on the right side of the screen: Step 15.4: In the Step 1 of 2 panel, fill it out as guided by the following table, and then click the blue Next button: Field label Value Comments Enroll ID org2admin Enroll secret org2adminpw click the \"eye\" icon to see the password Type admin Choose from dropdown list Step 15.5: We will not be using custom attributes in this lab, so all you have to do on this screen is click the Register user button. Step 15.6: You should now see the userid you just registered, org2admin , listed on the screen. You also need to create a userid that your peer node will operate as, so click the Register user button again. Step 15.7: In the Step 1 of 2 panel, fill it out as guided by the following table, and then click the blue Next button: Important It is critical that you change the value of the Type field from client to peer for this userid! Field label Value Comments Enroll ID peer2 Enroll secret peer2pw click the \"eye\" icon to see the password Type peer Choose from dropdown list Step 15.8: Just click the Register user button at the bottom of the screen. Step 15.9: You should now see the peer2 userid listed along with the others on this screen. Click the Organizations icon on the palette on the left of your screen and continue to the next section of the lab: Section 16: Create an MSP for your second peer organization Defining the MSP for Team xx Org2 will bring our network one step closer to fruition: Step 16.1: You should see the MSP definitions for your other two organizations. Click the blue Create MSP definition button. Step 16.2: Enter the following values as instructed here on the MSP definition details screen and click the Next button: Field label Value Comments MSP display name Team xx Org2 MSP substitute your two-digit team ID for xx MSP ID teamxxorg2msp substitute your two-digit team ID for xx Step 16.3: On the Root Certificate Authority details screen, select Team xx Org2 CA from the dropdown list. Once you have selected the root certificate authority, you will see that the Root certificates and TLS root certificates fields appear and are populated with apparent nonsense that is actually base64-encoded X.509 certificates. Important Ensure that you selected your certificate authority for your Org2 , and not Org1 , in the Root Certificate Authority field. It's easy to mistakenly choose Org1 's certificate authority here, and this often turns ecstasy to melancholy. Click the Next button. Step 16.4: On the Admin certificates screen, fill out the three fields beneath this in accordance with the below table, and then click the Generate button, which should become active once you enter values for the three fields: Field label Value Comments Enroll ID org2admin Select from dropdown list. It will not be the default presented to you, so make sure you select it. Enroll secret org2adminpw Identity name Team xx Org2 MSP Admin substitute your team ID for xx Step 16.5: The prior step generated a public certificate and a matching private key. This private key is stored by the IBM Blockchain Platform console in your local browser storage and nowhere else. In order to ensure that you can retrieve your private key later, you must now click the Export button which will prompt you to save your private key (along with the public certificate) in a JSON file on your hard drive. Step 16.6: Select the Save File radio button in the dialog window that appears, and click the OK button. Step 16.7: Save the exported JSON file in a location that you can remember. Note You probably won't need this saved file for this lab if you use the same browser window for the duration of the lab, but the saved file may be necessary if, for whatever reason, you do have to use a new browser window or session, so go ahead and save it! Step 16.8: Now that you have saved the exported certificate, click the blue Next button to proceed: Step 16.9: On the Review MSP information screen, ensure that the values you entered match what is shown in the following table, taking into account that xx should be your two-digit team ID: Left column (labels) Right column (values your provided) MSP display name Team xx Org2 MSP MSP ID teamxxorg2msp Admin certificate Team xx Org2 MSP Admin Selected CA Team xx Org2 CA Note If you entered some values incorrectly, click the Back button as necessary to navigate back through the screen flow until you get to the screen(s) necessary to correct your mistakes, and then navigate forward again with the Next button until you return to this Review MSP information screen and verify you have entered the expected values. Ask an instructor for help if necessary. When you have ensured that you have entered the right values, click the blue Create MSP definition button in the lower right of your screen. Step 16.9: You should now see the definition for your new MSP listed on your screen. Scroll up and click the Nodes icon in the icon palette on your left- it is the topmost icon on this palette- and you will be ready to proceed to the next section. Section 17: Create a peer node for your second peer organization The most useful German phrase I know is noch einmal Bier, bitte! , which translates to another beer, please! So I am asking you kindly, noch einmal peer, bitte! , that is, please define a peer for your second organization: Step 17.1: Click the blue Add peer button. Step 17.2: Click the Create a peer button and then click the blue Next button. Step 17.3: Leave all of the Advanced deployment options unchecked. Type Team xx Org2 Peer , where xx is your two-digit team ID, in the Peer display name field and then click the blue Next button. Step 17.4: Enter or select the following values on the Step 3 of 5 panel as directed by the following table, and then click the blue Next button. Field label Value Comments Certificate Authority Team xx Org2 CA Select from dropdown list if this choice is not already presented to you, where xx is your two-digit team ID Peer enroll ID peer2 Select from dropdown list Peer enroll secret peer2pw Organization MSP Team xx Org2 MSP Select from dropdown list, where xx is your two-digit team ID TLS CSR hostname leave blank Step 17.5: On the Associate Identity screen, select Team xx Org2 MSP Admin , where xx is your two-digit team ID, for the Peer administrator identity field, and click Next . Step 17.6: The Summary panel provides a review of the values you entered or selected in the prior panels. You may need to scroll down to see all of the values. The values you entered should match up with the table below. If not, use the Back button as necessary to correct your entries. The table below shows the expected value (where xx is your two-digit team ID) and which of the seven panels in the Add Peer flow was used to set this value: Field label Expected Value Comments Peer display name Team xx Org2 Peer Set in Step 2 of 5 panel State database CouchDB Not set by you- default value Certificate Authority Team xx Org2 CA Set in Step 3 of 5 panel Peer enroll ID peer2 Set in Step 3 of 5 panel Peer enroll secret peer2pw Set in Step 3 of 5 panel Organization MSP Team xx Org2 MSP Set in Step 3 of 5 panel CPU (VPC) usage total 1.6 Not set by you- calculated from defaults Memory usage total 2,800M Not set by you- calculated from defaults Storage usage total 200Gi Not set by you- calculated from defaults Associated identity Team xx Org2 MSP Admin Set in Step 4 of 5 panel Note If you have to use the Back button to make any corrections, you can return to the summary on Step 5 of 5 by clicking Next the necessary number of times. When you have ensured that you have entered the right values, click the blue Add peer button in the lower right of your screen: Step 17.7: You should see your new peer listed, along with a gray box in the upper right of its tile, showing that the status of this peer is \"pending\" if you hover your cursor over the gray box. It can take a minute or two on our lab system for the peer to come up completely, and you may need to refresh your browser in order to see the box turn green. If your peer is still not ready after a couple of minutes and after you have tried refreshing your browser, ask an instructor for help. The peer must be ready, as indicated by a green box in the upper right of the peer's tile, similar to what is shown below, before you can continue: Section 18: Add your Teamxx Org2 organization to the consortium Step 18.1: Click on your Team xx Orderin... tile (the full name is most likely truncated on your screen) under the Ordering services section: Note You may need to scroll down a little to see this. Ensure you click the tile in the Ordering services section and not the similarly named tile in the Certificate Authorities section- it is easy to make that mistake because the full names are truncated. Step 18.2: Click the blue Add organization button in the Consortium members section. Step 18.3: Click the Existing MSP ID button, select Team xx Org2 MSP (team xx org2msp) where xx is your two-digit team ID, and then click the Add organization button. Step 18.4: You should now see your second peer organization, team xx org2msp , listed as a member of your consortium. Section 19: Add your Teamxx Org2 organization to the channel Team xx Org2 can now become a member of channels since you added it to the consortium in the prior section. Take advantage of that good fortune and add it as a member of your channel: When you created your team xx -channel1 channel earlier in the lab, your new Team xx Org2 organization did not exist yet. If it had existed at the time, you could have added it to the channel membership when you created the channel. You will add the organization to the channel membership now. Step 19.1: Click the Channels icon on the icon palette on the left: Step 19.2: Click the tile for your team xx -channel1 channel: Step 19.3: Click the Settings icon (the one that looks like a gear) a little underneath the channel name near the top of your screen: Step 19.4: In the Organization updating channel panel, select Team xx Org1 MSP (team xx org1msp) from the dropdown list for the Channel updater MSP field, select Team xx Org1 MSP Admin from the dropdown list for the Identity field, and then click the Next button: Step 19.5: On the Organizations panel, select Team xx Org2 MSP (team xx org2msp) from the dropdown list for the Channel member field, and then click the Add button to the right of the field: Step 19.6: Your team xx org2msp organization will now be listed under the Organizations section. Select the checkbox to the left of Operator in order to give this organization Operator authority on the channel. Click the Next button: Step 19.7: On the Update policy panel, select 1 out of 2 for the Policy field and then click the Next button: Step 19.8: From the Capabilities panel, click the Review channel information link, as you will not be updating any of the advanced configuration settings: Step 19.9: Review the top half of the information in the Review channel information panel. The bottom half of information, below the horizontal line, is for advanced settings that you did not change. Ensure that the information in the top half, which you did enter, corresponds to the table below, with xx corresponding to your two-digit team ID: Left column (labels) Right column (values your provided) Channel name team xx -channel1 Ordering service Team xx Ordering Service_1 Organizations team xx org1msp and team xx org2msp Policy 1 out of 2 Organization updating channel Team xx Org1 MSP Identity for organization updating channel Team xx Org1 MSP Admin Note If you entered some values incorrectly, click the Back button as necessary to navigate back through the screen flow until you get to the screen(s) necessary to correct your mistakes, and then navigate forward again with the Next button until you return to this Review MSP information screen and verify you have entered the expected values. Ask an instructor for help if necessary. When you have ensured that you have entered the right values, click the blue Update channel button in the lower right of your screen. Step 19.10: Notice that the block height is now three. The most recent block, that has an ID of 2 - block numbering starts at zero- contains a transaction that contains the configuration update you just made, which added your Team xx Org2 to the channel. Note Hyperledger Fabric distinguishes configuration update transactions from typical application transactions. The IBM Blockchain Platform console does not show details of configuration update transactions nor include them in the count of transactions that it will display. That is, if you display a block that has a configuration update transaction, the IBM Blockchain Platform console will show 0 transactions for that block. (A block of application transactions can contain multiple transactions, but a configuration update transaction is the only transaction in its block. That is, a block does not contain a mix of application transactions and configuration update transactions). Click the Channel details tab, which is to the right of the Transaction overview tab: Step 19.11: In the Channel members section of the panel, you should now see both of your peer organizations listed as members. Once you have verified this, click the Channels icon on the icon palette on the left: Note Although team xx org2msp is listed in the Channel members section, you don't see it listed above that in the Nodes section. That is because you have not joined a peer from team xx org2msp to the channel yet. You will do that next. Section 20: Join your Teamxx Org2 peer to the channel You will now join Team xx Org2 Peer to the channel: Step 20.1: Now that your Org2 is a member of the channel, you can join your peer from Org2 to the channel. Click the blue Join channel button: Step 20.2: Ensure that Team xx Ordering Service , where xx is your two-digit team ID, is selected for the Ordering service field and click the blue Next button: Step 20.3: Type team xx -channel1 , where xx is your two-digit team ID, in the Channel field and click the Next button: Step 20.4: In the Choose from available peers section, select Team xx Org2 Peer , where xx is your two-digit team ID, and then click the blue Join channel button: Step 20.5: You are returned to the Channels screen. Click the tile for your channel, team xx -channel1 : Step 20.6: Click the Channel details tab to the right of the Transaction overview tab: Step 20.7: Observe that your peer node for Org2 , Team xx Org2 Peer , is listed in the Nodes section, indicating that this peer has joined the channel: Congratulations!! You have made it to the end of this lab! Job well done! But after all that work you haven't run any smart contracts on your new network yet! Don't worry, that occurs in the next lab . You will not have toiled in vain.","title":"Part 1 - Create a Blockchain Network"},{"location":"ibpconsole/#ibm-blockchain-platform-v213-lab-part-1-create-a-blockchain-network","text":"","title":"IBM Blockchain Platform v2.1.3 Lab Part 1 - Create a Blockchain Network"},{"location":"ibpconsole/#section-1-create-a-blockchain-network-lab-overview","text":"You will use the IBM Blockchain Platform console in this lab to create a blockchain network. The network will consist of three organizations. Two of these organizations will represent organizations that want to participate in the blockchain network and submit transactions. They will be referred to as peer organizations throughout the lab. The third organization is the organization that provides the ordering service. First you will create one peer organization. Then you will create an ordering service organization, create a channel and add your first peer organization to the channel. Then you will create a second peer organization, and add it to the channel. Each high-level task is detailed in a separate section, with multiple steps per task. The diagram below provides a view of what your blockchain network will look like upon completion of the lab: Important You will be assigned a two-digit team ID by your instructor, and everywhere in this lab where you see Team xx in the instructions, you must substitute xx with the two-digit id you have been assigned. The sections in this lab are as follows: Section 1: This overview Section 2: Logging in to the IBM Blockchain Platform console Section 3: Creating a Certificate Authority for your first peer organization, \"Team xx Org1\" Section 4: Adding new users using your Team xx Org1 Certificate Authority Section 5: Creating an MSP for your Team xx Org1 organization Section 6: Creating a peer node for your Team xx Org1 organization Section 7: Creating a Certificate Authority for an Ordering Service organization Section 8: Adding new users using your Ordering Service Certificate Authority Section 9: Creating an MSP for your Ordering Service organization Section 10: Creating an ordering service node for your Ordering Service organization Section 11: Adding your Team xx Org1 organization to a consortium Section 12: Creating a channel Section 13: Joining your Team xx Org1 peer to the channel Section 14: Creating a Certificate Authority for your second peer organization, \"Team xx Org2\" Section 15: Adding new users using your Team xx Org2 Certificate Authority Section 16: Creating an MSP for your Team xx Org2 organization Section 17: Creating a peer node for your Team* xx Org2 organization Section 18: Adding your Team xx Org2 organization to the consortium Section 19: Adding your Team xx Org2 organization to the channel Section 20: Joining your Team xx Org2 peer to the channel","title":"Section 1: Create a Blockchain Network lab overview"},{"location":"ibpconsole/#section-2-log-in-to-the-ibm-blockchain-platform-console","text":"Important The lab environment is using self-signed SSL certificates and your browser will not trust them without explicit action on your part so part of this initial section on logging in involves establishing this trust. You will first need to go to the URL address provided by your instructor. Step 2.1: Open a new tab in your Firefox browser window and enter the unique URL for your IBM Blockchain Platform console. This URL will be provided to you by your instructor. Note Your URL will similar to https://workshop-00-ibpconsole-console.apps.atsocpd3.dmz:443 , but this is just an example, so make sure you use the actual URL given to you by your instructor! If you see a security warning after entering the URL, click the Advanced button, which is highlighted in the below screen snippet: Step 2.2: The reason you are seeing these security messages is because of a self-signed certificate in our lab environment. Go ahead and click on the Accept the Risk and Continue button that is shown below: Step 2.3: Enter your team's userid and password, which will have been provided to you by the instructor, and click the Login button: Step 2.4: You may be presented with a screen asking you to change your password. If not, skip ahead to Step 2.5 . If so, enter your current password, and then a new password twice. Click the Change password button, which will turn blue and be enabled once you have entered matching values in the New password and the Confirm new password fields. Your new password must be at least eight characters in length. Upon successful password change, you will be presented with the Login screen again, as in Step 2.3 . Log in again with your new password. Step 2.5: You may be presented with a welcome screen with some informative interactive graphics. Move your cursor around a bit to see them, and then click the Let's get started button in the lower right corner. Note If you do not see this welcome screen with the graphics, you can view it at any time by clicking the Get started link at the top of your screen, and then clicking the Understand box on the left.","title":"Section 2: Log in to the IBM Blockchain Platform console"},{"location":"ibpconsole/#section-3-create-a-certificate-authority-for-your-first-peer-organization-teamxx-org1","text":"In a Hyperledger Fabric network, each organization will typically have their own certificate authority. The certificate authority is used to issue identities- consisting of X.509 public certificates and matching private keys- for end users, client applications, administrators, and peer and ordering service nodes. In most uses cases each organization will want to have control over the identities they issue, so the typical practice is that each organization provides their own certificate authority. We will follow that practice in this lab. You are starting with a blank slate, and our first component to add is the certificate authority for our first peer organization. In relation to the diagram in the overview section that showed our finished network upon successful lab completion, here is the component that will be added in this section: Step 3.1: You will be on a screen which lets you define three types of nodes- Peers , Certificate Authorities , and Ordering services . Click the blue Add Certificate Authority button: Information This will be transparent to you as a user of the IBM Blockchain Platform Console, but each individual node that you create during the lab will result in the creation of a Kubernetes pod , which is a collection of one or more containers , on a worker node in a Red Hat OpenShift Container Platform cluster. Step 3.2: Click Create a Certificate Authority and then click the blue Next button: Step 3.3: Fill in the Step 2 of 3 screen as follows, and then click the blue Next button: Field label Value Comments CA display name Team xx Org1 CA Substitute your two-digit team ID for xx CA administrator enroll ID admin CA administrator enroll secret adminpw Important Leave the checkboxes in the Advanced deployment options section unchecked. You may click on the small information icon to the right of each choice if you would like to learn about each option, but you do not need to do so to successfully complete the lab. This advice is applicable for all steps throughout this lab that offer advanced deployment option choices. Step 3.4: Review your settings on the Step 3 of 3 screen and click the Add Certificate Authority button: Note Throughout this lab, when passwords are entered, you can click the icon that looks like an eye to see the password you have entered. It is recommended that you do this for the lab to ensure you have entered the intended password. The screenshots shown in this lab will show the passwords that you should enter. Step 3.5: You will see a tile for your new certificate authority. Observe the box in the upper right corner of the tile. If it is gray, and you hover your cursor over it, you may see a message indicating that the status is pending. In about a minute, the box in the upper right should turn green, indicating that the certificate authority is running. Note If the box in the upper right corner of the tile does not turn green in a minute or two, try reloading the page in your browser. Contact an instructor for help if it does not turn green and show the running status when you hover your cursor over this box. Once your certificate authority is running, click on its tile so that you can proceed to the next section where you will add users.","title":"Section 3: Create a Certificate Authority for your first peer organization, \"Teamxx Org1\""},{"location":"ibpconsole/#section-4-add-new-users-using-your-teamxx-org1-certificate-authority","text":"Step 4.1: You must first associate an administrative identity with your certificate authority, so click the Associate identity button as shown in this screen snippet: Step 4.2: Ensure that the Enroll ID Button is selected in the Associate Identity sidebar panel, fill out the panel as directed in the below table, and then click the blue Associate Identity button: Field label Value Comments Enroll ID admin Enroll secret adminpw click the \"eye\" icon to see the password Identity display name Team xx Org1 CA Admin substitute your two-digit team ID for xx Step 4.3: You should now see the admin userid in the list of registered users. This userid is intended to be used by a person acting as the registrar of this Certificate Authority. Next you will create a userid for use by a person who will be the blockchain network administrator for the organization. Click the Register user button on the right side of the screen: Step 4.4: In the Step 1 of 2 panel, fill it out as guided by the following table, and then click the blue Next button: Field label Value Comments Enroll ID org1admin Enroll secret org1adminpw click the \"eye\" icon to see the password Type admin Choose from dropdown list Step 4.5: We will not be using custom attributes in this lab, so all you have to do on this screen is click the Register user button: Step 4.6: You should now see the userid you just registered, org1admin , listed on the screen. You also need to create a userid that your peer node will operate as, so click the Register user button again: Step 4.7: In the Step 1 of 2 panel, fill it out as guided by the following table, and then click the blue Next button: Important It is critical that you change the value of the Type field from client to peer for this userid! Field label Value Comments Enroll ID peer1 Enroll secret peer1pw click the \"eye\" icon to see the password Type peer Choose from dropdown list Step 4.8: Just click the Register user button at the bottom of the screen: Step 4.9: You should now see the peer1 userid listed along with the others on this screen. Click the Organizations icon on the palette on the left of your screen and continue to the next section of the lab:","title":"Section 4: Add new users using your Teamxx Org1 Certificate Authority"},{"location":"ibpconsole/#section-5-create-an-msp-for-your-organization","text":"The Membership Service Provider (MSP) component is integral to the private and permissioned Hyperledger Fabric as it provides the authentication- \"who are you?\"- and authorization - \"ok, we believe you are whom you say you are, but are you permitted to do what you are asking to do?\"- services. The infrastructure that the MSP needs to do its job must be in place before you create your peer node. This step will create this for your \"Team xx Org1\" organization. As we add components throughout the lab, the diagram that maps to our final goal will be shown, with the new component to be added in any given section annotated with a bright red star, as in the below diagram which shows that we will be adding your Team xx Org1 's MSP: Step 5.1: You should see a screen that looks like below, indicating that you have yet to create a Membership Service Provider (MSP) definition for your organization. Click the Create MSP definition button: Step 5.2: Enter the following values as instructed here on the MSP definition details screen and click the Next button: Field label Value Comments MSP display name Team xx Org1 MSP substitute your two-digit team ID for xx MSP ID teamxxorg1msp substitute your two-digit team ID for xx Step 5.3: On the Root Certificate Authority details screen, select Team xx Org1 CA from the dropdown list. Once you have selected the root certificate authority, you will see that the Root certificates and TLS root certificates fields appear and are populated with apparent nonsense that is actually base64-encoded X.509 certificates. Click the Next button: Step 5.4: On the Admin certificates screen, fill out the three fields beneath this in accordance with the below table, and then click the Generate button, which should become active once you enter values for the three fields: Field label Value Comments Enroll ID org1admin Select from dropdown list. It will not be the default presented to you, so make sure you select it. Enroll secret org1adminpw Identity name Team xx Org1 MSP Admin substitute your team ID for xx Step 5.5: The prior step generated a public certificate and a matching private key. This private key is stored by the IBM Blockchain Platform console in your local browser storage and nowhere else. In order to ensure that you can retrieve your private key later, you must now click the Export button which will prompt you to save your private key (along with the public certificate) in a JSON file on your hard drive. Step 5.6: Select the Save File radio button in the dialog window that appears, and click the OK button: Step 5.7: Save the exported JSON file in a location that you can remember. The sample screenshot below shows it being saved to a folder named Downloads . Note You probably won't need this saved file for this lab if you use the same browser window for the duration of the lab, but the saved file may be necessary if, for whatever reason, you do have to use a new browser window or session, so go ahead and save it! Step 5.8: Now that you have saved the exported certificate, click the blue Next button to proceed: Step 5.9: On the Review MSP information screen, ensure that the values you entered match what is shown in the following table, taking into account that xx should be your two-digit team ID: Left column (labels) Right column (values your provided) MSP display name Team xx Org1 MSP MSP ID teamxxorg1msp Admin certificate Team xx Org1 MSP Admin Selected CA Team xx Org1 CA Note If you entered some values incorrectly, click the Back button as necessary to navigate back through the screen flow until you get to the screen(s) necessary to correct your mistakes, and then navigate forward again with the Next button until you return to this Review MSP information screen and verify you have entered the expected values. Ask an instructor for help if necessary. When you have ensured that you have entered the right values, click the blue Create MSP definition button in the lower right of your screen: Step 5.10: You should now see the definition for your new MSP listed on your screen. Click the Nodes icon in the icon palette on your left- it is the topmost icon on this palette, and you will be ready to proceed to the next section:","title":"Section 5: Create an MSP for your organization"},{"location":"ibpconsole/#section-6-create-a-peer-node-for-your-teamxx-org1-organization","text":"A peer node is where smart contracts- in essence, your blockchain business transactions- run. Peer nodes also store the ledgers. We will create a peer for your Team xx Org1 in this section and our fledgling network will then look like this: Step 6.1: Click the Add peer button: Step 6.2: Click the Create a peer button and then click the blue Next button: Step 6.3: Leave all of the Advanced deployment options unchecked. Type Team xx Org1 Peer , where xx is your two-digit team ID, in the Peer display name field and then click the blue Next button: Step 6.4: Enter or select the following values on the Step 3 of 5 panel as directed by the following table, and then click the blue Next button: Field label Value Comments Certificate Authority Team xx Org1 CA Select from dropdown list if this choice is not already presented to you, where xx is your two-digit team ID Peer enroll ID peer1 Select from dropdown list Peer enroll secret peer1pw Organization MSP Team xx Org1 MSP Select from dropdown list, where xx is your two-digit team ID TLS CSR hostname leave blank Step 6.5: On the Associate Identity screen, select Team xx Org1 MSP Admin , where xx is your two-digit team ID, for the Peer administrator identity field, and click Next : Step 6.6: The Summary panel provides a review of the values you entered or selected in the prior panels. You may need to scroll down to see all of the values. The values you entered should match up with the table below. If not, use the Back button as necessary to correct your entries. The table below shows the expected value (where xx is your two-digit team ID) and which of the seven panels in the Add Peer flow was used to set this value: Field label Expected Value Comments Peer display name Team xx Org1 Peer Set in Step 2 of 5 panel State database CouchDB Not set by you- default value Certificate Authority Team xx Org1 CA Set in Step 3 of 5 panel Peer enroll ID peer1 Set in Step 3 of 5 panel Peer enroll secret peer1pw Set in Step 3 of 5 panel Organization MSP Team xx Org1 MSP Set in Step 3 of 5 panel CPU (VPC) usage total 1.6 Not set by you- calculated from defaults Memory usage total 2,800M Not set by you- calculated from defaults Storage usage total 200Gi Not set by you- calculated from defaults Associated identity Team xx Org1 MSP Admin Set in Step 4 of 5 panel Note If you have to use the Back button to make any corrections, you can return to the summary on Step 5 of 5 by clicking Next the necessary number of times. When you have ensured that you have entered the right values, click the blue Add peer button in the lower right of your screen: Step 6.7: Similarly to when you created the certificate authority earlier, you should see your new peer listed, along with a gray box in the upper right of its tile, showing that the status of this peer is \"pending\" if you hover your cursor over the gray box. It can take a minute or two on our lab system for the peer to come up completely, and you may need to refresh your browser in order to see the box turn green. If your peer is still not ready after a couple of minutes and after you have tried refreshing your browser, ask an instructor for help. The peer must be ready, as indicated by a green box in the upper right of the peer's tile, similar to what is shown below, before you can continue:","title":"Section 6: Create a peer node for your Teamxx Org1 organization"},{"location":"ibpconsole/#section-7-create-a-certificate-authority-for-an-ordering-service-organization","text":"In this lab you will create three organizations- two organizations will run peer nodes and run smart contracts. One of the organizations will provide the ordering service for the blockchain network. In the real world each of the three organizations would likely use their own instance of the IBM Blockchain Platform console to create their necessary artifacts. (You have already done much of this for the first peer organization, Team xx Org1 , in the previous sections of this lab). Note You will carry out activities for all three organizations from your browser for purposes of this lab. This will somewhat simplify the steps you'll need to perform versus the real-world scenario where this activity is being carried out separately by each organization. The procedure to perform the tasks in the \"real world\" case are outlined in the IBM Blockchain Platform documentation- basically, it involves exporting information about your organization into JSON files, and providing this information \"out-of-band\" to the other organizations. In an earlier step you exported your generated certificate and its private key. While it is a JSON file, this is not a file you would ever send to another organization, as it contains your private key which should never be shared with other organizations. The exported JSON files that are used for inter-organizational tasks contain only public information which is safe to share. Our network will look like this at the completion of this section: Step 7.1: Click the Add Certificate Authority button: Step 7.2: Click Create a Certificate Authority and then click the blue Next button: Note The steps in this section are essentially the same as in Section 3 , just with different values being entered as appropriate. Step 7.3: Fill in the Step 2 of 3 screen as follows, and then click the blue Next button: Field label Value Comments CA display name Team xx Ordering Service CA Substitute your two-digit team ID for xx CA administrator enroll ID admin CA administrator enroll secret adminpw Step 7.4: Review your settings and click the Add Certificate Authority button: Step 7.5: You will see a tile for your new certificate authority. Observe the box in the upper right corner of the tile. If it is gray, and you hover your cursor over it, you may see a message indicating that the status is pending. In about a minute, the box in the upper right should turn green, indicating that the certificate authority is running. Note If the box in the upper right corner of the tile does not turn green in a minute or two, try reloading the page in your browser. Contact an instructor for help if it does not turn green and show the running status when you hover your cursor over this box. Once your Ordering Service certificate authority is running, click on its tile so that you can proceed to the next section where you will add users.","title":"Section 7: Create a Certificate Authority for an Ordering Service organization"},{"location":"ibpconsole/#section-8-add-new-users-using-your-ordering-service-certificate-authority","text":"Step 8.1: You must first associate an administrative identity with your certificate authority, so click the Associate identity button as shown in this screen snippet: Step 8.2: Ensure that the Enroll ID Button is selected in the Associate Identity sidebar panel, fill out the panel as directed in the below table, and then click the blue Associate Identity button: Field label Value Comments Enroll ID admin Enroll secret adminpw click the \"eye\" icon to see the password Identity display name Team xx Ordering Service CA Admin substitute your two-digit team ID for xx Step 8.3: You should now see the admin userid in the list of registered users. This userid is intended to be used by a person acting as the registrar of this Certificate Authority. Next you will create a userid for use by a person who will be the blockchain network administrator for the organization. Click the Register user button on the right side of the screen: Step 8.4: In the Step 1 of 2 panel, fill it out as guided by the following table, and then click the blue Next button: Field label Value Comments Enroll ID osadmin Enroll secret osadminpw click the \"eye\" icon to see the password Type admin Choose from dropdown list Step 8.5: We will not be using custom attributes in this lab, so all you have to do on this screen is click the Register user button: Step 8.6: You should now see the userid you just registered, osadmin , listed on the screen. You also need to create a userid that your ordering service node will operate as, so click the Register user button again: Step 8.7: In the Step 1 of 2 panel, fill it out as guided by the following table, and then click the blue Next button: Important It is critical that you change the value of the Type field from client to orderer for this userid! Field label Value Comments Enroll ID os1 Enroll secret os1pw click the \"eye\" icon to see the password Type orderer Choose from dropdown list Step 8.8: Just click the Register user button at the bottom of the screen: Step 8.9: You should now see the os1 userid listed along with the others on this screen. Click the Organizations icon on the palette on the left of your screen and continue to the next section of the lab:","title":"Section 8: Add new users using your Ordering Service Certificate Authority"},{"location":"ibpconsole/#section-9-create-an-msp-for-your-ordering-service-organization","text":"Our trusty lodestar shows us what will be added to our nascent network now: Step 9.1: You should see a screen that looks like below. You now need to create an MSP definition for your Ordering Service organization, just as you did earlier for your peer ( Team xx Org1 MSP ) organization. Click the Create MSP definition button to get started: Step 9.2: Enter the following values as instructed here on the MSP definition details screen and click the Next button: Field label Value Comments MSP display name Team xx Ordering Service MSP substitute your two-digit team ID for xx MSP ID teamxxosmsp substitute your two-digit team ID for xx The sidebar panel contains more information than will likely fit in your browser window, so review the values you have entered per the above list, and then scroll down within the sidebar panel: Step 9.3: On the Root Certificate Authority details screen, select Team xx Ordering Service CA from the dropdown list. Once you have selected the root certificate authority, you will see that the Root certificates and TLS root certificates fields appear and are populated with apparent nonsense that is actually base64-encoded X.509 certificates. Click the Next button: Step 9.4: On the Admin certificates screen, fill out the three fields beneath this in accordance with the below table, and then click the Generate button, which should become active once you enter values for the three fields: Field label Value Comments Enroll ID osadmin Select from dropdown list. It will not be the default presented to you, so make sure you select it. Enroll secret osadminpw Identity name Team xx Ordering Service MSP Admin substitute your team ID for xx Step 9.5: The prior step generated a public certificate and a matching private key. This private key is stored by the IBM Blockchain Platform console in your local browser storage and nowhere else. In order to ensure that you can retrieve your private key later, you must now click the Export button which will prompt you to save your private key (along with the public certificate) in a JSON file on your hard drive. Step 9.6: Select the Save File radio button in the dialog window that appears, and click the OK button: Step 9.7: Save the exported JSON file in a location that you can remember. The sample screenshot below shows it being saved to a folder named Downloads . Note You probably won't need this saved file for this lab if you use the same browser window for the duration of the lab, but the saved file may be necessary if, for whatever reason, you do have to use a new browser window or session, so go ahead and save it! Step 9.8: Now that you have saved the exported certificate, click the blue Next button to proceed: Step 9.9: On the Review MSP information screen, ensure that the values you entered match what is shown in the following table, taking into account that xx should be your two-digit team ID: Left column (labels) Right column (values your provided) MSP display name Team xx Ordering Service MSP MSP ID teamxxosmsp Admin certificate Team xx Ordering Service MSP Admin Selected CA Team xx Ordering Service CA Note If you entered some values incorrectly, click the Back button as necessary to navigate back through the screen flow until you get to the screen(s) necessary to correct your mistakes, and then navigate forward again with the Next button until you return to this Review MSP information screen and verify you have entered the expected values. Ask an instructor for help if necessary. When you have ensured that you have entered the right values, click the blue Create MSP definition button in the lower right of your screen: Step 9.10: You should now see the definition for your new MSP listed on your screen. Click the Nodes icon in the icon palette on your left- it is the topmost icon on this palette, and you will be ready to proceed to the next section:","title":"Section 9: Create an MSP for your Ordering Service organization"},{"location":"ibpconsole/#section-10-create-an-ordering-service-node-for-your-ordering-service-organization","text":"Having created the MSP, you may now create the ordering service node. Ordering service nodes receive proposed transactions from peer nodes, package them into blocks, and then deliver these blocks to peer nodes to commit to the ledger. Ordering service nodes are pretty important, in other words. Our star is running out of leg room all cramped up by the circle in our drawing but hopefully you can see what she is trying to highlight in this iteration of our journey: Step 10.1: Click the Add ordering service button: Step 10.2: Click the Create an Ordering service button and then click the blue Next button: Step 10.3: Type Team xx Ordering Service , where xx is your two-digit team ID, in the Ordering service display name field, leave the Number of ordering nodes field set to One ordering node , and then click the blue Next button: Step 10.4: Enter or select the following values on the Step 3 of 5 panel using the following table as a guide, and then click the blue Next button: Field label Value Comments Certificate Authority Team xx Ordering Service CA Select from dropdown list if this choice is not already presented to you, where xx is your two-digit team ID Ordering service enroll ID os1 Select from dropdown list. It will not be the default presented to you, so make sure you select it. Ordering service enroll secret os1pw Organization MSP Team xx Ordering Service MSP Select from dropdown list, where xx is your two-digit team ID Step 10.5: On the Associate Identity screen, select Team xx Ordering Service MSP Admin , where xx is your two-digit team ID, for the Orderer administrator identity field, and click Next : Step 10.6: The Summary panel provides a review of the values you entered or selected in the prior panels. You may need to scroll down to see all of the values. The values you entered should match up with the table below. If not, use the Back button as necessary to correct your entries. The table below shows the expected value (where xx is your two-digit team ID) and which of the seven panels in the Add ordering service flow was used to set this value: Field label Expected Value Comments Ordering service display name Team xx Ordering Service Set in Step 2 of 5 panel Number of ordering nodes 1 Default value from Step 2 of 5 panel Certificate Authority Team xx Ordering Service CA Set in Step 3 of 5 panel Ordering service enroll ID os1 Set in Step 3 of 5 panel Ordering service enroll secret os1pw Set in Step 3 of 5 panel Organization MSP Team xx Ordering Service MSP Set in Step 3 of 5 panel CPU (VPC) usage total 0.35 Not set by you- calculated from defaults Memory usage total 700 M Not set by you- calculated from defaults Storage usage total 100 Gi Not set by you- default value Associated identity Team xx Ordering Service MSP Admin Set in Step 4 of 5 panel Note If you have to use the Back button to make any corrections, you can return to the summary on Step 5 of 5 by clicking Next the necessary number of times. When you have ensured that you have entered the right values, click the blue Add ordering service button in the lower right of your screen: Step 10.7: You should see your new ordering service listed, along with a gray box in the upper right of its tile, showing that the status of this ordering service is \"pending\" if you hover your cursor over the gray box. It can take a minute or two on our lab system for the ordering service to come up completely, and you may need to refresh your browser in order to see the box turn green. If your ordering service is still not ready after a couple of minutes and after you have tried refreshing your browser, ask an instructor for help. The ordering service must be ready, as indicated by a green box in the upper right of its tile, similar to what is shown below, before you can continue. Caution This step pertains to the tile listed in the Ordering services section, not to the similarly named tile in the Certificate Authorities section Once it is ready, click on its tile and continue to the next section of the lab.","title":"Section 10: Create an ordering service node for your Ordering Service organization"},{"location":"ibpconsole/#section-11-add-your-teamxx-org1-organization-to-a-consortium","text":"Step 11.1: In the Consortium members section, which is below the Ordering service administrators section, click the Add organization button: Step 11.2: Click the Existing MSP ID button, select Team xx Org1 MSP (teamxxorg1msp) where xx is your two-digit team ID, and then click the Add organization button: Important Ensure that you select Team xx Org1 MSP (teamxxorg1msp) from the dropdown list. This will probably not be the default choice provided to you. Step 11.3: You should now see your peer organization, team xx org1msp , listed as a member of your consortium:","title":"Section 11: Add your Teamxx Org1 organization to a consortium"},{"location":"ibpconsole/#section-12-create-a-channel","text":"You won't get very far without an ordering service node, because they are the animals that create blocks. You won't get very far without a peer, as peers run smart contracts, which create transactions that are sent to an ordering service node. Well, you won't get much stuff done without a channel either, because a transaction proposal is sent from a peer to an ordering service node over a channel. You will define a channel in this section and in its definition you will make your Team xx Org1 peer organization a member of the channel. The actual definition of the channel is verified at the ordering service node and it keeps track of all channels. (You can define multiple channels in a Hyperledger Fabric network but for simplicity this lab will only have you define one). The line between the ordering service node and your first peer organization node represents that our ordering service knows about our new channel and that our peer organization is a member of the new channel: Step 12.1: Click the Channels icon in the icon palette on the left. The screenshot below shows which icon to click: Step 12.2: Click the Create channel button: Step 12.3: You may read the information on the Prerequisites panel, but you will not have to do anything- the prior sections of the lab have met the prerequisites! Click on the blue Next button to continue: Step 12.4: On the Channel details panel, enter team xx -channel1 in the Channel name field, and select Team xx Ordering Service for the Ordering service field, where xx is your two-digit team ID, then click the Next button to continue: Step 12.5: On the Organizations panel, select Team xx Org1 MSP (team xx org1msp) for the Channel member field and click the Add button to the right of your selection: Step 12.6: You should now see team xx org1msp listed in the Organizations section. Select the checkbox to the left of the word Operator in order to give your organization operator privileges on the channel. The Next button should become enabled once you do this, so click on it to continue: Step 12.7: On the Update policy panel, ensure that 1 out of 1 is selected in the Policy field and then click the Next button: Step 12.8: On the Organization creating channel panel, select Team xx Org1 MSP (team xx org1msp) from the dropdown list for the Channel creator MSP field, and select Team xx Org1 MSP Admin from the dropdown list for the Identity field, and then click the Next button: Step 12.9: On the Review channel information screen, ensure that the values you entered match what is shown in the following table, taking into account that xx should be your two-digit team ID: Left column (labels) Right column (values your provided) Channel name team xx -channel1 Ordering service Team xx Ordering Service_1 Organizations team xx org1msp Policy 1 out of 1 Organization creating channel Team xx Org1 MSP Identity for organization creating channel Team xx Org1 MSP Admin Note If you entered some values incorrectly, click the Back button as necessary to navigate back through the screen flow until you get to the screen(s) necessary to correct your mistakes, and then navigate forward again with the Next button until you return to this Review MSP information screen and verify you have entered the expected values. Ask an instructor for help if necessary. When you have ensured that you have entered the right values, click the blue Create MSP definition button in the lower right of your screen: Step 12.10: You should now see your channel listed. Click where it says Pending- add peer and continue to the next section:","title":"Section 12: Create a channel"},{"location":"ibpconsole/#section-13-join-your-teamxx-org1-peer-to-the-channel","text":"In the previous section you defined a channel, team xx channel1 , and made your Team xx Org1 organization a member of the channel. However, in order for a particular peer within that organization to participate in the channel, that peer has to join the channel. Our simple lab network only has one peer in the organization, but in most production implementations an organization will have multiple peers. When the peer joins a channel, it will receive all of the blocks in the channel that were created prior to the time the peer joined the channel, until it catches up. Our evolving network diagram only gets a subtle change from this section- the line from the ordering service node to the circle representing our organization, indicating that our organization is a member of the channel, has been extended with a line segment from the circle to our peer, indicating that our peer has now joined the channel: Step 13.1: For the Choose from available peers field, select Team xx Org1 Peer , where xx is your two-digit team ID, and click the Join channel button in the lower right: Note The Join channel button will not be enabled until you click on the peer name. Step 13.2: You should now see that instead of the Pending- add peer message at the bottom of the tile for your channel, it now says 2 Blocks . This indicates that the channel has been successfully created and you have joined a peer to it. Information The first block created in a channel is called the genesis block , and it contains configuration data for the channel. The second block in this channel is for a configuration transaction that defined Team xx Org1 Peer as an anchor peer for the Team xx Org1 organization. An anchor peer is a peer whose external endpoint address is published in the channel configuration. This way other organizations can reach this peer. An organization must provide at least one anchor peer for service discovery or private data collections to work.","title":"Section 13: Join your Teamxx Org1 peer to the channel"},{"location":"ibpconsole/#section-14-create-a-certificate-authority-for-your-second-peer-organization-teamxx-org2","text":"You have now already defined two organizations- Team xx Org1 and Team xx Ordering Service . The Ordering Service organization provides the ordering service and does not itself initiate blockchain transactions. Most, if not all, realistic blockchain networks will involve multiple organizations initiating blockchain transactions. So you will now define a second peer organization to participate in the network. Your network will thus have three organizations- two peer organizations that are collaborating in the blockchain network, and the ordering service organization which is, essentially, a service provider. You are changing hats again, this time from your Team xx Ordering Service administrator hat to your Team xx Org2 administrator hat. Our network diagram is coming along quite nicely: We will define the second peer organization now. The pattern is identical to what you did earlier for the first organization. Note This will be the third Certificate Authority you define in this lab, so we will show fewer screenshots of repetitive tasks, in this section and in subsequent sections. Step 14.1: Click the Nodes icon on the icon palette on the left, and then click the blue Add Certificate Authority button. Step 14.2: On the Step 1 of 3 sidebar panel, click Create a Certificate Authority and then click the blue Next button. Step 14.3: Fill in the Step 2 of 3 sidebar panel as follows, and then click the blue Next button: Field label Value Comments CA display name Team xx Org2 CA Substitute your two-digit team ID for xx CA administrator enroll ID admin CA administrator enroll secret adminpw Step 14.4: Review your settings on the Step 3 of 3 sidebar panel and click the Add Certificate Authority button: Step 14.5: You will see a tile for your new certificate authority. Observe the box in the upper right corner of the tile. If it is gray, and you hover your cursor over it, you may see a message indicating that the status is pending. In about a minute, the box in the upper right should turn green, indicating that the certificate authority is running. Note If the box in the upper right corner of the tile does not turn green in a minute or two, try reloading the page in your browser. Contact an instructor for help if it does not turn green and show the running status when you hover your cursor over this box. Once your certificate authority is running, click on its tile so that you can proceed to the next section where you will add users.","title":"Section 14: Create a Certificate Authority for your second peer organization, \"Teamxx Org2\""},{"location":"ibpconsole/#section-15-add-new-users-using-your-teamxx-org2-certificate-authority","text":"Step 15.1: You must first associate an administrative identity with your certificate authority, so click the Associate identity button as shown in this screen snippet: Step 15.2: Ensure that the Enroll ID Button is selected in the Associate Identity sidebar panel, fill out the panel as directed in the below table, and then click the blue Associate Identity button: Field label Value Comments Enroll ID admin Enroll secret adminpw click the \"eye\" icon to see the password Identity display name Team xx Org2 CA Admin substitute your two-digit team ID for xx Step 15.3: You should now see the admin userid in the list of registered users. This userid is intended to be used by a person acting as the registrar of this Certificate Authority. Next you will create a userid for use by a person who will be the blockchain network administrator for the organization. Click the Register user button on the right side of the screen: Step 15.4: In the Step 1 of 2 panel, fill it out as guided by the following table, and then click the blue Next button: Field label Value Comments Enroll ID org2admin Enroll secret org2adminpw click the \"eye\" icon to see the password Type admin Choose from dropdown list Step 15.5: We will not be using custom attributes in this lab, so all you have to do on this screen is click the Register user button. Step 15.6: You should now see the userid you just registered, org2admin , listed on the screen. You also need to create a userid that your peer node will operate as, so click the Register user button again. Step 15.7: In the Step 1 of 2 panel, fill it out as guided by the following table, and then click the blue Next button: Important It is critical that you change the value of the Type field from client to peer for this userid! Field label Value Comments Enroll ID peer2 Enroll secret peer2pw click the \"eye\" icon to see the password Type peer Choose from dropdown list Step 15.8: Just click the Register user button at the bottom of the screen. Step 15.9: You should now see the peer2 userid listed along with the others on this screen. Click the Organizations icon on the palette on the left of your screen and continue to the next section of the lab:","title":"Section 15: Add new users using your Teamxx Org2 Certificate Authority"},{"location":"ibpconsole/#section-16-create-an-msp-for-your-second-peer-organization","text":"Defining the MSP for Team xx Org2 will bring our network one step closer to fruition: Step 16.1: You should see the MSP definitions for your other two organizations. Click the blue Create MSP definition button. Step 16.2: Enter the following values as instructed here on the MSP definition details screen and click the Next button: Field label Value Comments MSP display name Team xx Org2 MSP substitute your two-digit team ID for xx MSP ID teamxxorg2msp substitute your two-digit team ID for xx Step 16.3: On the Root Certificate Authority details screen, select Team xx Org2 CA from the dropdown list. Once you have selected the root certificate authority, you will see that the Root certificates and TLS root certificates fields appear and are populated with apparent nonsense that is actually base64-encoded X.509 certificates. Important Ensure that you selected your certificate authority for your Org2 , and not Org1 , in the Root Certificate Authority field. It's easy to mistakenly choose Org1 's certificate authority here, and this often turns ecstasy to melancholy. Click the Next button. Step 16.4: On the Admin certificates screen, fill out the three fields beneath this in accordance with the below table, and then click the Generate button, which should become active once you enter values for the three fields: Field label Value Comments Enroll ID org2admin Select from dropdown list. It will not be the default presented to you, so make sure you select it. Enroll secret org2adminpw Identity name Team xx Org2 MSP Admin substitute your team ID for xx Step 16.5: The prior step generated a public certificate and a matching private key. This private key is stored by the IBM Blockchain Platform console in your local browser storage and nowhere else. In order to ensure that you can retrieve your private key later, you must now click the Export button which will prompt you to save your private key (along with the public certificate) in a JSON file on your hard drive. Step 16.6: Select the Save File radio button in the dialog window that appears, and click the OK button. Step 16.7: Save the exported JSON file in a location that you can remember. Note You probably won't need this saved file for this lab if you use the same browser window for the duration of the lab, but the saved file may be necessary if, for whatever reason, you do have to use a new browser window or session, so go ahead and save it! Step 16.8: Now that you have saved the exported certificate, click the blue Next button to proceed: Step 16.9: On the Review MSP information screen, ensure that the values you entered match what is shown in the following table, taking into account that xx should be your two-digit team ID: Left column (labels) Right column (values your provided) MSP display name Team xx Org2 MSP MSP ID teamxxorg2msp Admin certificate Team xx Org2 MSP Admin Selected CA Team xx Org2 CA Note If you entered some values incorrectly, click the Back button as necessary to navigate back through the screen flow until you get to the screen(s) necessary to correct your mistakes, and then navigate forward again with the Next button until you return to this Review MSP information screen and verify you have entered the expected values. Ask an instructor for help if necessary. When you have ensured that you have entered the right values, click the blue Create MSP definition button in the lower right of your screen. Step 16.9: You should now see the definition for your new MSP listed on your screen. Scroll up and click the Nodes icon in the icon palette on your left- it is the topmost icon on this palette- and you will be ready to proceed to the next section.","title":"Section 16: Create an MSP for your second peer organization"},{"location":"ibpconsole/#section-17-create-a-peer-node-for-your-second-peer-organization","text":"The most useful German phrase I know is noch einmal Bier, bitte! , which translates to another beer, please! So I am asking you kindly, noch einmal peer, bitte! , that is, please define a peer for your second organization: Step 17.1: Click the blue Add peer button. Step 17.2: Click the Create a peer button and then click the blue Next button. Step 17.3: Leave all of the Advanced deployment options unchecked. Type Team xx Org2 Peer , where xx is your two-digit team ID, in the Peer display name field and then click the blue Next button. Step 17.4: Enter or select the following values on the Step 3 of 5 panel as directed by the following table, and then click the blue Next button. Field label Value Comments Certificate Authority Team xx Org2 CA Select from dropdown list if this choice is not already presented to you, where xx is your two-digit team ID Peer enroll ID peer2 Select from dropdown list Peer enroll secret peer2pw Organization MSP Team xx Org2 MSP Select from dropdown list, where xx is your two-digit team ID TLS CSR hostname leave blank Step 17.5: On the Associate Identity screen, select Team xx Org2 MSP Admin , where xx is your two-digit team ID, for the Peer administrator identity field, and click Next . Step 17.6: The Summary panel provides a review of the values you entered or selected in the prior panels. You may need to scroll down to see all of the values. The values you entered should match up with the table below. If not, use the Back button as necessary to correct your entries. The table below shows the expected value (where xx is your two-digit team ID) and which of the seven panels in the Add Peer flow was used to set this value: Field label Expected Value Comments Peer display name Team xx Org2 Peer Set in Step 2 of 5 panel State database CouchDB Not set by you- default value Certificate Authority Team xx Org2 CA Set in Step 3 of 5 panel Peer enroll ID peer2 Set in Step 3 of 5 panel Peer enroll secret peer2pw Set in Step 3 of 5 panel Organization MSP Team xx Org2 MSP Set in Step 3 of 5 panel CPU (VPC) usage total 1.6 Not set by you- calculated from defaults Memory usage total 2,800M Not set by you- calculated from defaults Storage usage total 200Gi Not set by you- calculated from defaults Associated identity Team xx Org2 MSP Admin Set in Step 4 of 5 panel Note If you have to use the Back button to make any corrections, you can return to the summary on Step 5 of 5 by clicking Next the necessary number of times. When you have ensured that you have entered the right values, click the blue Add peer button in the lower right of your screen: Step 17.7: You should see your new peer listed, along with a gray box in the upper right of its tile, showing that the status of this peer is \"pending\" if you hover your cursor over the gray box. It can take a minute or two on our lab system for the peer to come up completely, and you may need to refresh your browser in order to see the box turn green. If your peer is still not ready after a couple of minutes and after you have tried refreshing your browser, ask an instructor for help. The peer must be ready, as indicated by a green box in the upper right of the peer's tile, similar to what is shown below, before you can continue:","title":"Section 17: Create a peer node for your second peer organization"},{"location":"ibpconsole/#section-18-add-your-teamxx-org2-organization-to-the-consortium","text":"Step 18.1: Click on your Team xx Orderin... tile (the full name is most likely truncated on your screen) under the Ordering services section: Note You may need to scroll down a little to see this. Ensure you click the tile in the Ordering services section and not the similarly named tile in the Certificate Authorities section- it is easy to make that mistake because the full names are truncated. Step 18.2: Click the blue Add organization button in the Consortium members section. Step 18.3: Click the Existing MSP ID button, select Team xx Org2 MSP (team xx org2msp) where xx is your two-digit team ID, and then click the Add organization button. Step 18.4: You should now see your second peer organization, team xx org2msp , listed as a member of your consortium.","title":"Section 18: Add your Teamxx Org2 organization to the consortium"},{"location":"ibpconsole/#section-19-add-your-teamxx-org2-organization-to-the-channel","text":"Team xx Org2 can now become a member of channels since you added it to the consortium in the prior section. Take advantage of that good fortune and add it as a member of your channel: When you created your team xx -channel1 channel earlier in the lab, your new Team xx Org2 organization did not exist yet. If it had existed at the time, you could have added it to the channel membership when you created the channel. You will add the organization to the channel membership now. Step 19.1: Click the Channels icon on the icon palette on the left: Step 19.2: Click the tile for your team xx -channel1 channel: Step 19.3: Click the Settings icon (the one that looks like a gear) a little underneath the channel name near the top of your screen: Step 19.4: In the Organization updating channel panel, select Team xx Org1 MSP (team xx org1msp) from the dropdown list for the Channel updater MSP field, select Team xx Org1 MSP Admin from the dropdown list for the Identity field, and then click the Next button: Step 19.5: On the Organizations panel, select Team xx Org2 MSP (team xx org2msp) from the dropdown list for the Channel member field, and then click the Add button to the right of the field: Step 19.6: Your team xx org2msp organization will now be listed under the Organizations section. Select the checkbox to the left of Operator in order to give this organization Operator authority on the channel. Click the Next button: Step 19.7: On the Update policy panel, select 1 out of 2 for the Policy field and then click the Next button: Step 19.8: From the Capabilities panel, click the Review channel information link, as you will not be updating any of the advanced configuration settings: Step 19.9: Review the top half of the information in the Review channel information panel. The bottom half of information, below the horizontal line, is for advanced settings that you did not change. Ensure that the information in the top half, which you did enter, corresponds to the table below, with xx corresponding to your two-digit team ID: Left column (labels) Right column (values your provided) Channel name team xx -channel1 Ordering service Team xx Ordering Service_1 Organizations team xx org1msp and team xx org2msp Policy 1 out of 2 Organization updating channel Team xx Org1 MSP Identity for organization updating channel Team xx Org1 MSP Admin Note If you entered some values incorrectly, click the Back button as necessary to navigate back through the screen flow until you get to the screen(s) necessary to correct your mistakes, and then navigate forward again with the Next button until you return to this Review MSP information screen and verify you have entered the expected values. Ask an instructor for help if necessary. When you have ensured that you have entered the right values, click the blue Update channel button in the lower right of your screen. Step 19.10: Notice that the block height is now three. The most recent block, that has an ID of 2 - block numbering starts at zero- contains a transaction that contains the configuration update you just made, which added your Team xx Org2 to the channel. Note Hyperledger Fabric distinguishes configuration update transactions from typical application transactions. The IBM Blockchain Platform console does not show details of configuration update transactions nor include them in the count of transactions that it will display. That is, if you display a block that has a configuration update transaction, the IBM Blockchain Platform console will show 0 transactions for that block. (A block of application transactions can contain multiple transactions, but a configuration update transaction is the only transaction in its block. That is, a block does not contain a mix of application transactions and configuration update transactions). Click the Channel details tab, which is to the right of the Transaction overview tab: Step 19.11: In the Channel members section of the panel, you should now see both of your peer organizations listed as members. Once you have verified this, click the Channels icon on the icon palette on the left: Note Although team xx org2msp is listed in the Channel members section, you don't see it listed above that in the Nodes section. That is because you have not joined a peer from team xx org2msp to the channel yet. You will do that next.","title":"Section 19: Add your Teamxx Org2 organization to the channel"},{"location":"ibpconsole/#section-20-join-your-teamxx-org2-peer-to-the-channel","text":"You will now join Team xx Org2 Peer to the channel: Step 20.1: Now that your Org2 is a member of the channel, you can join your peer from Org2 to the channel. Click the blue Join channel button: Step 20.2: Ensure that Team xx Ordering Service , where xx is your two-digit team ID, is selected for the Ordering service field and click the blue Next button: Step 20.3: Type team xx -channel1 , where xx is your two-digit team ID, in the Channel field and click the Next button: Step 20.4: In the Choose from available peers section, select Team xx Org2 Peer , where xx is your two-digit team ID, and then click the blue Join channel button: Step 20.5: You are returned to the Channels screen. Click the tile for your channel, team xx -channel1 : Step 20.6: Click the Channel details tab to the right of the Transaction overview tab: Step 20.7: Observe that your peer node for Org2 , Team xx Org2 Peer , is listed in the Nodes section, indicating that this peer has joined the channel: Congratulations!! You have made it to the end of this lab! Job well done! But after all that work you haven't run any smart contracts on your new network yet! Don't worry, that occurs in the next lab . You will not have toiled in vain.","title":"Section 20: Join your Teamxx Org2 peer to the channel"},{"location":"ibpdeploy/","text":"IBM Blockchain Platform v2.1.3 Lab Part 2 - Deploying a Smart Contract This lab will walk you through deploying the smart contract that you worked with from the VSCode labs: namely, commercial-paper . This lab assumes that you have successfully completed the IBM Blockchain Platform v2.1.3 Lab Part 1 - Create a Blockchain Network . If you have not completed part 1, you must do so before continuing with this lab. Section 1: Export Commercial Paper Smart Contract Remember from the VSCode labs, you have already packaged up the commercial paper ( papercontract@0.0.4 ) smart contract. Now you will export the contract to its own smart contract package ( in .cds format ) and deploy it to your IBM Blockchain Platform network. Note If you did not complete the VSCode labs, you can still continue with this lab. You need to download the .cds package here: commercial-paper and save it to your lab image under the /home/blockchain/ directory. Then you can skip to Section 2 of this lab. Step 1.1: Go back to your VSCode editor, and go to the IBM Blockchain Platform Extension view. Under the Smart Contract Packages panel, right-click on papercontract@0.0.4 and select Export Package : Step 1.2: Select the location /home/blockchain/ , and click Enter . Upon successful exporting, you will see a message like below: Section 2: Install Paper Contract to your Blockchain Network Step 2.1: Go back to your IBM Blockchain Platform Console at your assigned URL in your Firefox browser. Click on the Smart Contracts icon in the icon palette on the left, and in the Smart contracts panel, click the blue Install Smart Contract button: Step 2.2: In the (Step 1 of 2) Install Smart Contract side panel, using the blue Add File button, upload the papercontract@0.0.4.cds package (from the location /home/blockchain ), and click the Next button. The screenshot that follows shows that the name and version of the smart contract have replaced the Add File button: Step 2.3: Now select both peers (ensure each has a check mark to the right of it) and click the Install Smart Contract button. Note that in this lab we are installing to peers from two separate organizations. In most \"real world\" situations, the smart contract would be shared with members of the blockchain network, in a private Github repo or through some other means, and each organization would install the smart contract to its own peers through its own console. Step 2.4: Now, you should see papercontract appear in the Installed Smart Contracts section of the Smart Contracts screen: Section 3: Instantiate Paper Contract Step 3.1: From the Installed Smart Contracts section of the Smart Contracts panel, select the three dots to the right of papercontract and select Instantiate : Step 3.2: In the Instantiate smart contract (Step 1 of 5) sidebar panel, select team xx -channel1 , where xx is your two-digit team ID, in the Channel field and click the Next button: Step 3.3: In the Step 2 of 5 sidebar panel, select both peers in the Members list (ensure that each has a checkmark to the right of it), select 2 out of 2 members need to endorse transactions from the Policy dropdown list, and then click the Next button: Step 3.4: In the Step 3 of 5 sidebar panel, select Team xx Org1 Peer , where xx is your two-digit team ID, in the Peer field, as the peer to approve proposals for instantiating the smart contract, and click the Next button: Step 3.5: In the Step 4 of 5 sidebar panel, skip adding a private data collection and just click Next : Step 3.6: In the Step 5 of 5 sidebar panel, leave the function name blank (it will by default call the init function in the smart contract which is what we want for papercontract ) And leave the arguments box blank. Simply click the Instantiate smart contract button: Step 3.7: First time instantiation could take a while because the Node.js smart contract is pulling in all the package dependencies from the public NPM registry. After a few minutes, instantiation should complete. If you scroll down on the Smart Contracts panel, you will see the list of Instantiated Smart Contracts now includes papercontract : Read this if your instantiation failed If you receive a message indicating that an error occurred during instantiation, click the Show error details link. If it states that the grpc web client timed out the proposal after five minutes, simply click the Instantiate smart contract button again. There is a hard-coded timeout of five minutes, and sometimes in our lab system it takes just over five minutes to build the Docker image for the smart contract. Even if this timeout occurs, the Docker image does get built, so that if you try it again, the Docker image already exists, and you will most likely succeed on this second attempt in much less than five minutes. Now that you have the smart contract instantiated on the channel, you are ready to move on to the next step. Section 4: Register client user for TeamXX Org1 Now you need to register a client user to use to enroll application identities for Org1. In real life, as the blockchain network administrator for your organization, you might want to register a distinct client user for each business application that has a need to access the smart contract. In this case, the same client user is used to enroll a number of application identities. Another development pattern is to register a distinct client user for each distinct application identity. You can register a client user through the Fabric application SDK as well, though that is not covered in this lab. Step 4.1: Go to the Nodes view on your IBM Blockchain Platform Console, and navigate to the Certificate Authorities section. Then select Team xx Org1 CA , where xx is your two-digit team ID: Step 4.2: Select the Register user button: Step 4.3: In the Register User (Step 1 of 2) sidebar panel, fill in the fields as directed by the table below, and then click the Next button: Field label Value Comments Enroll ID app-dev Enroll secret app-devpw click the \"eye\" icon to see the password Type Client This will be populated for you Step 4.4: In the Register User (Step 2 of 2) sidebar panel, just click the Register user button. Step 4.5: Now you should see the app-dev user you added show up under Registered users : Section 5: Register client user for TeamXX Org2 (Optional) Now we will register a client user for enrolling application identities for Org2. This section is optional. In the sections that follow, you will only connect directly to Org1's peer. You will only need to register a client user for Org2 if you wish to connect to go above and beyond the steps in this lab and try connecting directly to Org2's peer. Step 5.1: Go to the Nodes view on your IBM Blockchain Platform Console, and navigate to the Certificate Authorities section. Then select Team xx Org2 CA , where xx is your two-digit team ID. Step 5.2. Follow the same steps from Section 4, Steps 4.2-4.5 in order to register a client user, also named app-dev , for Org2. Section 6: Download the connection profile to connect to TeamXX Org1 Peer The connection profile is a JSON file that describes all the connection endpoints, MSP information, channel information and certificate information required to connect to your organization's peer. A client application wishing to invoke transactions against a smart contract would require this file to obtain the necessary information needed to make that connection. Without IBM Blockchain Platform, this is a file you would put together yourself using existing sample connection profiles available in the Hyperledger Fabric community. With the IBM Blockchain Platform, you can download a ready-made file from the IBM Blockchain Platform Console. Step 6.1: Select the Smart contracts icon from the icon palette on the left, scroll down to the Instantiated smart contracts section, click on the three dots to the right of papercontract and click Connect with SDK : Step 6.2. In the Connect with SDK sidebar panel, you want to select the following (Remember to replace the xx below with your team number): MSP for connection: Teamxx Org1 MSP Certificate Authority: TeamXX Org1 CA And then click on the Download connection profile button at the bottom. You may need to scroll down in the sidebar panel to see this button. Use the file save dialog to save the profile under its default name of teamxx-channel1_papercontract_profile.json (where xx is your two-digit team ID). Keep track of where you saved this profile, as you will be using it in the next section. Click the Close button to close the sidebar panel after you have downloaded the connection profile. Section 7: Create a new Gateway in VSCode IBM Blockchain Platform Extension Note You will be using the IBM Blockchain Platform VSCode extension for the next few sections but leave your Firefox browser tab for the IBM Blockchain Platform Console open (you can minimize your browser window if you'd like) as you will be going back to it in the latter half of Section 10 . Now you can use that connection profile you just downloaded to create a new gateway in VSCode IBM Blockchain Platform Extension. Step 7.1: In the VSCode IBM Blockchain Platform view, click on the + in the Fabric Gateways panel (if you are still connected to your local gateway you will need to disconnect from this gateway first. You can do so by clicking on the door icon where the + should be): Step 7.2: Then in the popup window at the top of VSCode, select Create a gateway from a connection profile : Step 7.3: Next you will be asked to enter the name of the gateway. Type team xx -ibp , remembering to replace xx with your team number, and press Enter . Step 7.4: Finally, you will be asked to browse to the connection profile that you downloaded from Section 6 . Browse to it, and select Open . Step 7.5: Upon success, you will see team xx -ibp , where xx is your two-digit team ID, show up in the Fabric Gateways panel as follows: Section 8: Create a new wallet and identity in VSCode IBM Blockchain Platform Extension Step 8.1: In the VSCode IBM Blockchain Platform view, click on the + in the Fabric Wallets panel: Step 8.2. Select create a new wallet and add an identity in the popup window: Step 8.3: Type team xx -wallet in the next popup window, where xx is your two-digit team ID, and press Enter : Step 8.4: Type isabella as the name for the identity, and press Enter : Step 8.5: Type team xx org1msp as the MSPID, where xx is your two-digit team ID, and press Enter : Step 8.6: Pick Select a gateway and provide an enrollment ID and secret : Step 8.7: Choose team xx -ibp as the gateway you want to enroll and identity with, where xx is your two-digit team ID: Step 8.8: Type app-dev as the enrollment ID and press Enter : Step 8.9: Type app-devpw as the enrollment secret and press Enter : Step 8.10: Upon success you will see the new wallet and identity in the Fabric Wallets panel: Section 9: Connect to the teamxx-ibp gateway Now that you have created a wallet and enrolled an ID and password, you are ready to connect to the teamxx-ibp gateway. Step 9.1: Click on team xx -ibp , in the Fabric Gateways panel, where xx is your two-digit team ID: Step 9.2: In the popup window, select team xx -wallet , where xx is your two-digit team ID: Step 9.3: Upon success, you will also see your new gateway represented in the Fabric Gateways panel. Expand the twisties until you see your papercontract transactions: Section 10: Issue a transaction to test the connection Now we are ready to submit a test transaction. Step 10.1: From the Fabric Gateways panel, expand into the papercontract@0.0.4 contract, right-click on the issue transaction and select Submit Transaction : Step 10.2: Copy and paste the following inside the brackets as the argument, and then press Enter : MagnetoCorp , 00002 , 2020-07-31 , 2020-12-31 , 6000000 Example: Step 10.3: Press Enter on the transient data popup window. Read this if your transaction timed out This step may take several minutes. When you instantiated the smart contract in Section 3 , it built a Docker image for the smart contract on only one peer, the peer on which you chose to run the instantiate proposal (see Step 3.4 ). The Docker image for the other peer will be built on first use, and this transaction may time out. If it does, simply run steps 10.1 through 10.3 again, and it should succeed this time. Step 10.4: Upon success you will see the results from the issue transaction in the OUTPUT panel in VSCode, similar to what is shown here: [4/15/2020 4:49:08 PM] [INFO] submitTransaction [4/15/2020 4:49:15 PM] [INFO] submitting transaction issue with args MagnetoCorp,00002,2020-07-31,2020-12-31,6000000 on channel teamxx-channel1 [4/15/2020 4:49:26 PM] [SUCCESS] Returned value from issue: { class : org.papernet.commercialpaper , key : \\ MagnetoCorp\\ :\\ 00002\\ , currentState :1, issuer : MagnetoCorp , paperNumber : 00002 , issueDateTime : 2020-07-31 , maturityDateTime : 2020-12-31 , faceValue : 6000000 , owner : MagnetoCorp } Step 10.5: Now, return to the IBM Blockchain Platform Console at your assigned URL in Firefox. Go to the Channels view, and click on the team xx -channel1 tile, where xx is your two-digit team ID: Step 10.6: You should see that the block height is now 6. In the Block History section, click on the block at the top of the table: Step 10.7: Now you will see a list of transactions in block #5. Click on the topmost transaction (there should only be one): Step 10.8: In the Transaction sidebar panel you should see the issue transaction and its input arguments in the Input section, and the output of the transaction in the Output section, from the transaction that you just submitted via the VSCode IBM Blockchain Platform Extension. Step 10.9: OPTIONAL: you can submit additional transactions through VSCode, and watch the block height increase and look at the transaction in the IBM Blockchain Platform Console. Congratulations!! You've now successfully enrolled an application identity and used it to invoke transactions against a smart contract deployed to IBM Blockchain Platform v2.1.3!","title":"Part 2 - Deploy Smart Contract"},{"location":"ibpdeploy/#ibm-blockchain-platform-v213-lab-part-2-deploying-a-smart-contract","text":"This lab will walk you through deploying the smart contract that you worked with from the VSCode labs: namely, commercial-paper . This lab assumes that you have successfully completed the IBM Blockchain Platform v2.1.3 Lab Part 1 - Create a Blockchain Network . If you have not completed part 1, you must do so before continuing with this lab.","title":"IBM Blockchain Platform v2.1.3 Lab Part 2 - Deploying a Smart Contract"},{"location":"ibpdeploy/#section-1-export-commercial-paper-smart-contract","text":"Remember from the VSCode labs, you have already packaged up the commercial paper ( papercontract@0.0.4 ) smart contract. Now you will export the contract to its own smart contract package ( in .cds format ) and deploy it to your IBM Blockchain Platform network. Note If you did not complete the VSCode labs, you can still continue with this lab. You need to download the .cds package here: commercial-paper and save it to your lab image under the /home/blockchain/ directory. Then you can skip to Section 2 of this lab. Step 1.1: Go back to your VSCode editor, and go to the IBM Blockchain Platform Extension view. Under the Smart Contract Packages panel, right-click on papercontract@0.0.4 and select Export Package : Step 1.2: Select the location /home/blockchain/ , and click Enter . Upon successful exporting, you will see a message like below:","title":"Section 1: Export Commercial Paper Smart Contract"},{"location":"ibpdeploy/#section-2-install-paper-contract-to-your-blockchain-network","text":"Step 2.1: Go back to your IBM Blockchain Platform Console at your assigned URL in your Firefox browser. Click on the Smart Contracts icon in the icon palette on the left, and in the Smart contracts panel, click the blue Install Smart Contract button: Step 2.2: In the (Step 1 of 2) Install Smart Contract side panel, using the blue Add File button, upload the papercontract@0.0.4.cds package (from the location /home/blockchain ), and click the Next button. The screenshot that follows shows that the name and version of the smart contract have replaced the Add File button: Step 2.3: Now select both peers (ensure each has a check mark to the right of it) and click the Install Smart Contract button. Note that in this lab we are installing to peers from two separate organizations. In most \"real world\" situations, the smart contract would be shared with members of the blockchain network, in a private Github repo or through some other means, and each organization would install the smart contract to its own peers through its own console. Step 2.4: Now, you should see papercontract appear in the Installed Smart Contracts section of the Smart Contracts screen:","title":"Section 2: Install Paper Contract to your Blockchain Network"},{"location":"ibpdeploy/#section-3-instantiate-paper-contract","text":"Step 3.1: From the Installed Smart Contracts section of the Smart Contracts panel, select the three dots to the right of papercontract and select Instantiate : Step 3.2: In the Instantiate smart contract (Step 1 of 5) sidebar panel, select team xx -channel1 , where xx is your two-digit team ID, in the Channel field and click the Next button: Step 3.3: In the Step 2 of 5 sidebar panel, select both peers in the Members list (ensure that each has a checkmark to the right of it), select 2 out of 2 members need to endorse transactions from the Policy dropdown list, and then click the Next button: Step 3.4: In the Step 3 of 5 sidebar panel, select Team xx Org1 Peer , where xx is your two-digit team ID, in the Peer field, as the peer to approve proposals for instantiating the smart contract, and click the Next button: Step 3.5: In the Step 4 of 5 sidebar panel, skip adding a private data collection and just click Next : Step 3.6: In the Step 5 of 5 sidebar panel, leave the function name blank (it will by default call the init function in the smart contract which is what we want for papercontract ) And leave the arguments box blank. Simply click the Instantiate smart contract button: Step 3.7: First time instantiation could take a while because the Node.js smart contract is pulling in all the package dependencies from the public NPM registry. After a few minutes, instantiation should complete. If you scroll down on the Smart Contracts panel, you will see the list of Instantiated Smart Contracts now includes papercontract : Read this if your instantiation failed If you receive a message indicating that an error occurred during instantiation, click the Show error details link. If it states that the grpc web client timed out the proposal after five minutes, simply click the Instantiate smart contract button again. There is a hard-coded timeout of five minutes, and sometimes in our lab system it takes just over five minutes to build the Docker image for the smart contract. Even if this timeout occurs, the Docker image does get built, so that if you try it again, the Docker image already exists, and you will most likely succeed on this second attempt in much less than five minutes. Now that you have the smart contract instantiated on the channel, you are ready to move on to the next step.","title":"Section 3: Instantiate Paper Contract"},{"location":"ibpdeploy/#section-4-register-client-user-for-teamxx-org1","text":"Now you need to register a client user to use to enroll application identities for Org1. In real life, as the blockchain network administrator for your organization, you might want to register a distinct client user for each business application that has a need to access the smart contract. In this case, the same client user is used to enroll a number of application identities. Another development pattern is to register a distinct client user for each distinct application identity. You can register a client user through the Fabric application SDK as well, though that is not covered in this lab. Step 4.1: Go to the Nodes view on your IBM Blockchain Platform Console, and navigate to the Certificate Authorities section. Then select Team xx Org1 CA , where xx is your two-digit team ID: Step 4.2: Select the Register user button: Step 4.3: In the Register User (Step 1 of 2) sidebar panel, fill in the fields as directed by the table below, and then click the Next button: Field label Value Comments Enroll ID app-dev Enroll secret app-devpw click the \"eye\" icon to see the password Type Client This will be populated for you Step 4.4: In the Register User (Step 2 of 2) sidebar panel, just click the Register user button. Step 4.5: Now you should see the app-dev user you added show up under Registered users :","title":"Section 4: Register client user for TeamXX Org1"},{"location":"ibpdeploy/#section-5-register-client-user-for-teamxx-org2-optional","text":"Now we will register a client user for enrolling application identities for Org2. This section is optional. In the sections that follow, you will only connect directly to Org1's peer. You will only need to register a client user for Org2 if you wish to connect to go above and beyond the steps in this lab and try connecting directly to Org2's peer. Step 5.1: Go to the Nodes view on your IBM Blockchain Platform Console, and navigate to the Certificate Authorities section. Then select Team xx Org2 CA , where xx is your two-digit team ID. Step 5.2. Follow the same steps from Section 4, Steps 4.2-4.5 in order to register a client user, also named app-dev , for Org2.","title":"Section 5: Register client user for TeamXX Org2 (Optional)"},{"location":"ibpdeploy/#section-6-download-the-connection-profile-to-connect-to-teamxx-org1-peer","text":"The connection profile is a JSON file that describes all the connection endpoints, MSP information, channel information and certificate information required to connect to your organization's peer. A client application wishing to invoke transactions against a smart contract would require this file to obtain the necessary information needed to make that connection. Without IBM Blockchain Platform, this is a file you would put together yourself using existing sample connection profiles available in the Hyperledger Fabric community. With the IBM Blockchain Platform, you can download a ready-made file from the IBM Blockchain Platform Console. Step 6.1: Select the Smart contracts icon from the icon palette on the left, scroll down to the Instantiated smart contracts section, click on the three dots to the right of papercontract and click Connect with SDK : Step 6.2. In the Connect with SDK sidebar panel, you want to select the following (Remember to replace the xx below with your team number): MSP for connection: Teamxx Org1 MSP Certificate Authority: TeamXX Org1 CA And then click on the Download connection profile button at the bottom. You may need to scroll down in the sidebar panel to see this button. Use the file save dialog to save the profile under its default name of teamxx-channel1_papercontract_profile.json (where xx is your two-digit team ID). Keep track of where you saved this profile, as you will be using it in the next section. Click the Close button to close the sidebar panel after you have downloaded the connection profile.","title":"Section 6: Download the connection profile to connect to TeamXX Org1 Peer"},{"location":"ibpdeploy/#section-7-create-a-new-gateway-in-vscode-ibm-blockchain-platform-extension","text":"Note You will be using the IBM Blockchain Platform VSCode extension for the next few sections but leave your Firefox browser tab for the IBM Blockchain Platform Console open (you can minimize your browser window if you'd like) as you will be going back to it in the latter half of Section 10 . Now you can use that connection profile you just downloaded to create a new gateway in VSCode IBM Blockchain Platform Extension. Step 7.1: In the VSCode IBM Blockchain Platform view, click on the + in the Fabric Gateways panel (if you are still connected to your local gateway you will need to disconnect from this gateway first. You can do so by clicking on the door icon where the + should be): Step 7.2: Then in the popup window at the top of VSCode, select Create a gateway from a connection profile : Step 7.3: Next you will be asked to enter the name of the gateway. Type team xx -ibp , remembering to replace xx with your team number, and press Enter . Step 7.4: Finally, you will be asked to browse to the connection profile that you downloaded from Section 6 . Browse to it, and select Open . Step 7.5: Upon success, you will see team xx -ibp , where xx is your two-digit team ID, show up in the Fabric Gateways panel as follows:","title":"Section 7: Create a new Gateway in VSCode IBM Blockchain Platform Extension"},{"location":"ibpdeploy/#section-8-create-a-new-wallet-and-identity-in-vscode-ibm-blockchain-platform-extension","text":"Step 8.1: In the VSCode IBM Blockchain Platform view, click on the + in the Fabric Wallets panel: Step 8.2. Select create a new wallet and add an identity in the popup window: Step 8.3: Type team xx -wallet in the next popup window, where xx is your two-digit team ID, and press Enter : Step 8.4: Type isabella as the name for the identity, and press Enter : Step 8.5: Type team xx org1msp as the MSPID, where xx is your two-digit team ID, and press Enter : Step 8.6: Pick Select a gateway and provide an enrollment ID and secret : Step 8.7: Choose team xx -ibp as the gateway you want to enroll and identity with, where xx is your two-digit team ID: Step 8.8: Type app-dev as the enrollment ID and press Enter : Step 8.9: Type app-devpw as the enrollment secret and press Enter : Step 8.10: Upon success you will see the new wallet and identity in the Fabric Wallets panel:","title":"Section 8: Create a new wallet and identity in VSCode IBM Blockchain Platform Extension"},{"location":"ibpdeploy/#section-9-connect-to-the-teamxx-ibp-gateway","text":"Now that you have created a wallet and enrolled an ID and password, you are ready to connect to the teamxx-ibp gateway. Step 9.1: Click on team xx -ibp , in the Fabric Gateways panel, where xx is your two-digit team ID: Step 9.2: In the popup window, select team xx -wallet , where xx is your two-digit team ID: Step 9.3: Upon success, you will also see your new gateway represented in the Fabric Gateways panel. Expand the twisties until you see your papercontract transactions:","title":"Section 9: Connect to the teamxx-ibp gateway"},{"location":"ibpdeploy/#section-10-issue-a-transaction-to-test-the-connection","text":"Now we are ready to submit a test transaction. Step 10.1: From the Fabric Gateways panel, expand into the papercontract@0.0.4 contract, right-click on the issue transaction and select Submit Transaction : Step 10.2: Copy and paste the following inside the brackets as the argument, and then press Enter : MagnetoCorp , 00002 , 2020-07-31 , 2020-12-31 , 6000000 Example: Step 10.3: Press Enter on the transient data popup window. Read this if your transaction timed out This step may take several minutes. When you instantiated the smart contract in Section 3 , it built a Docker image for the smart contract on only one peer, the peer on which you chose to run the instantiate proposal (see Step 3.4 ). The Docker image for the other peer will be built on first use, and this transaction may time out. If it does, simply run steps 10.1 through 10.3 again, and it should succeed this time. Step 10.4: Upon success you will see the results from the issue transaction in the OUTPUT panel in VSCode, similar to what is shown here: [4/15/2020 4:49:08 PM] [INFO] submitTransaction [4/15/2020 4:49:15 PM] [INFO] submitting transaction issue with args MagnetoCorp,00002,2020-07-31,2020-12-31,6000000 on channel teamxx-channel1 [4/15/2020 4:49:26 PM] [SUCCESS] Returned value from issue: { class : org.papernet.commercialpaper , key : \\ MagnetoCorp\\ :\\ 00002\\ , currentState :1, issuer : MagnetoCorp , paperNumber : 00002 , issueDateTime : 2020-07-31 , maturityDateTime : 2020-12-31 , faceValue : 6000000 , owner : MagnetoCorp } Step 10.5: Now, return to the IBM Blockchain Platform Console at your assigned URL in Firefox. Go to the Channels view, and click on the team xx -channel1 tile, where xx is your two-digit team ID: Step 10.6: You should see that the block height is now 6. In the Block History section, click on the block at the top of the table: Step 10.7: Now you will see a list of transactions in block #5. Click on the topmost transaction (there should only be one): Step 10.8: In the Transaction sidebar panel you should see the issue transaction and its input arguments in the Input section, and the output of the transaction in the Output section, from the transaction that you just submitted via the VSCode IBM Blockchain Platform Extension. Step 10.9: OPTIONAL: you can submit additional transactions through VSCode, and watch the block height increase and look at the transaction in the IBM Blockchain Platform Console. Congratulations!! You've now successfully enrolled an application identity and used it to invoke transactions against a smart contract deployed to IBM Blockchain Platform v2.1.3!","title":"Section 10: Issue a transaction to test the connection"},{"location":"immunichain-home/","text":"Immunichain Guided Tour What is Immunichain? Immunichain is the tracking of immunization records of a child on the blockchain. The participants in the network include: a guardian, a medical provider and a member organization (think of summer camp or a high school athletic department). Between these participants, we are granting or revoking access to the child's immunization record. If you are a medical provider and have access to the child's immunization record, you can administor new immunizations. Additionally, if you are a member, you can view the child's immunization record if you have access to it. Why would we grant access for a member to our child's immunization record? Well, for example, each summer millions of kids go to summer camp. Tradtionally, each summer camp needs to verify that the child has had all their shots. In today's world, the guardian or the doctor has to fill out a form explaining that the child has had all their immunization shots. In tomorrow's world, we can utilize blockchain to not only stop having to fill out paper forms of maybe incorrect information, but we can simply allow the member to view the records and - once approved - we can revoke their access so that they don't keep the child's information. How did Immunichain Come About? Immunichain came from an IBM internal Blockchain hackathon in May of 2017. Around the same time, an Open Mainframe Project intern Kevin Lee from University of Illinois at Urbana-Champaign was tasked to use this use case to make a blockchain application. He ended up making this application that you are going to use today. The use case is a true story for on of our co-workers, as her grandson lived in 3 different countries before coming to the US. Transferring her grandson's medical records took a very long time due to the complications of the US law and information the other 3 countries were providing. While the medical records were being transferred, her grandson ended up having the same immunization shots multiple times - which can be harmful to the child. They finally were able to get the medical record transferred to a US doctor and the child is doing well today. While the original intent of this use case was for children, you can think of doing a similar use case with pets and their shot records. What are you going to accomplish today? Today, you will take a guided tour of the Immunichain UI. This UI will allow you to create a guardian, medical provider and a member organization. Once you have a guardian you can create a child (it's that simple...) and grant access to your medical provider and member organzations. Based on whether or not you have granted access or revoked access, the participants will be able to administor new immunization shots or read the child's immunization record. Underneath this UI, is the blockchain network doing all the work for you through REST API calls. If you took this to your friend, they should not even know that blockchain is doing all the work underneath the covers. In a real world application, Immunichain would be split up into 3 different UI's comprised of our 3 participants. Pre-Requisites for Mac Web Browser (Chrome preferably) Internet connectively Pre-Requisites for Microsoft Web Browser (Chrome preferably) Internet connectively Author Austin Grice","title":"Immunichain Guided Tour"},{"location":"immunichain-home/#immunichain-guided-tour","text":"","title":"Immunichain Guided Tour"},{"location":"immunichain-home/#what-is-immunichain","text":"Immunichain is the tracking of immunization records of a child on the blockchain. The participants in the network include: a guardian, a medical provider and a member organization (think of summer camp or a high school athletic department). Between these participants, we are granting or revoking access to the child's immunization record. If you are a medical provider and have access to the child's immunization record, you can administor new immunizations. Additionally, if you are a member, you can view the child's immunization record if you have access to it. Why would we grant access for a member to our child's immunization record? Well, for example, each summer millions of kids go to summer camp. Tradtionally, each summer camp needs to verify that the child has had all their shots. In today's world, the guardian or the doctor has to fill out a form explaining that the child has had all their immunization shots. In tomorrow's world, we can utilize blockchain to not only stop having to fill out paper forms of maybe incorrect information, but we can simply allow the member to view the records and - once approved - we can revoke their access so that they don't keep the child's information.","title":"What is Immunichain?"},{"location":"immunichain-home/#how-did-immunichain-come-about","text":"Immunichain came from an IBM internal Blockchain hackathon in May of 2017. Around the same time, an Open Mainframe Project intern Kevin Lee from University of Illinois at Urbana-Champaign was tasked to use this use case to make a blockchain application. He ended up making this application that you are going to use today. The use case is a true story for on of our co-workers, as her grandson lived in 3 different countries before coming to the US. Transferring her grandson's medical records took a very long time due to the complications of the US law and information the other 3 countries were providing. While the medical records were being transferred, her grandson ended up having the same immunization shots multiple times - which can be harmful to the child. They finally were able to get the medical record transferred to a US doctor and the child is doing well today. While the original intent of this use case was for children, you can think of doing a similar use case with pets and their shot records.","title":"How did Immunichain Come About?"},{"location":"immunichain-home/#what-are-you-going-to-accomplish-today","text":"Today, you will take a guided tour of the Immunichain UI. This UI will allow you to create a guardian, medical provider and a member organization. Once you have a guardian you can create a child (it's that simple...) and grant access to your medical provider and member organzations. Based on whether or not you have granted access or revoked access, the participants will be able to administor new immunization shots or read the child's immunization record. Underneath this UI, is the blockchain network doing all the work for you through REST API calls. If you took this to your friend, they should not even know that blockchain is doing all the work underneath the covers. In a real world application, Immunichain would be split up into 3 different UI's comprised of our 3 participants.","title":"What are you going to accomplish today?"},{"location":"immunichain-home/#pre-requisites-for-mac","text":"Web Browser (Chrome preferably) Internet connectively","title":"Pre-Requisites for Mac"},{"location":"immunichain-home/#pre-requisites-for-microsoft","text":"Web Browser (Chrome preferably) Internet connectively","title":"Pre-Requisites for Microsoft"},{"location":"immunichain-home/#author","text":"Austin Grice","title":"Author"},{"location":"immunichain/","text":"Part 1: Immunichain Walk Through Section 1: Create your Participants Child 1. Begin by going to the Immunichain UI below: https://immunichain.zcloud.marist.edu/login/ 2. Click on Create an account 3. You will be prompted to fill out a profile for your participant. In the Role field, select your participant (Guardian, Healthcare Provider and Member Organization). Based on your role, fill out the rest of the information. NOTE: You will want to make your profile specific to you. As everyone is creating their participant, it is being inserted into one database. By the time you create your participants, there could be multiple medical providers and member organizations. If you make them specific to you, you will know which medical provider and member organiation to assign to your child. Here is my guardian: 4. Once you have successfully created a guardian, you will be welcomed with the guardian's homepage 5. Once you have looked through the available options for our guardian, you can click on logout in the top right 6. Once you are on the Immunichain homepage, you can click on Create an account once more. This time, make a healthcare provider Here is my healthcare provider: 7. Once you have made your healthcare provider, you will be graced with its profile 8. Once you have looked through the available options for our healthcare provider, you can click on logout in the top right 9. Once you are on the Immunichain homepage, you can click on Create an account once more. This time, make a member organization Here is my member organization: 10. Once you have made you member organization, you will be greeted with its profile 11. Look through the available options for our member organization. Once you are finished, you can click on logout in the top right Section 2: Create a Child and Grant Access 1. You should be on the Immunichain homepage. If you are log into your guardian 2. Once you get to your guardian's profile, scroll down and click on Continue of Add a Child 3. Fill out the information for our hypothetical child and choose the healthcare provider and member organization that you created NOTE Remember how I said - at the beginning - that there would be multiple healthcare providers and members to choose from, you now know why I said to make the participants specific to you. 4. Click on Submit once you have filled out your child's information 5. Click on return home and that should take you back to the guardian's profile. Now that you think you have create a child, you can confirm by click on Continue of View Record 6. Select our new child and click on Continue 7. You should now see all the information you just filled in for our child 8. You will notice that we have already granted access for our healthcare provider, Suzie, and then our member organization, KennysCamp. If you did not grant access for our other participants when creating the child, you will see blank information in the Medical Providers and Member Organizations section. You can change that by going to the guardian's profile and then click on Authorize Member or Add Medical Provider Section 3: Add Immunizations 1. Navigate your way back to the Immunichain homepage. Once you are there, log into our member organization 2. Click on Continue of the View Record tile 3. You should only see the children in which we have access to - in this case, it should only be BabyDennis 4. Click on Continue and you should see all of Dennis's information 5. You will notice, that there are no immunization shots on Dennis's record. Let's change that. We can do that by logging out of our Member and then logging into our Healthcare Provider 6. Once you get to the medical providers homepage, click on Continue of Add Immunization . Then select our child, Dennis . 7. You should now be on the screen to add immunizations for Dennis. Go ahead and give Dennis an immunization shot with today's date 8. Go ahead and click on Submit to add this immunization shot. Once you have done that, you will should see a Success message 9. Now that we have successfully added an immunization shot, we can see if our member can see it on their end. You can do that by logging out of the healthcare provider and then logging into our member. 10. Once you are on the member's profile, you can click on Continue of the View Record tile and selecting Dennis. 11. Now that we have selected Dennis, you can see see the updated information of Dennis's immunization shot 12. Imagine if you were a SummerCamp or another member participant that needs childrens medical shot record. Doing this digital increases the accuracy of the data due to the healthcare provider inputting the data right when the shot was administered. Additionally, this will allow them to increase their efficency of approving children into their camp, for example. Now if you were a guardian and a summer camp already approved your child, we would want to revoke that member from seeing our child's immunization record. How do we do that? We will do exactly that in the next section. Section 4: Revoking Access 1. Navigate back to Immunchain's homepage and log into the Guardian's profile 2. Click on Continue of the Deauthorize Member tile 3. Select Dennis as our child and then select our Member, KennysCamp, as the one we revoking access to 4. You should get a Success message once click on Submit of the revoking our member 5. Now, log out of our guardian and log into our medical provider 6. Once in the medical provider's profile, click on Continue of the Add Immunization tile 7. Select our child, Dennis, and then add another immunization to his record 8. Once you get the Success message, click on Back to Home . 9. You should still be in the guardian's profile. Since you are, click on Continue of the View Record tile. Then select our child, Dennis. You should then see Dennis's updated immunization record 10. Log out of our medical provider and then log into our member, KennysCamp. 11. Click on Continue of the View Record tile. You should see the message of: You do not have any children . This means the KennysCamp can't view Dennis's immunization record anymore. Optional: If you want to grant KennysCamp as a member again, you can go back into the guardian's profile. Once there, you can click on Continue of the Authorize Member tile. Then you can grant KennysCamp as an authorized member for Dennis. Now if you go back to KennysCamp, click on Continue of the View Record tile and you should see the updated information for Dennis. End of Lab","title":"Immunichain"},{"location":"immunichain/#part-1-immunichain-walk-through","text":"","title":"Part 1: Immunichain Walk Through"},{"location":"immunichain/#section-1-create-your-participants-child","text":"1. Begin by going to the Immunichain UI below: https://immunichain.zcloud.marist.edu/login/ 2. Click on Create an account 3. You will be prompted to fill out a profile for your participant. In the Role field, select your participant (Guardian, Healthcare Provider and Member Organization). Based on your role, fill out the rest of the information. NOTE: You will want to make your profile specific to you. As everyone is creating their participant, it is being inserted into one database. By the time you create your participants, there could be multiple medical providers and member organizations. If you make them specific to you, you will know which medical provider and member organiation to assign to your child. Here is my guardian: 4. Once you have successfully created a guardian, you will be welcomed with the guardian's homepage 5. Once you have looked through the available options for our guardian, you can click on logout in the top right 6. Once you are on the Immunichain homepage, you can click on Create an account once more. This time, make a healthcare provider Here is my healthcare provider: 7. Once you have made your healthcare provider, you will be graced with its profile 8. Once you have looked through the available options for our healthcare provider, you can click on logout in the top right 9. Once you are on the Immunichain homepage, you can click on Create an account once more. This time, make a member organization Here is my member organization: 10. Once you have made you member organization, you will be greeted with its profile 11. Look through the available options for our member organization. Once you are finished, you can click on logout in the top right","title":"Section 1: Create your Participants &amp; Child"},{"location":"immunichain/#section-2-create-a-child-and-grant-access","text":"1. You should be on the Immunichain homepage. If you are log into your guardian 2. Once you get to your guardian's profile, scroll down and click on Continue of Add a Child 3. Fill out the information for our hypothetical child and choose the healthcare provider and member organization that you created NOTE Remember how I said - at the beginning - that there would be multiple healthcare providers and members to choose from, you now know why I said to make the participants specific to you. 4. Click on Submit once you have filled out your child's information 5. Click on return home and that should take you back to the guardian's profile. Now that you think you have create a child, you can confirm by click on Continue of View Record 6. Select our new child and click on Continue 7. You should now see all the information you just filled in for our child 8. You will notice that we have already granted access for our healthcare provider, Suzie, and then our member organization, KennysCamp. If you did not grant access for our other participants when creating the child, you will see blank information in the Medical Providers and Member Organizations section. You can change that by going to the guardian's profile and then click on Authorize Member or Add Medical Provider","title":"Section 2: Create a Child and Grant Access"},{"location":"immunichain/#section-3-add-immunizations","text":"1. Navigate your way back to the Immunichain homepage. Once you are there, log into our member organization 2. Click on Continue of the View Record tile 3. You should only see the children in which we have access to - in this case, it should only be BabyDennis 4. Click on Continue and you should see all of Dennis's information 5. You will notice, that there are no immunization shots on Dennis's record. Let's change that. We can do that by logging out of our Member and then logging into our Healthcare Provider 6. Once you get to the medical providers homepage, click on Continue of Add Immunization . Then select our child, Dennis . 7. You should now be on the screen to add immunizations for Dennis. Go ahead and give Dennis an immunization shot with today's date 8. Go ahead and click on Submit to add this immunization shot. Once you have done that, you will should see a Success message 9. Now that we have successfully added an immunization shot, we can see if our member can see it on their end. You can do that by logging out of the healthcare provider and then logging into our member. 10. Once you are on the member's profile, you can click on Continue of the View Record tile and selecting Dennis. 11. Now that we have selected Dennis, you can see see the updated information of Dennis's immunization shot 12. Imagine if you were a SummerCamp or another member participant that needs childrens medical shot record. Doing this digital increases the accuracy of the data due to the healthcare provider inputting the data right when the shot was administered. Additionally, this will allow them to increase their efficency of approving children into their camp, for example. Now if you were a guardian and a summer camp already approved your child, we would want to revoke that member from seeing our child's immunization record. How do we do that? We will do exactly that in the next section.","title":"Section 3: Add Immunizations"},{"location":"immunichain/#section-4-revoking-access","text":"1. Navigate back to Immunchain's homepage and log into the Guardian's profile 2. Click on Continue of the Deauthorize Member tile 3. Select Dennis as our child and then select our Member, KennysCamp, as the one we revoking access to 4. You should get a Success message once click on Submit of the revoking our member 5. Now, log out of our guardian and log into our medical provider 6. Once in the medical provider's profile, click on Continue of the Add Immunization tile 7. Select our child, Dennis, and then add another immunization to his record 8. Once you get the Success message, click on Back to Home . 9. You should still be in the guardian's profile. Since you are, click on Continue of the View Record tile. Then select our child, Dennis. You should then see Dennis's updated immunization record 10. Log out of our medical provider and then log into our member, KennysCamp. 11. Click on Continue of the View Record tile. You should see the message of: You do not have any children . This means the KennysCamp can't view Dennis's immunization record anymore. Optional: If you want to grant KennysCamp as a member again, you can go back into the guardian's profile. Once there, you can click on Continue of the Authorize Member tile. Then you can grant KennysCamp as an authorized member for Dennis. Now if you go back to KennysCamp, click on Continue of the View Record tile and you should see the updated information for Dennis. End of Lab","title":"Section 4: Revoking Access"},{"location":"index_walmart/","text":"Blockchain Immersion Wildfire Workshop Welcome! This two-day workshop combines lectures and hands-on labs to teach you the fundamentals of blockchain for business. On Day 1, we focus on the open source framework called Hyperledger Fabric that powers blockchain for business. On Day 2, you will learn about the IBM-specific offerings that leverage Hyperledger Fabric, and how our unique combination of expertise, governance and operations tooling, and infrastructure capabilities with Linux on Z can help you achieve business results faster and more securely. Agenda Day 1 8:45am - Introductions 9am - Lecture: Hyperledger Fabric Technology Deep Dive Part 1 10am - Lab: Developer Journey with VSCode and the IBM Blockchain Platform Extension 10:15am - Lab: Developer Journey Part 1 - Create Smart Contract Package 11am - Lab: Developer Journey Part 2 - Commercial Paper Noon - Lunch 1pm - Lecture: Hyperledger Fabric Technology Deep Dive Part 2 2pm - Lab: Developer Journey Part 3 - Cross Chaincode Calls and Debug 3pm - Lab: Developer Journey Part 4 - Create a Loopback API service 4pm - Lecture: Hyperledger Fabric Technology Deep Dive Part 3 5pm - Day 1 Wrap up Day 2 9am - Lecture: IBM Cloud Private on Linux on Z and Secure Service Containers 10:45am - Lecture: The Next Generation IBM Blockchain Platform 11:30am - Lecture: Blockchain on Z - Why and Roadmap Noon - Lunch 1pm - Lab: IBM Blockchain Platform Part 1 - Deploy Network 2pm - Lab: IBM Blockchain Platform Part 2 - Deploy Smart Contract 3pm - Lecture: Kubernetes Explained 4pm - Lab: IBM Blockchain Platform Part 3 - CICD 5pm - Day 2 Wrap Up Acknowledgements Thanks to the following people who helped us test out the labs: Elvin Galarza, Kevin Breitenother, Victoria Coates Authors Austin Grice Barry Silliman Garrett Woodworth Jin VanStee","title":"Blockchain Immersion Wildfire Workshop"},{"location":"index_walmart/#blockchain-immersion-wildfire-workshop","text":"Welcome! This two-day workshop combines lectures and hands-on labs to teach you the fundamentals of blockchain for business. On Day 1, we focus on the open source framework called Hyperledger Fabric that powers blockchain for business. On Day 2, you will learn about the IBM-specific offerings that leverage Hyperledger Fabric, and how our unique combination of expertise, governance and operations tooling, and infrastructure capabilities with Linux on Z can help you achieve business results faster and more securely.","title":"Blockchain Immersion Wildfire Workshop"},{"location":"index_walmart/#agenda","text":"","title":"Agenda"},{"location":"index_walmart/#day-1","text":"8:45am - Introductions 9am - Lecture: Hyperledger Fabric Technology Deep Dive Part 1 10am - Lab: Developer Journey with VSCode and the IBM Blockchain Platform Extension 10:15am - Lab: Developer Journey Part 1 - Create Smart Contract Package 11am - Lab: Developer Journey Part 2 - Commercial Paper Noon - Lunch 1pm - Lecture: Hyperledger Fabric Technology Deep Dive Part 2 2pm - Lab: Developer Journey Part 3 - Cross Chaincode Calls and Debug 3pm - Lab: Developer Journey Part 4 - Create a Loopback API service 4pm - Lecture: Hyperledger Fabric Technology Deep Dive Part 3 5pm - Day 1 Wrap up","title":"Day 1"},{"location":"index_walmart/#day-2","text":"9am - Lecture: IBM Cloud Private on Linux on Z and Secure Service Containers 10:45am - Lecture: The Next Generation IBM Blockchain Platform 11:30am - Lecture: Blockchain on Z - Why and Roadmap Noon - Lunch 1pm - Lab: IBM Blockchain Platform Part 1 - Deploy Network 2pm - Lab: IBM Blockchain Platform Part 2 - Deploy Smart Contract 3pm - Lecture: Kubernetes Explained 4pm - Lab: IBM Blockchain Platform Part 3 - CICD 5pm - Day 2 Wrap Up","title":"Day 2"},{"location":"index_walmart/#acknowledgements","text":"Thanks to the following people who helped us test out the labs: Elvin Galarza, Kevin Breitenother, Victoria Coates","title":"Acknowledgements"},{"location":"index_walmart/#authors","text":"Austin Grice Barry Silliman Garrett Woodworth Jin VanStee","title":"Authors"},{"location":"lab-errata/","text":"Lab 3 errata and notes: Steps 20 21 - These steps have commands that span multiple lines in the document (3 or 4). You cannot copy and paste from the document to the command line in one operation because newline characters in the document will cause it to be 3 different commands, which will fail. You either have to type the whole command by hand, or, what may be easier- copy and paste the lines one at a time and then hit Enter after pasting the last line of the command in the terminal. Better yet, copy the commands from here: Step 20 command : docker exec cliMagnetoCorp peer chaincode install -n papercontract -v 0.0.3-p /opt/gopath/src/github.com/contract -l node Step 21 command : docker exec cliMagnetoCorp peer chaincode instantiate -n papercontract -v 0.0.3-l node -c '{ Args :[ org.papernet.commercialpaper:instantiate ]}' -C mychannel -P AND ('Org1MSP.member') Step 72 - The instructions for this step are missing a dropdown selection asking you to choose between something like \u2018orderer.example.com\u2019 or \u2018peer0.org1.example.com\u2019 -- choose the one that starts with peer* Step 95 \u2013 the instructions are missing the \u201d to the right of MagnetoCorp. It should be: MagnetoCorp , 00005","title":"Lab errata"},{"location":"lab-errata/#lab-3-errata-and-notes","text":"Steps 20 21 - These steps have commands that span multiple lines in the document (3 or 4). You cannot copy and paste from the document to the command line in one operation because newline characters in the document will cause it to be 3 different commands, which will fail. You either have to type the whole command by hand, or, what may be easier- copy and paste the lines one at a time and then hit Enter after pasting the last line of the command in the terminal. Better yet, copy the commands from here: Step 20 command : docker exec cliMagnetoCorp peer chaincode install -n papercontract -v 0.0.3-p /opt/gopath/src/github.com/contract -l node Step 21 command : docker exec cliMagnetoCorp peer chaincode instantiate -n papercontract -v 0.0.3-l node -c '{ Args :[ org.papernet.commercialpaper:instantiate ]}' -C mychannel -P AND ('Org1MSP.member') Step 72 - The instructions for this step are missing a dropdown selection asking you to choose between something like \u2018orderer.example.com\u2019 or \u2018peer0.org1.example.com\u2019 -- choose the one that starts with peer* Step 95 \u2013 the instructions are missing the \u201d to the right of MagnetoCorp. It should be: MagnetoCorp , 00005","title":"Lab 3 errata and notes:"},{"location":"loopback/","text":"In this section, we are going to create a loopback API application for MagnetoCorp and another loopback API application for Digibank. Once we have created these applications, you'll be able to submit transactions and have them be recorded in our blockchain network. 1. From the terminal application, open a new tab and navigate to your desktop. Once you are at the desktop, install the loopback npm package. You can find these commands below: tecadmin@ubuntubase:~/Desktop$ cd ~ tecadmin@ubuntubase:~/Desktop$ npm install -g @loopback/cli 2. Once you have the loopback installed, go ahead and follow the series of commands and prompts below. I'll explain these after we have completed this (when you get the Select features to enable in the project prompt, just hit Enter ): ----- Create Our App ----- tecadmin@ubuntubase:~/Desktop$ lb4 app ? Project name: magnetocorp ? Project description: loopback api for magnetocorp ? Project root directory: magnetocorp ? Application class name: MagnetocorpApplication ? Select features to enable in the project (Press space to select, a to toggle all, i to invert selection)Enable eslint, Enable prettier, Enable mocha, Enable loopbackBuild, Enable vscode, Enable docker, Enable repositories, Enable services create .eslintignore create .eslintrc.js create .mocharc.json create .npmrc create .prettierignore create .prettierrc create DEVELOPING.md create README.md create index.ts create package.json create tsconfig.json create .vscode/settings.json create .vscode/tasks.json create .gitignore create .dockerignore create Dockerfile create index.js create public/index.html create src/application.ts create src/index.ts create src/migrate.ts create src/sequence.ts create src/__tests__/README.md create src/controllers/README.md create src/controllers/index.ts create src/controllers/ping.controller.ts create src/datasources/README.md create src/models/README.md create src/repositories/README.md create src/__tests__/acceptance/home-page.acceptance.ts create src/__tests__/acceptance/ping.controller.acceptance.ts create src/__tests__/acceptance/test-helper.ts Application magnetocorp was created in magnetocorp. ----- Create Model for our Issue ----- tecadmin@ubuntubase:~/Desktop$ cd magnetocorp/ tecadmin@ubuntubase:~/Desktop/magnetocorp$ lb4 model ? Model class name: issue ? Please select the model base class Entity (A persisted model with an ID) ? Allow additional (free-form) properties? No Let's add a property to Issue Enter an empty property name when done ? Enter the property name: issuer ? Property type: string ? Is issuer the ID property? No ? Is it required?: Yes ? Default value [leave blank for none]: Let's add another property to Issue Enter an empty property name when done ? Enter the property name: paperNumber ? Property type: string ? Is paperNumber the ID property? No ? Is it required?: Yes ? Default value [leave blank for none]: Let's add another property to Issue Enter an empty property name when done ? Enter the property name: issueDateTime ? Property type: string ? Is issueDateTime the ID property? No ? Is it required?: Yes ? Default value [leave blank for none]: Let's add another property to Issue Enter an empty property name when done ? Enter the property name: maturityDateTime ? Property type: string ? Is maturityDateTime the ID property? No ? Is it required?: Yes ? Default value [leave blank for none]: Let's add another property to Issue Enter an empty property name when done ? Enter the property name: faceValue ? Property type: string ? Is faceValue the ID property? No ? Is it required?: Yes ? Default value [leave blank for none]: Let's add another property to Issue Enter an empty property name when done ? Enter the property name: paperRate ? Property type: string ? Is paperRate the ID property? No ? Is it required?: Yes ? Default value [leave blank for none]: Let's add another property to Issue Enter an empty property name when done ? Enter the property name: create src/models/issue.model.ts update src/models/index.ts Model issue was created in src/models/ ----- Create Model for our getPaperRate ----- tecadmin@ubuntubase:~/Desktop/magnetocorp$ lb4 model ? Model class name: getPaperRate ? Please select the model base class Entity (A persisted model with an ID) ? Allow additional (free-form) properties? No Let's add a property to GetPaperRate Enter an empty property name when done ? Enter the property name: issuer ? Property type: string ? Is issuer the ID property? No ? Is it required?: Yes ? Default value [leave blank for none]: Let's add another property to GetPaperRate Enter an empty property name when done ? Enter the property name: paperNumber ? Property type: string ? Is paperNumber the ID property? No ? Is it required?: Yes ? Default value [leave blank for none]: Let's add another property to GetPaperRate Enter an empty property name when done ? Enter the property name: create src/models/get-paper-rate.model.ts update src/models/index.ts Model getPaperRate was created in src/models/ ----- Create Model for our getAllPapersFromIssuer ----- tecadmin@ubuntubase:~/Desktop/magnetocorp$ lb4 model ? Model class name: getAllPapersFromIssuer ? Please select the model base class Entity (A persisted model with an ID) ? Allow additional (free-form) properties? No Let's add a property to GetAllPapersFromIssuer Enter an empty property name when done ? Enter the property name: paperIssuer ? Property type: string ? Is paperIssuer the ID property? No ? Is it required?: Yes ? Default value [leave blank for none]: Let's add another property to GetAllPapersFromIssuer Enter an empty property name when done ? Enter the property name: create src/models/get-all-papers-from-issuer.model.ts update src/models/index.ts Model getAllPapersFromIssuer was created in src/models/ ----- Create a Datasource ----- tecadmin@ubuntubase:~/Desktop/magnetocorp$ lb4 datasource ? Datasource name: db ? Select the connector for db: In-memory db (supported by StrongLoop) ? window.localStorage key to use for persistence (browser only): ? Full path to file for persistence (server only): ./data/db.json create src/datasources/db.datasource.json create src/datasources/db.datasource.ts update src/datasources/index.ts Datasource db was created in src/datasources/ ----- Create our Repositories ----- tecadmin@ubuntubase:~/Desktop/magnetocorp$ lb4 repository ? Please select the datasource DbDatasource ? Select the model(s) you want to generate a repository (Press space to select, a to toggle all, i to invert selection)GetAllPapersFromIssuer, GetPaperRate, Issue ? Please select the repository base class DefaultCrudRepository (Legacy juggler bridge) ? Please enter the name of the ID property for GetAllPapersFromIssuer: id ? Please enter the name of the ID property for GetPaperRate: id ? Please enter the name of the ID property for Issue: id create src/repositories/get-all-papers-from-issuer.repository.ts create src/repositories/get-paper-rate.repository.ts create src/repositories/issue.repository.ts update src/repositories/index.ts update src/repositories/index.ts update src/repositories/index.ts Repositories GetAllPapersFromIssuerRepository,GetPaperRateRepository,IssueRepository was created in src/repositories/ ----- Create a Controller for Issue, GetPaperRate and GetAllPapersFromIssuer ----- tecadmin@ubuntubase:~/Desktop/magnetocorp$ lb4 controller ? Controller class name: Issue ? What kind of controller would you like to generate? REST Controller with CRUD functions ? What is the name of the model to use with this CRUD repository? Issue ? What is the name of your CRUD repository? IssueRepository ? What is the type of your ID? string ? What is the base HTTP path name of the CRUD operations? /issues create src/controllers/issue.controller.ts update src/controllers/index.ts Controller Issue was created in src/controllers/ tecadmin@ubuntubase:~/Desktop/magnetocorp$ lb4 controller ? Controller class name: GetPaperRate ? What kind of controller would you like to generate? REST Controller with CRUD functions ? What is the name of the model to use with this CRUD repository? GetPaperRate ? What is the name of your CRUD repository? GetPaperRateRepository ? What is the type of your ID? string ? What is the base HTTP path name of the CRUD operations? /get-paper-rates create src/controllers/get-paper-rate.controller.ts update src/controllers/index.ts Controller GetPaperRate was created in src/controllers/ tecadmin@ubuntubase:~/Desktop/magnetocorp$ lb4 controller ? Controller class name: GetAllPapersFromIssuer ? What kind of controller would you like to generate? REST Controller with CRUD functions ? What is the name of the model to use with this CRUD repository? GetAllPapersFromIssuer ? What is the name of your CRUD repository? GetAllPapersFromIssuerRepository ? What is the type of your ID? string ? What is the base HTTP path name of the CRUD operations? /get-all-papers-from-issuers create src/controllers/get-all-papers-from-issuer.controller.ts update src/controllers/index.ts Controller GetAllPapersFromIssuer was created in src/controllers/ What you just did above is basically create the bones to our loopback API application. We needed to create our app, model, datasource, repository and controller to actually create our application. Below is a breakdown of each thing we created. Important Do not repeat the commands shown in the rest of this section as they are snippets of what you just entered above and they are repeated here for illustrative purposes App: The LoopBack 4 CLI toolkit comes with templates that generate whole applications, as well as artifacts (for example, controllers, models, and repositories) for existing applications. tecadmin@ubuntubase:~/Desktop$ lb4 app ? Project name: magnetocorp ? Project description: loopback application for magnetocorp ? Project root directory: magnetocorp ? Application class name: MagnetoCorpApplication ? Select features to enable in the project (Press space to select, a to toggle all, i to invert selection)Enable eslint, Enable --- Press enter to enable all of these! --- prettier, Enable mocha, Enable loopbackBuild, Enable vscode, Enable docker, Enable repositories, Enable services Model: Now we can begin working on the representation of our data for use with LoopBack 4, which needs to align with what is in our smart conract. To that end, we\u2019re going to create an issue and buy model that can represent instances of a task for our papercontract. A model describes business domain objects and defines a list of properties with name, type, and other constraints. Models are used for data exchange on the wire or between different systems. tecadmin@ubuntubase:~/Desktop/magnetocorp$ lb4 model ? Model class name: getPaperRate ? Please select the model base class Entity (A persisted model with an ID) ? Allow additional (free-form) properties? No Let's add a property to GetPaperRate Enter an empty property name when done ? Enter the property name: issuer ? Property type: string ? Is issuer the ID property? No ? Is it required?: Yes ? Default value [leave blank for none]: Let's add another property to GetPaperRate Enter an empty property name when done ? Enter the property name: paperNumber ? Property type: string ? Is paperNumber the ID property? No ? Is it required?: Yes ? Default value [leave blank for none]: Let's add another property to GetPaperRate Enter an empty property name when done ? Enter the property name: create src/models/get-paper-rate.model.ts update src/models/index.ts Model getPaperRate was created in src/models/ Datasource: Datasources are LoopBack\u2019s way of connecting to various sources of data, such as databases, APIs, message queues and more. In LoopBack 4, datasources can be represented as strongly-typed objects and freely made available for injection throughout the application. Typically, in LoopBack 4, datasources are used in conjunction with Repositories to provide access to data. tecadmin@ubuntubase:~/Desktop/magnetocorp$ lb4 datasource ? Datasource name: db ? Select the connector for db: In-memory db (supported by StrongLoop) ? window.localStorage key to use for persistence (browser only): ? Full path to file for persistence (server only): ./data/db.json create src/datasources/db.datasource.json create src/datasources/db.datasource.ts update src/datasources/index.ts Datasource db was created in src/datasources/ Repositories: A Repository represents a specialized Service interface that provides strong-typed data access (for example, CRUD) operations of a domain model against the underlying database or service. tecadmin@ubuntubase:~/Desktop/magnetocorp$ lb4 repository ? Please select the datasource DbDatasource ? Select the model(s) you want to generate a repository (Press space to select, a to toggle all, i to invert selection)GetAllPapersFromIssuer, GetPaperRate, Issue ? Please select the repository base class DefaultCrudRepository (Legacy juggler bridge) ? Please enter the name of the ID property for GetAllPapersFromIssuer: id ? Please enter the name of the ID property for GetPaperRate: id ? Please enter the name of the ID property for Issue: id create src/repositories/get-all-papers-from-issuer.repository.ts create src/repositories/get-paper-rate.repository.ts create src/repositories/issue.repository.ts update src/repositories/index.ts update src/repositories/index.ts update src/repositories/index.ts Controller: In LoopBack 4, controllers handle the request-response lifecycle for your API. Each function on a controller can be addressed individually to handle an incoming request (like a POST request to /todos), to perform business logic, and to return a response. tecadmin@ubuntubase:~/Desktop/magnetocorp$ lb4 controller ? Controller class name: Issue ? What kind of controller would you like to generate? REST Controller with CRUD functions ? What is the name of the model to use with this CRUD repository? Issue ? What is the name of your CRUD repository? IssueRepository ? What is the type of your ID? string ? What is the base HTTP path name of the CRUD operations? /issues create src/controllers/issue.controller.ts update src/controllers/index.ts Controller Issue was created in src/controllers/ You can find out more information and great tutorials as to how to build your own loopback API application here: https://loopback.io/doc/en/lb4/index.html Important Okay, now resume entering or performing any commands or tasks you see. 3. Within VSCode, go to the Explorer Perspective and do File - Add Folder to Workplace and navigate to the magnetocorp folder that we just created within the Desktop folder. Go ahead and open that folder in VSCode. 4. Now within VSCode, right click on magnetocorp - the folder you just opened in VSCode. Once you right click, select New Folder and name it data . Really mysterious right? 5. On the newly created folder, data , right click on that folder and select New File and name that file db.json . Within that new file, add in this text below :: { \"ids\": { \"Todo\": 5 }, \"models\": { \"Todo\": { \"1\": \"{\\\"title\\\":\\\"Take over the galaxy\\\",\\\"desc\\\":\\\"MWAHAHAHAHAHAHAHAHAHAHAHAHAMWAHAHAHAHAHAHAHAHAHAHAHAHA\\\",\\\"id\\\":1}\", \"2\": \"{\\\"title\\\":\\\"destroy alderaan\\\",\\\"desc\\\":\\\"Make sure there are no survivors left!\\\",\\\"id\\\":2}\", \"3\": \"{\\\"title\\\":\\\"terrorize senate\\\",\\\"desc\\\":\\\"Tell them they're getting a budget cut.\\\",\\\"id\\\":3}\", \"4\": \"{\\\"title\\\":\\\"crush rebel scum\\\",\\\"desc\\\":\\\"Every.Last.One.\\\",\\\"id\\\":4}\" } } } Go ahead and save this file! This file, db.json, contains an example database. 6. Within the magnetocorp folder in VSCode, navigate to the following folder :: magnetocorp - src - repositories You should see 5 files in there: README.md , issue.repository.ts , get-paper-rate.repository.ts , get-all-papers-from-issuer.repository.ts , and index.ts 7. Within the issue.repository.ts file, add // on line 8. Look below as to what to do :: typeof Issue.prototype.id --- CHANGE TO --- // typeof Issue.prototype.id Go ahead and save this file! 8. Do the same thing for get-paper-rate.repository.ts on line 8 :: typeof GetPaperRate.prototype.id --- CHANGE TO --- // typeof GetPaperRate.prototype.id Go ahead and save this file! 9. Do the same thing for get-all-papers-from-issuer.repository.ts on line 8 :: typeof GetAllPapersFromIssuer.prototype.id --- CHANGE TO --- // typeof GetAllPapersFromIssuer.prototype.id Go ahead and save this file! 10. Within the magnetocorp folder in VSCode, navigate to the following folder :: magnetocorp - src - controllers You should see 6 files in there: README.md , issue.controller.ts , get-paper-rate.controller.ts , get-all-papers-from-issuer.controller.ts , ping.controller.ts , and index.ts 11. Within the issue.controller.ts file, delete all of its contents and paste in what is below :: // Copyright IBM Corp. 2017,2018. All Rights Reserved. // Node module: @loopback/example-todo // This file is licensed under the MIT License. // License text available at https://opensource.org/licenses/MIT import { del, get, getFilterSchemaFor, param, patch, post, put, requestBody, } from '@loopback/rest'; import { Issue } from '../models'; import { BlockChainModule } from '../blockchainClient'; let blockchainClient = new BlockChainModule.BlockchainClient(); export class IssueController { constructor() { } @post('/issue', { responses: { '200': { description: 'Todo model instance', content: { 'application/json': { schema: { 'x-ts-type': Issue } } }, }, }, }) async createIssue(@requestBody() requestBody: Issue): Promise Issue { console.log('Buy, requestBody: ') console.log(requestBody) let networkObj = await blockchainClient.connectToNetwork(); if (!networkObj) { let errString = 'Error connecting to network'; let issue = new Issue({ issuer: errString, paperNumber: errString, issueDateTime: errString, maturityDateTime: errString, faceValue: errString, paperRate: errString }); return issue; } console.log('newtork obj: ') console.log(networkObj) let dataForIssue = { function: 'issue', issuer: requestBody.issuer, paperNumber: requestBody.paperNumber, issueDateTime: requestBody.issueDateTime, maturityDateTime: requestBody.maturityDateTime, faceValue: requestBody.faceValue, paperRate: requestBody.paperRate, contract: networkObj.contract }; var resultAsBuffer = await blockchainClient.issue(dataForIssue); console.log('result from blockchainClient.submitTransaction in controller: ') console.log('result from blockchainClient.submitTransaction in controller: ') let result = JSON.parse(Buffer.from(JSON.parse(resultAsBuffer)).toString()) let issue = new Issue({ issuer: result.issuer, paperNumber: result.paperNumber, issueDateTime: result.issueDateTime, maturityDateTime: result.maturityDateTime, faceValue: result.faceValue, paperRate: result.paperRate }); return issue; } } Go ahead and save this file! Below is a breakdown of this file above: Below, we are pulling in the issue model that we created when we created our loopback API application: import { Issue } from '../models'; Below, we are only specifying a post API call. A post call adds data, in this case a transaction against our blockchain network, to our ledgers: @post('/issue', { responses: { '200': { Below, we are actually submitting a transaction, an issue transaction. This transaction is looking for all the data fields we created in our issue model file. If all goes well, we will successfully issue a commercialpaper: async createIssue(@requestBody() requestBody: Issue): Promise Issue { console.log('Buy, requestBody: ') console.log(requestBody) let networkObj = await blockchainClient.connectToNetwork(); if (!networkObj) { let errString = 'Error connecting to network'; let issue = new Issue({ issuer: errString, paperNumber: errString, issueDateTime: errString, maturityDateTime: errString, faceValue: errString, paperRate: errString }); return issue; } 12. Within VSCode, right click on the src folder (within the magnetocorp folder) and select New File . Go ahead and name this file blockchainClient.ts 13. Within our new blockchainClient.ts file, paste in this code below: import { json } from \"body-parser\"; const yaml = require('js-yaml'); const { FileSystemWallet, Gateway } = require('fabric-network'); const fs = require('fs'); // A wallet stores a collection of identities for use const wallet = new FileSystemWallet('/home/tecadmin/.fabric-vscode/local_fabric_wallet'); export module BlockChainModule { export class BlockchainClient { async connectToNetwork() { const gateway = new Gateway(); try { console.log('connecting to Fabric network...') const identityLabel = 'isabella'; let connectionProfile = yaml.safeLoad(fs.readFileSync('/home/tecadmin/Desktop/magnetocorp/networkConnection.yaml', 'utf8')); let connectionOptions = { identity: identityLabel, wallet: wallet, discovery: { asLocalhost: true, enabled: true } }; // Connect to gateway using network.yaml file and our certificates in _idwallet directory await gateway.connect(connectionProfile, connectionOptions); console.log('Connected to Fabric gateway.'); // Connect to our local fabric const network = await gateway.getNetwork('mychannel'); console.log('Connected to mychannel. '); // Get the contract we have installed on the peer const contract = await network.getContract('papercontract'); let networkObj = { contract: contract, network: network }; return networkObj; } catch (error) { console.log(`Error processing transaction. ${error}`); console.log(error.stack); } finally { console.log('Done connecting to network.'); // gateway.disconnect(); } } async issue(args: any) { console.log('args for issue: ') console.log(args) let response = await args.contract.submitTransaction(args.function, args.issuer, args.paperNumber, args.issueDateTime, args.maturityDateTime, args.faceValue, args.paperRate ); return response; } } } Go ahead and save this file! Below is a breakdown of our blockchainClient.ts file: Below, you'll see that we are specifying where our user's credientials are located to validate that our user can actually submit a transaction: // A wallet stores a collection of identities for use const wallet = new FileSystemWallet('/home/tecadmin/Desktop/magnetocorp/local_fabric_wallet'); Below, we are saying that within the .fabric-vscode/local_fabric_wallet folder we are using User1@org1.example.com as our user. Also, we are saying that our connection profile is networkConnection.yaml located one directory back. We will copy the connection profile in the next section: const identityLabel = 'isabella'; let connectionProfile = yaml.safeLoad(fs.readFileSync('/home/tecadmin/Desktop/magnetocorp/networkConnection.yaml', 'utf8')); Below, we are connecting to our channel, called mychannel , and also using our smart contract, called papercontract : // Connect to our local fabric const network = await gateway.getNetwork('mychannel'); console.log('Connected to mychannel. '); // Get the contract we have installed on the peer const contract = await network.getContract('papercontract'); Below, we are actually submitting our issue transaction. There is a very similar transaction. This will use our issue controller as a basis for our actual arguments (args): async issue(args: any) { console.log('args for issue: ') console.log(args) let response = await args.contract.submitTransaction(args.function, args.issuer, args.paperNumber, args.issueDateTime, args.maturityDateTime, args.faceValue, args.paperRate ); return response; } 14. Now, we need to copy our networkConnection.yaml file over from magnetocorp in our fabric-samples-cp folder and place it into our magnetocorp folder. You can execute the command below, from our terminal application, as to how to copy: tecadmin@ubuntubase:~/Desktop/magnetocorp$ cp /home/tecadmin/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/gateway/networkConnection.yaml . # 15. From VSCode, go to the IBM Blockchain Platform Extension and right click on local_fabric_wallet and select Add Identity to Wallet . From there follow the prompt as it follows below: Provide a Name for the Identity: isabella Enter MSPID: Org1MSP Choose a method of adding an identity: Provide an enrollment ID and secret Enter Enrollment ID: admin Enter Enrollment secret: adminpw 16. We need to modify our package.json file to include the fabric-network module. Within our magnetocorp folder, find the package.json file and add in the following text below on line 58 : \"fabric-network\": \"~1.4.1\" Note Your line number may differ- the important thing is that this line is added to the end of the dependencies section, and not in the dev-dependencies section. So now our dependencies look like this: \"dependencies\": { \"@loopback/boot\": \"^1.4.0\", \"@loopback/context\": \"^1.19.0\", \"@loopback/core\": \"^1.8.1\", \"@loopback/openapi-v3\": \"^1.6.1\", \"@loopback/repository\": \"^1.6.1\", \"@loopback/rest\": \"^1.15.0\", \"@loopback/rest-explorer\": \"^1.2.1\", \"@loopback/service-proxy\": \"^1.2.1\", \"fabric-network\": \"~1.4.1\" Do not forget to add a comma after the \"@loopback/service-proxy\": \"^1.2.1\" dependency above the line you just added. Go ahead and save this file! 17. Now we can delete the node_modules and package-lock.json file so that it will pick up the fabric-network package when we do an npm install again. To do this, within VSCode, right click on node_modules and select Delete . Do the same for package-lock.json . If it asks you to confirm this, select Move to Trash . 18. Back in our terminal application, do an npm install within the magnetocorp folder: tecadmin@ubuntubase:~/Desktop/magnetocorp$ npm install * * * added 748 packages from 1578 contributors and audited 4980 packages in 45.757s found 3 vulnerabilities (1 low, 2 moderate) 19. Then you can do an npm build as well from the same folder: tecadmin@ubuntubase:~/Desktop/magnetocorp$ npm run build magnetocorp@1.0.0 build /home/tecadmin/Desktop/magnetocorp lb-tsc es2017 --outDir dist 20. We will hold off on starting the server until we have built the DigiBank loopback application as well. 21. Speaking of DigiBank, let's build their loopback API application. It will be very similar to how we built MagnetoCorp's. 22. Go ahead and follow the series of commands and prompts below to create Digibank's loopback application. I'll explain these after we have completed this: ----- Create Our App ----- tecadmin@ubuntubase:~/Desktop$ lb4 app ? Project name: digibank ? Project description: loopback api for digibank ? Project root directory: digibank ? Application class name: DigibankApplication ? Select features to enable in the project (Press space to select, a to toggle all, i to invert selection)Enable eslint, Enable prettier, Enable mocha, Enable loopbackBuild, Enable vscode, Enable docker, Enable repositories, Enable services create .eslintignore create .eslintrc.js create .mocharc.json create .npmrc create .prettierignore create .prettierrc create DEVELOPING.md create README.md create index.ts create package.json create tsconfig.json create .vscode/settings.json create .vscode/tasks.json create .gitignore create .dockerignore create Dockerfile create index.js create public/index.html create src/application.ts create src/index.ts create src/migrate.ts create src/sequence.ts create src/__tests__/README.md create src/controllers/README.md create src/controllers/index.ts create src/controllers/ping.controller.ts create src/datasources/README.md create src/models/README.md create src/repositories/README.md create src/__tests__/acceptance/home-page.acceptance.ts create src/__tests__/acceptance/ping.controller.acceptance.ts create src/__tests__/acceptance/test-helper.ts Application digibank was created in digibank. ----- Create Model for our Buy ----- tecadmin@ubuntubase:~/Desktop$ cd digibank/ tecadmin@ubuntubase:~/Desktop/digibank$ lb4 model ? Model class name: buy ? Please select the model base class Entity (A persisted model with an ID) ? Allow additional (free-form) properties? No Let's add a property to Buy Enter an empty property name when done ? Enter the property name: issuer ? Property type: string ? Is issuer the ID property? No ? Is it required?: Yes ? Default value [leave blank for none]: Let's add another property to Buy Enter an empty property name when done ? Enter the property name: paperNumber ? Property type: string ? Is paperNumber the ID property? No ? Is it required?: Yes ? Default value [leave blank for none]: Let's add another property to Buy Enter an empty property name when done ? Enter the property name: currentOwner ? Property type: string ? Is currentOwner the ID property? No ? Is it required?: Yes ? Default value [leave blank for none]: Let's add another property to Buy Enter an empty property name when done ? Enter the property name: newOwner ? Property type: string ? Is newOwner the ID property? No ? Is it required?: Yes ? Default value [leave blank for none]: Let's add another property to Buy Enter an empty property name when done ? Enter the property name: price ? Property type: string ? Is price the ID property? No ? Is it required?: Yes ? Default value [leave blank for none]: Let's add another property to Buy Enter an empty property name when done ? Enter the property name: purchaseDateTime ? Property type: string ? Is purchaseDateTime the ID property? No ? Is it required?: Yes ? Default value [leave blank for none]: Let's add another property to Buy Enter an empty property name when done ? Enter the property name: create src/models/buy.model.ts update src/models/index.ts Model buy was created in src/models/ ----- Create Model for our Redeem ----- tecadmin@ubuntubase:~/Desktop/digibank$ lb4 model ? Model class name: redeem ? Please select the model base class Entity (A persisted model with an ID) ? Allow additional (free-form) properties? No Let's add a property to Redeem Enter an empty property name when done ? Enter the property name: issuer ? Property type: string ? Is issuer the ID property? No ? Is it required?: Yes ? Default value [leave blank for none]: Let's add another property to Redeem Enter an empty property name when done ? Enter the property name: paperNumber ? Property type: string ? Is paperNumber the ID property? No ? Is it required?: Yes ? Default value [leave blank for none]: Let's add another property to Redeem Enter an empty property name when done ? Enter the property name: redeemingOwner ? Property type: string ? Is redeemingOwner the ID property? No ? Is it required?: Yes ? Default value [leave blank for none]: Let's add another property to Redeem Enter an empty property name when done ? Enter the property name: redeemDateTime ? Property type: string ? Is redeemingOwner the ID property? No ? Is it required?: Yes ? Default value [leave blank for none]: Let's add another property to Redeem Enter an empty property name when done ? Enter the property name: create src/models/redeem.model.ts update src/models/index.ts Model redeem was created in src/models/ ----- Create Model for our getPaperRate ----- tecadmin@ubuntubase:~/Desktop/digibank$ lb4 model ? Model class name: getPaperRate ? Please select the model base class Entity (A persisted model with an ID) ? Allow additional (free-form) properties? No Let's add a property to GetPaperRate Enter an empty property name when done ? Enter the property name: issuer ? Property type: string ? Is issuer the ID property? No ? Is it required?: Yes ? Default value [leave blank for none]: Let's add another property to GetPaperRate Enter an empty property name when done ? Enter the property name: paperNumber ? Property type: string ? Is paperNumber the ID property? No ? Is it required?: Yes ? Default value [leave blank for none]: Let's add another property to GetPaperRate Enter an empty property name when done ? Enter the property name: create src/models/get-paper-rate.model.ts update src/models/index.ts Model getPaperRate was created in src/models/ ----- Create Model for our getAllPapersFromIssuer ----- tecadmin@ubuntubase:~/Desktop/digibank$ lb4 model ? Model class name: getAllPapersFromIssuer ? Please select the model base class Entity (A persisted model with an ID) ? Allow additional (free-form) properties? No Let's add a property to GetAllPapersFromIssuer Enter an empty property name when done ? Enter the property name: paperIssuer ? Property type: string ? Is paperIssuer the ID property? No ? Is it required?: Yes ? Default value [leave blank for none]: Let's add another property to GetAllPapersFromIssuer Enter an empty property name when done ? Enter the property name: create src/models/get-all-papers-from-issuer.model.ts update src/models/index.ts Model getAllPapersFromIssuer was created in src/models/ ----- Create a Datasource ----- tecadmin@ubuntubase:~/Desktop/digibank$ lb4 datasource ? Datasource name: db ? Select the connector for db: In-memory db (supported by StrongLoop) ? window.localStorage key to use for persistence (browser only): ? Full path to file for persistence (server only): ./data/db.json create src/datasources/db.datasource.json create src/datasources/db.datasource.ts update src/datasources/index.ts Datasource db was created in src/datasources/ ----- Create a Repository ----- tecadmin@ubuntubase:~/Desktop/digibank$ lb4 repository ? Please select the datasource DbDatasource ? Select the model(s) you want to generate a repository (Press space to select, a to toggle all, i to invert selection)Buy, GetAllPapersFromIssuer, GetPaperRate, Redeem ? Please select the repository base class DefaultCrudRepository (Legacy juggler bridge) ? Please enter the name of the ID property for Buy: id ? Please enter the name of the ID property for GetAllPapersFromIssuer: id ? Please enter the name of the ID property for GetPaperRate: id ? Please enter the name of the ID property for Redeem: id create src/repositories/buy.repository.ts create src/repositories/get-all-papers-from-issuer.repository.ts create src/repositories/get-paper-rate.repository.ts create src/repositories/redeem.repository.ts update src/repositories/index.ts update src/repositories/index.ts update src/repositories/index.ts update src/repositories/index.ts Repositories BuyRepository,GetAllPapersFromIssuerRepository,GetPaperRateRepository,RedeemRepository was created in src/repositories/ ----- Create a Controller for the Issue Transaction ----- tecadmin@ubuntubase:~/Desktop/digibank$ lb4 controller ? Controller class name: Buy ? What kind of controller would you like to generate? REST Controller with CRUD functions ? What is the name of the model to use with this CRUD repository? Buy ? What is the name of your CRUD repository? BuyRepository ? What is the type of your ID? string ? What is the base HTTP path name of the CRUD operations? /buys create src/controllers/buy.controller.ts update src/controllers/index.ts Controller Buy was created in src/controllers/ tecadmin@ubuntubase:~/Desktop/digibank$ lb4 controller ? Controller class name: Redeem ? What kind of controller would you like to generate? REST Controller with CRUD functions ? What is the name of the model to use with this CRUD repository? Redeem ? What is the name of your CRUD repository? RedeemRepository ? What is the type of your ID? string ? What is the base HTTP path name of the CRUD operations? /redeems create src/controllers/redeem.controller.ts update src/controllers/index.ts Controller Redeem was created in src/controllers/ tecadmin@ubuntubase:~/Desktop/digibank$ lb4 controller ? Controller class name: GetPaperRate ? What kind of controller would you like to generate? REST Controller with CRUD functions ? What is the name of the model to use with this CRUD repository? GetPaperRate ? What is the name of your CRUD repository? GetPaperRateRepository ? What is the type of your ID? string ? What is the base HTTP path name of the CRUD operations? /get-paper-rates create src/controllers/get-paper-rate.controller.ts update src/controllers/index.ts Controller GetPaperRate was created in src/controllers/ tecadmin@ubuntubase:~/Desktop/digibank$ lb4 controller ? Controller class name: GetAllPapersFromIssuer ? What kind of controller would you like to generate? REST Controller with CRUD functions ? What is the name of the model to use with this CRUD repository? GetAllPapersFromIssuer ? What is the name of your CRUD repository? GetAllPapersFromIssuerRepository ? What is the type of your ID? string ? What is the base HTTP path name of the CRUD operations? /get-all-papers-from-issuers create src/controllers/get-all-papers-from-issuer.controller.ts update src/controllers/index.ts Controller GetAllPapersFromIssuer was created in src/controllers/ You just did the same thing for DigiBank, as you earlier did for MagnetoCorp and their loopback API application. 23. Within VSCode, go to the Explorer Perspective and do File - Add Folder to Workplace and navigate to the digibank folder that we just created within the Desktop folder. Go ahead and open that folder in VSCode. 24. Now within VSCode, right click on digibank - the folder you just opened in VSCode. Once you right click, select New Folder and name it data . Really mysterious right? 25. On the newly created folder, data , right click on that folder and select New File and name that file db.json . Within that new file, add in this text below: { \"ids\": { \"Todo\": 5 }, \"models\": { \"Todo\": { \"1\": \"{\\\"title\\\":\\\"Take over the galaxy\\\",\\\"desc\\\":\\\"MWAHAHAHAHAHAHAHAHAHAHAHAHAMWAHAHAHAHAHAHAHAHAHAHAHAHA\\\",\\\"id\\\":1}\", \"2\": \"{\\\"title\\\":\\\"destroy alderaan\\\",\\\"desc\\\":\\\"Make sure there are no survivors left!\\\",\\\"id\\\":2}\", \"3\": \"{\\\"title\\\":\\\"terrorize senate\\\",\\\"desc\\\":\\\"Tell them they're getting a budget cut.\\\",\\\"id\\\":3}\", \"4\": \"{\\\"title\\\":\\\"crush rebel scum\\\",\\\"desc\\\":\\\"Every.Last.One.\\\",\\\"id\\\":4}\" } } } Go ahead and save this file! This file, db.json, contains an example database. 26. Within the digibank folder in VSCode, navigate to the following folder: digibank - src - repositories You should see 6 files in there: README.md , buy.repository.ts , redeem.repository.ts , get-paper-rate.repository.ts , get-all-papers-from-issuer.repository.ts and index.ts 27. Within the buy.repository.ts file, add // on line 8. Look below as to what to do: typeof Buy.prototype.id --- CHANGE TO --- // typeof Buy.prototype.id Go ahead and save this file! 28. Within the Redeem.repository.ts file, add // on line 8. Look below as to what to do: typeof Redeem.prototype.id --- CHANGE TO --- // typeof Redeem.prototype.id Go ahead and save this file! 29. Within the get-paper-rate.repository.ts file, add // on line 8. Look below as to what to do: typeof GetPaperRate.prototype.id --- CHANGE TO --- // typeof GetPaperRate.prototype.id Go ahead and save this file! 30. Within the get-all-papers-from-issuer.repository.ts file, add // on line 8. Look below as to what to do: typeof GetAllPapersFromIssuer.prototype.id --- CHANGE TO --- // typeof GetAllPapersFromIssuer.prototype.id Go ahead and save this file! 31. Within the digibank folder in VSCode, navigate to the following folder: digibank - src - controllers You should see 7 files in there: README.md , buy.controller.ts , redeem.controller.ts , get-paper-rate.controller.ts , get-papers-from-issuer.controller.ts , ping.controller.ts , and index.ts 32. Within the buy.controller.ts file, delete all of its contents and paste in the code that is below: // Copyright IBM Corp. 2017,2018. All Rights Reserved. // Node module: @loopback/example-todo // This file is licensed under the MIT License. // License text available at https://opensource.org/licenses/MIT import { del, get, getFilterSchemaFor, param, patch, post, put, requestBody, } from '@loopback/rest'; import { Buy } from '../models'; import { BlockChainModule } from '../blockchainClient'; let blockchainClient = new BlockChainModule.BlockchainClient(); export class BuyController { constructor() { } @post('/buy', { responses: { '200': { description: 'Todo model instance', content: { 'application/json': { schema: { 'x-ts-type': Buy } } }, }, }, }) async createBuy(@requestBody() requestBody: Buy): Promise Buy { console.log('Buy, requestBody: ') console.log(requestBody) let networkObj = await blockchainClient.connectToNetwork(); if (!networkObj) { let errString = 'Error connecting to network'; let buy = new Buy({ issuer: errString, paperNumber: errString, currentOwner: errString, newOwner: errString, price: errString, purchaseDateTime: errString }); return buy; } console.log('newtork obj: ') console.log(networkObj) // dateStr = dateStr.toDateString(); let dataForBuy = { function: 'buy', issuer: requestBody.issuer, paperNumber: requestBody.paperNumber, currentOwner: requestBody.currentOwner, newOwner: requestBody.newOwner, price: requestBody.price, purchaseDateTime: requestBody.purchaseDateTime, contract: networkObj.contract }; var resultAsBuffer = await blockchainClient.buy(dataForBuy); console.log('result from blockchainClient.submitTransaction in controller: ') let result = JSON.parse(Buffer.from(JSON.parse(resultAsBuffer)).toString()) let buy = new Buy({ issuer: result.issuer, paperNumber: result.paperNumber, currentOwner: result.currentOwner, newOwner: result.currentOwner, price: result.price, purchaseDateTime: result.purchaseDateTime }); return buy; } } Go ahead and save this file! 33. Within the redeem.controller.ts file, delete all of its contents and paste in the code that is below: // Copyright IBM Corp. 2017,2018. All Rights Reserved. // Node module: @loopback/example-todo // This file is licensed under the MIT License. // License text available at https://opensource.org/licenses/MIT import { del, get, getFilterSchemaFor, param, patch, post, put, requestBody, } from '@loopback/rest'; import { Redeem } from '../models'; import { BlockChainModule } from '../blockchainClient'; let blockchainClient = new BlockChainModule.BlockchainClient(); export class RedeemController { constructor() { } @post('/redeem', { responses: { '200': { description: 'Todo model instance', content: { 'application/json': { schema: { 'x-ts-type': Redeem } } }, }, }, }) async createIssue(@requestBody() requestBody: Redeem): Promise Redeem { console.log('Buy, requestBody: ') console.log(requestBody) let networkObj = await blockchainClient.connectToNetwork(); if (!networkObj) { let errString = 'Error connecting to network'; let redeem = new Redeem({ issuer: errString, paperNumber: errString, redeemingOwner: errString, redeemDateTime: errString }); return redeem; } console.log('newtork obj: ') console.log(networkObj) let dataForRedeem = { function: 'redeem', issuer: requestBody.issuer, paperNumber: requestBody.paperNumber, redeemingOwner: requestBody.redeemingOwner, redeemDateTime: requestBody.redeemDateTime, contract: networkObj.contract }; var resultAsBuffer = await blockchainClient.redeem(dataForRedeem); console.log('result from blockchainClient.submitTransaction in controller: ') let result = JSON.parse(Buffer.from(JSON.parse(resultAsBuffer)).toString()) let issue = new Redeem({ issuer: result.issuer, paperNumber: result.paperNumber, redeemingOwner: result.redeemingOwner, redeemDateTime: result.redeemDateTime }); return issue; } } Go ahead and save this file! 34. Within VSCode, right click on the src folder (within the digibank folder) and select New File . Go ahead and name this file blockchainClient.ts 35. Within our new blockchainClient.ts file, paste in this code below: const yaml = require('js-yaml'); const { FileSystemWallet, Gateway } = require('fabric-network'); const fs = require('fs'); // A wallet stores a collection of identities for use const wallet = new FileSystemWallet('/home/tecadmin/.fabric-vscode/local_fabric_wallet'); export module BlockChainModule { export class BlockchainClient { async connectToNetwork() { const gateway = new Gateway(); try { console.log('connecting to Fabric network...') const identityLabel = 'balaji'; let connectionProfile = yaml.safeLoad(fs.readFileSync('/home/tecadmin/Desktop/digibank/networkConnection.yaml', 'utf8')); let connectionOptions = { identity: identityLabel, wallet: wallet, discovery: { asLocalhost: true, enabled: true } }; // Connect to gateway using network.yaml file and our certificates in _idwallet directory await gateway.connect(connectionProfile, connectionOptions); console.log('Connected to Fabric gateway.'); // Connect to our local fabric const network = await gateway.getNetwork('mychannel'); console.log('Connected to mychannel. '); // Get the contract we have installed on the peer const contract = await network.getContract('papercontract'); let networkObj = { contract: contract, network: network }; return networkObj; } catch (error) { console.log(`Error processing transaction. ${error}`); console.log(error.stack); } finally { console.log('Done connecting to network.'); // gateway.disconnect(); } } async redeem(args: any) { console.log('args for redeem: ') console.log(args) let response = await args.contract.submitTransaction(args.function, args.issuer, args.paperNumber, args.redeemingOwner, args.redeemDateTime ); return response; } async buy(args: any) { console.log('args for buy: ') console.log(args) let response = await args.contract.submitTransaction(args.function, args.issuer, args.paperNumber, args.currentOwner, args.newOwner, args.price, args.purchaseDateTime ); return response; } } } Go ahead and save this file! 36. Now, we need to copy our networkConnection.yaml file over from digibank in our fabric-samples-cp folder and place it into our digibank folder. You can execute the command below, from our terminal application, as to how to copy: tecadmin@ubuntubase:~/Desktop/digibank$ cp /home/tecadmin/Desktop/fabric-samples-cp/commercial-paper/organization/digibank/gateway/networkConnection.yaml . # 37. From VSCode, go to the IBM Blockchain Platform Extension and right click on local_fabric_wallet and select Add Identity to Wallet . From there follow the prompt as it follows below: Provide a Name for the Identity: balaji Enter MSPID: Org1MSP Choose a method of adding an identity: Provide an enrollment ID and secret Enter Enrollment ID: admin Enter Enrollment secret: adminpw 38. Within our digibank folder in VSCode, find the index.js file. In here there is a port number we need to change. Since magnetocorp is occupying port 3000 , we should make digibank occupy port 3001 . You can find the port number within the index.js file on line 9. Look below at to what to do: port: +process.env.PORT || 3000, --- CHANGE TO --- port: +process.env.PORT || 3001, 39. We need to modify our package.json file to include the fabric-network module. Within our digibank folder, find the package.json file and add in the following text below on line 58 : \"fabric-network\": \"~1.4.1\" So now our dependencies look like this: \"dependencies\": { \"@loopback/boot\": \"^1.4.0\", \"@loopback/context\": \"^1.19.0\", \"@loopback/core\": \"^1.8.1\", \"@loopback/openapi-v3\": \"^1.6.1\", \"@loopback/repository\": \"^1.6.1\", \"@loopback/rest\": \"^1.15.0\", \"@loopback/rest-explorer\": \"^1.2.1\", \"@loopback/service-proxy\": \"^1.2.1\", \"fabric-network\": \"~1.4.1\" Do not forget to add a comma after the \"@loopback/service-proxy\": \"^1.2.1\" dependency Go ahead and save this file! 40. Now we can delete the node_modules and package-lock.json file so that it will pick up the fabric-network package when we do an npm install again. To do this, within VSCode, right click on node_modules and select Delete . Do the same for node_modules . If it asks you to confirm this, select Move to Trash . 41. Back in our terminal application, do an npm install within the digibank folder: tecadmin@ubuntubase:~/Desktop/digibank$ npm install * * * added 748 packages from 1578 contributors and audited 4980 packages in 45.757s found 3 vulnerabilities (1 low, 2 moderate) 42. Then you can do an npm build as well from the same folder: tecadmin@ubuntubase:~/Desktop/digibank$ npm run build magnetocorp-commercialpaper@1.0.0 build /home/tecadmin/Desktop/digibank lb-tsc es2017 --outDir dist 43. Now, we can start both loopback applications. Let's first go start MagnetoCorp's. To do this, go to your terminal application - where you generated the magnetocorp folder. Then run the command below: tecadmin@ubuntubase:~/Desktop/magnetocorp$ npm start magnetocorp@1.0.0 prestart /home/tecadmin/Desktop/magnetocorp npm run build magnetocorp@1.0.0 build /home/tecadmin/Desktop/magnetocorp lb-tsc es2017 --outDir dist magnetocorp@1.0.0 start /home/tecadmin/Desktop/magnetocorp node . Server is running at http://[::1]:3000 Try http://[::1]:3000/ping 44. Then go to your digibank terminal application and do the same command: tecadmin@ubuntubase:~/Desktop/digibank$ npm start digibank@1.0.0 prestart /home/tecadmin/Desktop/digibank npm run build digibank@1.0.0 build /home/tecadmin/Desktop/digibank lb-tsc es2017 --outDir dist digibank@1.0.0 start /home/tecadmin/Desktop/digibank node . Server is running at http://[::1]:3001 Try http://[::1]:3001/ping 45. Go to MagnetoCorp's loopback application by going to http://[::1]:3000 46. Do the same, but this time for DigiBank. You can go to http://[::1]:3001 . It should look the same as MagnetoCorp, but says DigiBank's instead. 47. You can move forward with both loopback applications by clicking on the /explorer link toward the bottom 48. Within the MagnetoCorp loopback UI ( port 3000 ), go ahead and toggle on the Issue controller. Then click on Try it Out . 49. Then paste in the code below to issue a new paper in the white space: { \"issuer\": \"MagnetoCorp\", \"paperNumber\": \"00005\", \"issueDateTime\": \"2020-05-31\", \"maturityDateTime\": \"2020-11-30\", \"faceValue\": \"5000000\", \"paperRate\": \"0.02\" } 50. Once you have the new paper in there, go ahead and click on the blue Execute button below 51. Then you will see the output of our issue transaction Don't be alarm by the the faceValue and paperRate not appearing in our response. We will confirm that it actually went through here in a second. 52. From the IBM Blockchain Platform Extension in VSCode, connect to the local_fabric Fabric Gateway and select balaji as your identity to connect with (it will pop up in the top middle). Then untoggle till you see the buy transaction under our papercontract@0.0.2 smart contract. Enter the code below - between the brackets - to submit this transaction: \"MagnetoCorp\", \"00005\", \"MagnetoCorp\", \"DigiBank\", \"4900000\", \"2019-07-31\" You should see a success message below in the bottom right 53. From same Fabric Gateway, right click on getAllPapersFromIssuer and select Evaluate Transaction . Enter the code below - between the brackets - to submit the query: \"MagnetoCorp\" You should see all of the MagnetoCorp issued papers. Notice, how our paper #00005 has a new owner, DigiBank . 54. Now, let's go to our DigiBank loopback application (port: 3001 ) and do a redeem transaction. To do this, untoggle the Redeem controller and click on Try it out 55. Then paste in what is below in the white space: { \"issuer\": \"MagnetoCorp\", \"paperNumber\": \"00005\", \"redeemingOwner\": \"DigiBank\", \"redeemDateTime\": \"2020-11-30\" } 56. Once you have that in place, go ahead and click on the blue Execute button. Feel free to submit transactions some more through the loopback applications and VSCode. Once you are done, go ahead and clean up the lab station so we can have more fun the labs coming up.","title":"Loopback"},{"location":"portList/","text":"List of ports for each team for quick reference **************** TEAM1 **************** team01 optools URL: https://192.168.22.81:30012 team01 proxy URL: https://192.168.22.81:30013 team01 USERNAME: team01@ibm.com **************** TEAM2 **************** team02 optools URL: https://192.168.22.81:30014 team02 proxy URL: https://192.168.22.81:30016 team02 USERNAME: team02@ibm.com **************** TEAM3 **************** team03 optools URL: https://192.168.22.81:30017 team03 proxy URL: https://192.168.22.81:30018 team03 USERNAME: team03@ibm.com **************** TEAM4 **************** team04 optools URL: https://192.168.22.81:30019 team04 proxy URL: https://192.168.22.81:30020 team04 USERNAME: team04@ibm.com **************** TEAM5 **************** team05 optools URL: https://192.168.22.81:30021 team05 proxy URL: https://192.168.22.81:30022 team05 USERNAME: team05@ibm.com **************** TEAM6 **************** team06 optools URL: https://192.168.22.81:30023 team06 proxy URL: https://192.168.22.81:30024 team06 USERNAME: team06@ibm.com **************** TEAM7 **************** team07 optools URL: https://192.168.22.81:30025 team07 proxy URL: https://192.168.22.81:30026 team07 USERNAME: team07@ibm.com **************** TEAM8 **************** team08 optools URL: https://192.168.22.81:30027 team08 proxy URL: https://192.168.22.81:30028 team08 USERNAME: team08@ibm.com **************** TEAM9 **************** team09 optools URL: https://192.168.22.81:30029 team09 proxy URL: https://192.168.22.81:30030 team09 USERNAME: team09@ibm.com **************** TEAM10 **************** team10 optools URL: https://192.168.22.81:30031 team10 proxy URL: https://192.168.22.81:30032 team10 USERNAME: team10@ibm.com **************** TEAM11 **************** team11 optools URL: https://192.168.22.81:30033 team11 proxy URL: https://192.168.22.81:30034 team11 USERNAME: team11@ibm.com **************** TEAM12 **************** team12 optools URL: https://192.168.22.81:30035 team12 proxy URL: https://192.168.22.81:30036 team12 USERNAME: team12@ibm.com **************** TEAM13 **************** team13 optools URL: https://192.168.22.81:30037 team13 proxy URL: https://192.168.22.81:30038 team13 USERNAME: team13@ibm.com **************** TEAM14 **************** team14 optools URL: https://192.168.22.81:30039 team14 proxy URL: https://192.168.22.81:30040 team14 USERNAME: team14@ibm.com **************** TEAM15 **************** team15 optools URL: https://192.168.22.81:30041 team15 proxy URL: https://192.168.22.81:30042 team15 USERNAME: team15@ibm.com **************** TEAM16 **************** team16 optools URL: https://192.168.22.81:30043 team16 proxy URL: https://192.168.22.81:30044 team16 USERNAME: team16@ibm.com **************** TEAM17 **************** team17 optools URL: https://192.168.22.81:30045 team17 proxy URL: https://192.168.22.81:30046 team17 USERNAME: team17@ibm.com **************** TEAM18 **************** team18 optools URL: https://192.168.22.81:30047 team18 proxy URL: https://192.168.22.81:30048 team18 USERNAME: team18@ibm.com **************** TEAM19 **************** team19 optools URL: https://192.168.22.81:30049 team19 proxy URL: https://192.168.22.81:30050 team19 USERNAME: team19@ibm.com **************** TEAM20 **************** team20 optools URL: https://192.168.22.81:30051 team20 proxy URL: https://192.168.22.81:30052 team20 USERNAME: team20@ibm.com","title":"portList"},{"location":"references/","text":"Please take a few minutes to provide us feedback Workshop evaluation Additional Resources What is blockchain? IBM and Hyperledger Hyperledger Fabric: A Distributed Operating System for Permissioned Blockchains Hyperledger Fabric documentation IBM Blockchain Founder's Handbook Blockchain Essentials Badge Existing Networks and Code Patterns IBM Food Trust TradeLens Trusted Identity World Wire Unbounded - Blockchain Network Finder IBM Blockchain Code Patterns Additional Labs Vehicle Lifecycle Demo Use Case Walkthrough IBM Blockchain Platform VSCode Extension Lab: Add Indices for Better Performing Queries Lab resources Port List for IBM Blockchain Platform Lab","title":"Additional Resources"},{"location":"references/#please-take-a-few-minutes-to-provide-us-feedback","text":"Workshop evaluation","title":"Please take a few minutes to provide us feedback"},{"location":"references/#additional-resources","text":"What is blockchain? IBM and Hyperledger Hyperledger Fabric: A Distributed Operating System for Permissioned Blockchains Hyperledger Fabric documentation IBM Blockchain Founder's Handbook Blockchain Essentials Badge","title":"Additional Resources"},{"location":"references/#existing-networks-and-code-patterns","text":"IBM Food Trust TradeLens Trusted Identity World Wire Unbounded - Blockchain Network Finder IBM Blockchain Code Patterns","title":"Existing Networks and Code Patterns"},{"location":"references/#additional-labs","text":"Vehicle Lifecycle Demo Use Case Walkthrough IBM Blockchain Platform VSCode Extension Lab: Add Indices for Better Performing Queries","title":"Additional Labs"},{"location":"references/#lab-resources","text":"Port List for IBM Blockchain Platform Lab","title":"Lab resources"},{"location":"vscode-home/","text":"Welcome to the Visual Studio Code Lab Welcome to the Visual Studio Code (VSCode) Overview Lab. Visual Studio Code, or VSCode for short, is a popular source code editor developed by Microsoft for Windows, Linux and macOS. It is freely available and it includes support for debugging, embedded Git control, syntax highlighting, intelligent code completion, snippets, and code refactoring. VSCode allows for extensions that add support for popular languages, themes, debuggers, and more. IBM has developed a VSCode extension called the IBM Blockchain Platform Extension to help users develop their smart contracts. Throughout this lab you will experience using VSCode and the IBM Blockchain Platform Extension for the creation of a smart contract (chaincode). The first part of this lab is very basic and is meant to walk you through the fundamentals of the IBM Blockchain Platform Extension. Part two follows a tutorial called Commercial Paper which will utilize the new application programming model in Hyperledger Fabric version 1.4 - which is the first long term support release of Hyperledger Fabric. In part three, you will learn how to code a cross chaincode call in a smart contract as well as learn to use the integrated debugger to iterate through smart contract updates. In part four, you will create a loopback API against your commercial paper smart contract that exposes REST APIs for application front ends to call. Speaking of Hyperledger Fabric, in this lab we will be using a locally deployed Fabric runtime whose components will run as Docker containers on your lab workstation. You can also configure your IBM Blockchain Platform VSCode Extension to connect to multiple remote IBM Blockchain Platform environments (e.g., dev/test, staging, production). When you are ready to test your smart contract against a remote environment, you can connect your IBM Blockchain Platform VSCode Extension to the IBM Blockchain Platform running in the public IBM Cloud or on your own premises. You will get to deploy onto your own premises (well, premises provided to you in our lab environment!) in tomorrow's lab. In this lab we will be using the following versions: Visual Studio Code: 1.35.1 IBM Blockchain Platform Extension: 1.0.3 Hyperledger Fabric: v1.4.1 The Benefits of VSCode IBM Blockchain Platform Extension One of the hurdles in getting started with blockchain is the difficulty around the creation and testing of smart contracts across various DevOps environments. The VSCode IBM Blockchain Platform Extension has been created to assist users in developing, testing, and deploying smart contracts, enabling users to connect to a local Hyperledger Fabric development environment (what the lab today covers) to test smart contracts before deploying them into various remote runtimes such as IBM Cloud (with IBM Blockchain Platform for IBM Cloud) or on your own premises or other vendor cloud offerings (with IBM Blockchain Platform for Multicloud). Within VSCode, you can employ a series of commands to gain the maximum benefit of your blockchain network. Over the course of this lab, we will use many of these commands. Below is a list of commands: Command Description Add Gateway Add a Hyperledger Fabric instance gateway Add Identity To Wallet Add an identity to be used when connecting to a Hyperledger Fabric gateway Connect Via Gateway Connect to a Hyperledger Fabric blockchain using a gateway Create Smart Contract Project Create a new JavaScript or TypeScript smart contract project Create Identity (register and enroll) Create, register and enroll a new identity from the runtime certificate authority Debug Debug a Smart Contract Delete Gateway Delete a Hyperledger Fabric instance gateway Delete Package Delete a smart contract package Disconnect From Gateway Disconnect from the blockchain gateway you're currently connected to Edit Gateway Edit connection profile or wallet used for connecting to a blockchain gateway Export Connection Details Export connection details for the a Hyperledger Fabric instance Export Package Export an already-packaged smart contract package to use outside VSCode Generate Smart Contract Tests Create a functional level test file for instantiated smart contracts Import Package Import a smart contract package Install Smart Contract Install a smart contract package onto a peer Instantiate Smart Contract Instantiate an installed smart contract package onto a channel Open Fabric Runtime Terminal Open a terminal with access to the Fabric runtime (peer CLI) Package a Smart Contract Project Create a new smart contract package from a project in the Explorer Refresh Fabric Gateways Refresh the Fabric Gateways view Refresh Smart Contract Packages Refresh the Smart Contract Packages view Restart Local Fabric Ops Refresh the Local Fabric Ops view Start Fabric Runtime Start a Hyperledger Fabric instance Stop Fabric Runtime Stop a Hyperledger Fabric instance Submit Transaction Submit a transaction to a smart contract Evaluate Transaction Evaluate a smart contract transaction Teardown Fabric Runtime Teardown the local_fabric runtime (hard reset) Toggle Development Mode Toggle the Hyperledger Fabric instance development mode Upgrade Smart Contract Upgrade an instantiated smart contract View Homepage View the extensions homepage As you can see, these commands can do a lot. The IBM Blockchain Platform Extension development team works hard to add to the list of available commands and features. If you think there is a feature or enhancement that should be created, you can create an issue here: https://github.com/IBM-Blockchain/blockchain-vscode-extension/issues Equally, if you want to stay on top of all the releases of the extension and what updates came with each release, you can view that here: https://github.com/IBM-Blockchain/blockchain-vscode-extension/releases Tip If you find any typos, errors, or just want to provide helpful feedback to make this lab better, please click on the GitHub icon in the lower left corner of this page to be taken to our GitHub repository, from where you can create an Issue to suggest a correction or improvement. Thanks for your feedback! Acknowledgements Special thanks to the following contributors to this lab: Matthew Golby-Kirk Matt Lucas Dennis Miller Barry Silliman Garrett Woodworth Authors Austin Grice Jin VanStee","title":"Vscode home"},{"location":"vscode-home/#welcome-to-the-visual-studio-code-lab","text":"Welcome to the Visual Studio Code (VSCode) Overview Lab. Visual Studio Code, or VSCode for short, is a popular source code editor developed by Microsoft for Windows, Linux and macOS. It is freely available and it includes support for debugging, embedded Git control, syntax highlighting, intelligent code completion, snippets, and code refactoring. VSCode allows for extensions that add support for popular languages, themes, debuggers, and more. IBM has developed a VSCode extension called the IBM Blockchain Platform Extension to help users develop their smart contracts. Throughout this lab you will experience using VSCode and the IBM Blockchain Platform Extension for the creation of a smart contract (chaincode). The first part of this lab is very basic and is meant to walk you through the fundamentals of the IBM Blockchain Platform Extension. Part two follows a tutorial called Commercial Paper which will utilize the new application programming model in Hyperledger Fabric version 1.4 - which is the first long term support release of Hyperledger Fabric. In part three, you will learn how to code a cross chaincode call in a smart contract as well as learn to use the integrated debugger to iterate through smart contract updates. In part four, you will create a loopback API against your commercial paper smart contract that exposes REST APIs for application front ends to call. Speaking of Hyperledger Fabric, in this lab we will be using a locally deployed Fabric runtime whose components will run as Docker containers on your lab workstation. You can also configure your IBM Blockchain Platform VSCode Extension to connect to multiple remote IBM Blockchain Platform environments (e.g., dev/test, staging, production). When you are ready to test your smart contract against a remote environment, you can connect your IBM Blockchain Platform VSCode Extension to the IBM Blockchain Platform running in the public IBM Cloud or on your own premises. You will get to deploy onto your own premises (well, premises provided to you in our lab environment!) in tomorrow's lab. In this lab we will be using the following versions: Visual Studio Code: 1.35.1 IBM Blockchain Platform Extension: 1.0.3 Hyperledger Fabric: v1.4.1","title":"Welcome to the Visual Studio Code Lab"},{"location":"vscode-home/#the-benefits-of-vscode-ibm-blockchain-platform-extension","text":"One of the hurdles in getting started with blockchain is the difficulty around the creation and testing of smart contracts across various DevOps environments. The VSCode IBM Blockchain Platform Extension has been created to assist users in developing, testing, and deploying smart contracts, enabling users to connect to a local Hyperledger Fabric development environment (what the lab today covers) to test smart contracts before deploying them into various remote runtimes such as IBM Cloud (with IBM Blockchain Platform for IBM Cloud) or on your own premises or other vendor cloud offerings (with IBM Blockchain Platform for Multicloud). Within VSCode, you can employ a series of commands to gain the maximum benefit of your blockchain network. Over the course of this lab, we will use many of these commands. Below is a list of commands: Command Description Add Gateway Add a Hyperledger Fabric instance gateway Add Identity To Wallet Add an identity to be used when connecting to a Hyperledger Fabric gateway Connect Via Gateway Connect to a Hyperledger Fabric blockchain using a gateway Create Smart Contract Project Create a new JavaScript or TypeScript smart contract project Create Identity (register and enroll) Create, register and enroll a new identity from the runtime certificate authority Debug Debug a Smart Contract Delete Gateway Delete a Hyperledger Fabric instance gateway Delete Package Delete a smart contract package Disconnect From Gateway Disconnect from the blockchain gateway you're currently connected to Edit Gateway Edit connection profile or wallet used for connecting to a blockchain gateway Export Connection Details Export connection details for the a Hyperledger Fabric instance Export Package Export an already-packaged smart contract package to use outside VSCode Generate Smart Contract Tests Create a functional level test file for instantiated smart contracts Import Package Import a smart contract package Install Smart Contract Install a smart contract package onto a peer Instantiate Smart Contract Instantiate an installed smart contract package onto a channel Open Fabric Runtime Terminal Open a terminal with access to the Fabric runtime (peer CLI) Package a Smart Contract Project Create a new smart contract package from a project in the Explorer Refresh Fabric Gateways Refresh the Fabric Gateways view Refresh Smart Contract Packages Refresh the Smart Contract Packages view Restart Local Fabric Ops Refresh the Local Fabric Ops view Start Fabric Runtime Start a Hyperledger Fabric instance Stop Fabric Runtime Stop a Hyperledger Fabric instance Submit Transaction Submit a transaction to a smart contract Evaluate Transaction Evaluate a smart contract transaction Teardown Fabric Runtime Teardown the local_fabric runtime (hard reset) Toggle Development Mode Toggle the Hyperledger Fabric instance development mode Upgrade Smart Contract Upgrade an instantiated smart contract View Homepage View the extensions homepage As you can see, these commands can do a lot. The IBM Blockchain Platform Extension development team works hard to add to the list of available commands and features. If you think there is a feature or enhancement that should be created, you can create an issue here: https://github.com/IBM-Blockchain/blockchain-vscode-extension/issues Equally, if you want to stay on top of all the releases of the extension and what updates came with each release, you can view that here: https://github.com/IBM-Blockchain/blockchain-vscode-extension/releases Tip If you find any typos, errors, or just want to provide helpful feedback to make this lab better, please click on the GitHub icon in the lower left corner of this page to be taken to our GitHub repository, from where you can create an Issue to suggest a correction or improvement. Thanks for your feedback!","title":"The Benefits of VSCode IBM Blockchain Platform Extension"},{"location":"vscode-home/#acknowledgements","text":"Special thanks to the following contributors to this lab: Matthew Golby-Kirk Matt Lucas Dennis Miller Barry Silliman Garrett Woodworth","title":"Acknowledgements"},{"location":"vscode-home/#authors","text":"Austin Grice Jin VanStee","title":"Authors"},{"location":"vscode-part1/","text":"Section 1: Overview In this part of the lab, we will guide you through the steps for generating, installing and instantiating a smart contract and then testing that smart contract to verify that it works. Before all of that, we will have you start up the local Hyperledger Fabric network so that we can build our smart contract on top of it. In this lab, we have you deploy to a local network that is running on your laptop, but you can also connect the IBM Blockchain Platform VSCode Extension to either your IBM Blockchain Platform network running in the IBM Cloud or your IBM Blockchain Platform network running on your own premises. Below is a breakdown of Part 1 of our lab: Start up a Blockchain Network : We must make sure that all levels of software (docker, node, npm, docker-compose and yo) are at the correct level before we start building our smart contract. Then, we will install the IBM Blockchain Platform Extension that will allow us to create and develop our smart contract. Once we have done that, we will then start up the Hyperledger Fabric network, which will consist of a certificate authority (CA), Solo orderer (meant for dev/test), couchdb (world state database), ccenv (chaincode environment), and most importantly our peer. Create our Smart Contract : Now that we have a running Hyperledger Fabric blockchain network, we will create our smart contract. The smart contract will be very basic in nature, but we will explain what the contract is trying to accomplish before we go through some of the unique features that the extension can do for us and our smart contract. Package, Install and Instantiate our Smart Contract : Since we have an understanding of how our smart contract works, we will need to install (peer level command) it on our peer and then instantiate (channel level command) the installed smart contract on the channel. Once we have instantiated the smart contract, we will be able to submit transactions. Submit Transactions : What fun is it to have a working smart contract and have it instantiated across the channel, if we can't submit transactions? In this section, we will actually submit transactions from the UI of VSCode. We will see data get committed to the ledger. Tests : Once we have an instantiated smart contract on our channel, we will then test out the code to make sure that the contract will actually work when we submit transactions. This checks all the files within our smart contract and simulates all of our transactions. We will know we are cooking with gas when our test comes back successful. We will then generate a test file that will test our smart contract, while submitting transactions to the ledger. We will view the docker logs of our running smart contract and see the transactions being added to the logs as well as the ledger. Section 2: Start Up a Blockchain Network NOTE: For Part 1 of our lab, we will be using the terminal within VSCode. Do not execute the commands within the actual terminal application. You can enter them from the terminal application, but the instructions below will all be within the VSCode terminal. In Part 2 of this lab, you will use the terminal application. 1. Open up your terminal and type in the following commands below : tecadmin@ubuntubase:~$ node -v # We want Node to be v8.x or higher v8.11.3 tecadmin@ubuntubase:~$ npm -v # We want NPM to be v5.x or higher 5.6.0 tecadmin@ubuntubase:~$ yo --version # We want yo to be v2.x or higher 2.0.5 tecadmin@ubuntubase:~$ docker --version # We want Docker to be v17.06.2-ce or higher Docker version 17.06.2-ce, build cec0b72 tecadmin@ubuntubase:~$ docker-compose --version # We want Docker Compose to be v1.14.0 or higher docker-compose version 1.14.0, build c7bdf9e tecadmin@ubuntubase:~$ If you get a version that doesn't support our qualifications, raise your hand and tell the instructor. 2. From the Ubuntu Desktop, click on Visual Studio Code. The Visual Studio Code icon is on the right above the Cisco Anyconnect icon on the toolbar on the left. 3. Once you are in the Visual Studio Code application, you should see an outline of a block just below the extensions button (approximately the 6th button in VSCode). Go ahead and click on that button. Once you do, you'll see a similar screen as the image below 4. Hover your mouse over the Local Fabric Ops panel and we'll see three dots - ... - and click on those dots. We'll be presented with two options. Start Fabric Runtime and Teardown Fabric Runtime are those two options. We will want to click on Start Fabric Runtime in this case. This will start our local Hyperledger Fabric network. It will stand up a peer, certificate authority, orderer and a couchdb container. In addition to standing up these containers, it will join our peer to a channel called mychannel. The difference between Start Fabric Runtime and Teardown Fabric Runtime might be obvious, but Start Fabric Runtime grabs all of the Hyperledger Fabric images and starts them as containers. In addition, it builds the crypto material (certificates, public and private keys) and creates and joins a sample channel called mychannel . The other option, Teardown Fabric Runtime basically cleans up the network and removes all of the containers that Start Fabric Runtime builds. It does not remove the Hyperledger Fabric images that the Start Fabric Runtime pulls down into your local docker registry. To do a full cleanup, we will need to manually remove those images. 5. How do we know if we have a successful blockchain network up and running? I'm glad you asked! We will see messages flooding the Output panel. We will want to see a message that resembles the one below : [2/20/2019 7:26:54 PM] [INFO] 2019-02-21 00:26:34.756 UTC [cli.common] readBlock - INFO 002 Received block: 0 [2/20/2019 7:26:54 PM] [INFO] 2019-02-21 00:26:34.930 UTC [channelCmd] InitCmdFactory - INFO 001 Endorser and orderer connections initialized [2/20/2019 7:26:55 PM] [INFO] 2019-02-21 00:26:35.458 UTC [channelCmd] executeJoin - INFO 002 Successfully submitted proposal to join channel 6. We can verify that everything is up and working by entering the docker ps -a command that will print out all of our containers. Section 3: Create our Smart Contract Now that we have a local running Hyperledger Fabric network, let's create our Smart Contract that we will then install and instantiate onto our network. 1. We can do that by clicking on the gear icon in the bottom left and then clicking on Command Palette.. This will give us the option to do a series of commands, some that are VSCode-related and some that are IBM Blockchain Platform-related. 2. You will notice a series of commands pop up. Go ahead and enter this command below into the search bar : IBM Blockchain Platform: Create Smart Contract Project This command will generate a skeleton smart contract for us. We will walk through all that it generates in a second. 3. We might get a message that says the text below. If we don't, proceed onto the next step. : Can this extension install missing npm packages before proceeding? Select yes if that message comes up. What it is installing is generator-fabric which is actually the generator that creates our skeleton smart contract. 4. We'll then get a message that says : Chose smart contract language (esc to cancel) Choose JavaScript as our smart contract language of choice 5. The next prompt will ask you Name the type of asset managed by this smart contract . You can put whatever you would like to name your asset. For the sake of this lab experience, I will name my asset kale . 6. Then it will, simply, say Browse . That implies that it is looking for a folder to store the simple smart contract. Click on Browse and then go to your Desktop and click on the blank folder on the far right. There create and name a new folder and click on Create . Then hit on Save . 7. Then it will ask Choose how to open your new project and just click on Add to workplace . 8. If you click on the Explorer icon in the top left of VSCode, you'll see the Kale folder in there with a lot more files 9. Go ahead and untoggle the Kale folder and then untoggle the lib folder, in which you'll find the kale-contract.js file. Go ahead and click on that to open it up. Below is a breakdown of this simple smart contract: The line of code below will bring into scope a key Hyperledger Fabric class that will be used extensively by the smart contract -- Contract : const { Contract } = require('fabric-contract-api'); Below, we define the smart contract class KaleContract based on the built-in Fabric Contract class. The methods which implement the key transactions are defined within this class : class KaleContract extends Contract { Below, the function is called createKale and it takes kaleId and a value, both of which are strings. When this transaction is submitted, a new asset will be created, with key kaleId and value value. For example if we were to create \"001\", \"A bunch of kale\", then when we later read the value of key 001, we'll learn the value of that particular state is \"A bunch of kale\" : async createKale(ctx, kaleId, value) { const exists = await this.kaleExists(ctx, kaleId); if (exists) { throw new Error(`The kale ${kaleId} already exists`); } const asset = { value }; const buffer = Buffer.from(JSON.stringify(asset)); await ctx.stub.putState(kaleId, buffer); } You'll often hear such transactions, like below, referred to as \"queries\". As you can see, this function only takes kaleId, and will return the value of whatever state that key points to. : async readKale(ctx, kaleId) { const exists = await this.kaleExists(ctx, kaleId); if (!exists) { throw new Error(`The kale ${kaleId} does not exist`); } const buffer = await ctx.stub.getState(kaleId); const asset = JSON.parse(buffer.toString()); return asset; } Take a look at the other transactions in the contract at your leisure, then when you're happy, let's move on to packaging and deploying that contract so that we can start using it... Section 4: Package, Install and Instantiate our Smart Contract 1. Jump back down to the IBM Blockchain Platform section (the outline of a block icon). From there, click on the gear button in the bottom left and click on Command Palette... . Once it gives you a prompt in the top, enter the text that is below : IBM Blockchain Platform: Package a Smart Contract Project 2. Then it will bring in the package into our Smart Contract Packages section. If you had multiple folders open in your Editior perspective, it would ask you for which folder to package, but since there is only 1 it will grab the Kale folder. 3. Now, within the Local Fabric Ops section, you can untoggle Smart Contracts and then click on +Install . 4. It will ask you Choose which package to install on the peer and select Kale@0.0.1 . Then it will go ahead and install it for you on your peer. 5. Now that we have an installed smart contract, we need to instantiate it. You can do that by, you might have guessed, clicking on the +Instantiate button. Then it will ask you Choose a Smart Contract and Version to instantiate and you can select Kale@0.0.1 . It will pop up another prompt asking you which function you want to call. You can just hit the Enter key and bypass this prompt. Then it will ask if you want to Provide a Private Data collection configuration file and you can select No . Then it will instantiate our Kale smart contract to our channel, called mychannel . Section 5: Submit Transactions 1. From the IBM Blockchain Platform Extension, you can click on the local_fabric gateway. It will then use the admin ID. It will display all of your channels that this gateway can see, in this case it is only mychannel . If you untoggle mychannel you will see Kale@0.0.1 as an instantiated smart contract on the channel. If you had multiple smart contracts on here, you would see those as well. Now, if you untoggle Kale@0.0.1 you will see the various transactions you can execute. 2. From this perspective, you can right click on createKale and then click on Submit Transaction . Then it will prompt you for the arguments you want to pass in. You can enter the text below. It will give you another prompt for transient data, but you can hit enter to bypass this prompt and it will then execute the transaction. NOTE: Put your arguments between the brackets: \"001\", \"a bunch of kale\" See what I did there? Anyways.. 3. Now we can confirm that the transaction actually occured. There are a couple of ways we could do this. The first way we can test this out is by entering the following text below in our VSCode terminal: docker logs fabricvscodelocalfabric_peer0.org1.example.com | grep block * * 2019-06-11 14:36:33.321 UTC [gossip.privdata] StoreBlock - INFO 0a1 [mychannel] Received block [3] from buffer 2019-06-11 14:36:33.322 UTC [committer.txvalidator] Validate - INFO 0a2 [mychannel] Validated block [3] in 0ms 2019-06-11 14:36:33.432 UTC [kvledger] CommitWithPvtData - INFO 0a3 [mychannel] Committed block [3] with 1 transaction(s) in 109ms (state_validation=11ms block_commit=70ms state_commit=11ms) 4. The other option would be to right click on the readKale transaction in the Fabric Gateway section. Once you right click on readKale you can select Evaluate Transaction , which doesn't actually get recorded as a transaction, but rather as a query. If you select Submit Transaction , that would be recorded as a transaction. Once it gives you a prompt, enter the text below. Then hit enter and then enter again to bypass the transient data prompt and execute the query: \"001\" Output Logs: [6/11/2019 2:37:11 PM] [INFO] submitting transaction readKale with args 001 [6/11/2019 2:37:13 PM] [SUCCESS] Returned value from readKale: {\"value\":\"a bunch of kale\"} 5. We can also update our Kale by right clicking on the updateKale transaction and selecting Submit Transaction . You can enter the text below to update our existing kale. Again, hit enter to go to the next prompt and then enter again to bypass the transient data prompt and execute our transaction: \"001\", \"a bunch of organic kale\" 6. Now, we can repeat step 4 and execute the readKale transaction. This time, select Submit Transaction instead of Evaluate Transaction . Here is what to enter in the prompt: \"001\" Output Logs: [6/11/2019 2:42:56 PM] [INFO] evaluateTransaction [6/11/2019 2:43:01 PM] [INFO] evaluating transaction readKale with args 001 [6/11/2019 2:43:01 PM] [SUCCESS] Returned value from readKale: {\"value\":\"a bunch of organic kale\"} 7. Because Barry is on a major health kick and is hungry for some organic Kale, we can execute the deleteKale transaction after Barry transforms the Kale into its base nutrients fighting for attention along with everything else in his bloodstream. To do this, right click on the deleteKale transaction and select submit transaction and enter this between the brackets. Hit enter to go to the next prompt and then enter once more to actually execute the transaction: \"001\" 8. To confirm that it is actually deleted, you can execute the readKale transaction once more. Once you do that, you'll get an error message in the bottom right. Those errors talk about endorsement failure or no peers are available to be queried, but the real issue is that there is no kale with an ID of 001 Section 6: Tests 1. VSCode gives us a couple ways to test our smart contract. We will test them both, but let's focus on unit testing first. 2. If you go to the Editor perspective, toggle the test folder. Then right click on the kale-contract.js file and select Open in terminal . 3. Once you get your terminal prompt, enter the text below to test our smart contract out: tecadmin@ubuntubase:~/Documents/Kale/tests$ npm test Output Logs: KaleContract #kaleExists \u2713 should return true for a kale \u2713 should return false for a kale that does not exist #createKale \u2713 should create a kale \u2713 should throw an error for a kale that already exists #readKale \u2713 should return a kale \u2713 should throw an error for a kale that does not exist #updateKale \u2713 should update a kale \u2713 should throw an error for a kale that does not exist #deleteKale \u2713 should delete a kale \u2713 should throw an error for a kale that does not exist 10 passing (334ms) =============================== Coverage summary =============================== Statements : 100% ( 29/29 ) Branches : 100% ( 10/10 ) Functions : 100% ( 5/5 ) Lines : 100% ( 29/29 ) You should get all green signs with some check marks. That is a good sign that transactions should work as they are. Very nice! 4. Another way we can test is by generating a smart contract test client. To do that, jump back down to the IBM Blockchain Platform Extension by clicking on the outline of a block. Once you are there, right click on your smart contract that is in your Fabric Gateway section. Then select your only option, Generate Tests for Smart Contract . Then select JavaScript once it prompts you for which test language you prefer. 5. Then it will install some npm packages for us. You should see some messaging in the bottom right. Once that is done, scroll down to line 72 in the file that was generated. 6. On line 74 , enter the following within the brackets: \"001\", \"a new bunch of kale\" 7. Then save this file by either doing Control + s or by doing File - Save . Once you have done that, there should be a button that says Run Test in between lines 71 and 72. You can click on Run Test to actually run the test: Output Logs: KaleContract-Kale@0.0.1 \u2713 createKale (2352ms) 1 passing (3s) 8. All the other transactions will work as well, but you will need to save the file before trying to run the tests. Please try a few of the tests for yourself.","title":"Vscode part1"},{"location":"vscode-part1/#section-1-overview","text":"In this part of the lab, we will guide you through the steps for generating, installing and instantiating a smart contract and then testing that smart contract to verify that it works. Before all of that, we will have you start up the local Hyperledger Fabric network so that we can build our smart contract on top of it. In this lab, we have you deploy to a local network that is running on your laptop, but you can also connect the IBM Blockchain Platform VSCode Extension to either your IBM Blockchain Platform network running in the IBM Cloud or your IBM Blockchain Platform network running on your own premises. Below is a breakdown of Part 1 of our lab: Start up a Blockchain Network : We must make sure that all levels of software (docker, node, npm, docker-compose and yo) are at the correct level before we start building our smart contract. Then, we will install the IBM Blockchain Platform Extension that will allow us to create and develop our smart contract. Once we have done that, we will then start up the Hyperledger Fabric network, which will consist of a certificate authority (CA), Solo orderer (meant for dev/test), couchdb (world state database), ccenv (chaincode environment), and most importantly our peer. Create our Smart Contract : Now that we have a running Hyperledger Fabric blockchain network, we will create our smart contract. The smart contract will be very basic in nature, but we will explain what the contract is trying to accomplish before we go through some of the unique features that the extension can do for us and our smart contract. Package, Install and Instantiate our Smart Contract : Since we have an understanding of how our smart contract works, we will need to install (peer level command) it on our peer and then instantiate (channel level command) the installed smart contract on the channel. Once we have instantiated the smart contract, we will be able to submit transactions. Submit Transactions : What fun is it to have a working smart contract and have it instantiated across the channel, if we can't submit transactions? In this section, we will actually submit transactions from the UI of VSCode. We will see data get committed to the ledger. Tests : Once we have an instantiated smart contract on our channel, we will then test out the code to make sure that the contract will actually work when we submit transactions. This checks all the files within our smart contract and simulates all of our transactions. We will know we are cooking with gas when our test comes back successful. We will then generate a test file that will test our smart contract, while submitting transactions to the ledger. We will view the docker logs of our running smart contract and see the transactions being added to the logs as well as the ledger.","title":"Section 1: Overview"},{"location":"vscode-part1/#section-2-start-up-a-blockchain-network","text":"NOTE: For Part 1 of our lab, we will be using the terminal within VSCode. Do not execute the commands within the actual terminal application. You can enter them from the terminal application, but the instructions below will all be within the VSCode terminal. In Part 2 of this lab, you will use the terminal application. 1. Open up your terminal and type in the following commands below : tecadmin@ubuntubase:~$ node -v # We want Node to be v8.x or higher v8.11.3 tecadmin@ubuntubase:~$ npm -v # We want NPM to be v5.x or higher 5.6.0 tecadmin@ubuntubase:~$ yo --version # We want yo to be v2.x or higher 2.0.5 tecadmin@ubuntubase:~$ docker --version # We want Docker to be v17.06.2-ce or higher Docker version 17.06.2-ce, build cec0b72 tecadmin@ubuntubase:~$ docker-compose --version # We want Docker Compose to be v1.14.0 or higher docker-compose version 1.14.0, build c7bdf9e tecadmin@ubuntubase:~$ If you get a version that doesn't support our qualifications, raise your hand and tell the instructor. 2. From the Ubuntu Desktop, click on Visual Studio Code. The Visual Studio Code icon is on the right above the Cisco Anyconnect icon on the toolbar on the left. 3. Once you are in the Visual Studio Code application, you should see an outline of a block just below the extensions button (approximately the 6th button in VSCode). Go ahead and click on that button. Once you do, you'll see a similar screen as the image below 4. Hover your mouse over the Local Fabric Ops panel and we'll see three dots - ... - and click on those dots. We'll be presented with two options. Start Fabric Runtime and Teardown Fabric Runtime are those two options. We will want to click on Start Fabric Runtime in this case. This will start our local Hyperledger Fabric network. It will stand up a peer, certificate authority, orderer and a couchdb container. In addition to standing up these containers, it will join our peer to a channel called mychannel. The difference between Start Fabric Runtime and Teardown Fabric Runtime might be obvious, but Start Fabric Runtime grabs all of the Hyperledger Fabric images and starts them as containers. In addition, it builds the crypto material (certificates, public and private keys) and creates and joins a sample channel called mychannel . The other option, Teardown Fabric Runtime basically cleans up the network and removes all of the containers that Start Fabric Runtime builds. It does not remove the Hyperledger Fabric images that the Start Fabric Runtime pulls down into your local docker registry. To do a full cleanup, we will need to manually remove those images. 5. How do we know if we have a successful blockchain network up and running? I'm glad you asked! We will see messages flooding the Output panel. We will want to see a message that resembles the one below : [2/20/2019 7:26:54 PM] [INFO] 2019-02-21 00:26:34.756 UTC [cli.common] readBlock - INFO 002 Received block: 0 [2/20/2019 7:26:54 PM] [INFO] 2019-02-21 00:26:34.930 UTC [channelCmd] InitCmdFactory - INFO 001 Endorser and orderer connections initialized [2/20/2019 7:26:55 PM] [INFO] 2019-02-21 00:26:35.458 UTC [channelCmd] executeJoin - INFO 002 Successfully submitted proposal to join channel 6. We can verify that everything is up and working by entering the docker ps -a command that will print out all of our containers.","title":"Section 2: Start Up a Blockchain Network"},{"location":"vscode-part1/#section-3-create-our-smart-contract","text":"Now that we have a local running Hyperledger Fabric network, let's create our Smart Contract that we will then install and instantiate onto our network. 1. We can do that by clicking on the gear icon in the bottom left and then clicking on Command Palette.. This will give us the option to do a series of commands, some that are VSCode-related and some that are IBM Blockchain Platform-related. 2. You will notice a series of commands pop up. Go ahead and enter this command below into the search bar : IBM Blockchain Platform: Create Smart Contract Project This command will generate a skeleton smart contract for us. We will walk through all that it generates in a second. 3. We might get a message that says the text below. If we don't, proceed onto the next step. : Can this extension install missing npm packages before proceeding? Select yes if that message comes up. What it is installing is generator-fabric which is actually the generator that creates our skeleton smart contract. 4. We'll then get a message that says : Chose smart contract language (esc to cancel) Choose JavaScript as our smart contract language of choice 5. The next prompt will ask you Name the type of asset managed by this smart contract . You can put whatever you would like to name your asset. For the sake of this lab experience, I will name my asset kale . 6. Then it will, simply, say Browse . That implies that it is looking for a folder to store the simple smart contract. Click on Browse and then go to your Desktop and click on the blank folder on the far right. There create and name a new folder and click on Create . Then hit on Save . 7. Then it will ask Choose how to open your new project and just click on Add to workplace . 8. If you click on the Explorer icon in the top left of VSCode, you'll see the Kale folder in there with a lot more files 9. Go ahead and untoggle the Kale folder and then untoggle the lib folder, in which you'll find the kale-contract.js file. Go ahead and click on that to open it up. Below is a breakdown of this simple smart contract: The line of code below will bring into scope a key Hyperledger Fabric class that will be used extensively by the smart contract -- Contract : const { Contract } = require('fabric-contract-api'); Below, we define the smart contract class KaleContract based on the built-in Fabric Contract class. The methods which implement the key transactions are defined within this class : class KaleContract extends Contract { Below, the function is called createKale and it takes kaleId and a value, both of which are strings. When this transaction is submitted, a new asset will be created, with key kaleId and value value. For example if we were to create \"001\", \"A bunch of kale\", then when we later read the value of key 001, we'll learn the value of that particular state is \"A bunch of kale\" : async createKale(ctx, kaleId, value) { const exists = await this.kaleExists(ctx, kaleId); if (exists) { throw new Error(`The kale ${kaleId} already exists`); } const asset = { value }; const buffer = Buffer.from(JSON.stringify(asset)); await ctx.stub.putState(kaleId, buffer); } You'll often hear such transactions, like below, referred to as \"queries\". As you can see, this function only takes kaleId, and will return the value of whatever state that key points to. : async readKale(ctx, kaleId) { const exists = await this.kaleExists(ctx, kaleId); if (!exists) { throw new Error(`The kale ${kaleId} does not exist`); } const buffer = await ctx.stub.getState(kaleId); const asset = JSON.parse(buffer.toString()); return asset; } Take a look at the other transactions in the contract at your leisure, then when you're happy, let's move on to packaging and deploying that contract so that we can start using it...","title":"Section 3: Create our Smart Contract"},{"location":"vscode-part1/#section-4-package-install-and-instantiate-our-smart-contract","text":"1. Jump back down to the IBM Blockchain Platform section (the outline of a block icon). From there, click on the gear button in the bottom left and click on Command Palette... . Once it gives you a prompt in the top, enter the text that is below : IBM Blockchain Platform: Package a Smart Contract Project 2. Then it will bring in the package into our Smart Contract Packages section. If you had multiple folders open in your Editior perspective, it would ask you for which folder to package, but since there is only 1 it will grab the Kale folder. 3. Now, within the Local Fabric Ops section, you can untoggle Smart Contracts and then click on +Install . 4. It will ask you Choose which package to install on the peer and select Kale@0.0.1 . Then it will go ahead and install it for you on your peer. 5. Now that we have an installed smart contract, we need to instantiate it. You can do that by, you might have guessed, clicking on the +Instantiate button. Then it will ask you Choose a Smart Contract and Version to instantiate and you can select Kale@0.0.1 . It will pop up another prompt asking you which function you want to call. You can just hit the Enter key and bypass this prompt. Then it will ask if you want to Provide a Private Data collection configuration file and you can select No . Then it will instantiate our Kale smart contract to our channel, called mychannel .","title":"Section 4: Package, Install and Instantiate our Smart Contract"},{"location":"vscode-part1/#section-5-submit-transactions","text":"1. From the IBM Blockchain Platform Extension, you can click on the local_fabric gateway. It will then use the admin ID. It will display all of your channels that this gateway can see, in this case it is only mychannel . If you untoggle mychannel you will see Kale@0.0.1 as an instantiated smart contract on the channel. If you had multiple smart contracts on here, you would see those as well. Now, if you untoggle Kale@0.0.1 you will see the various transactions you can execute. 2. From this perspective, you can right click on createKale and then click on Submit Transaction . Then it will prompt you for the arguments you want to pass in. You can enter the text below. It will give you another prompt for transient data, but you can hit enter to bypass this prompt and it will then execute the transaction. NOTE: Put your arguments between the brackets: \"001\", \"a bunch of kale\" See what I did there? Anyways.. 3. Now we can confirm that the transaction actually occured. There are a couple of ways we could do this. The first way we can test this out is by entering the following text below in our VSCode terminal: docker logs fabricvscodelocalfabric_peer0.org1.example.com | grep block * * 2019-06-11 14:36:33.321 UTC [gossip.privdata] StoreBlock - INFO 0a1 [mychannel] Received block [3] from buffer 2019-06-11 14:36:33.322 UTC [committer.txvalidator] Validate - INFO 0a2 [mychannel] Validated block [3] in 0ms 2019-06-11 14:36:33.432 UTC [kvledger] CommitWithPvtData - INFO 0a3 [mychannel] Committed block [3] with 1 transaction(s) in 109ms (state_validation=11ms block_commit=70ms state_commit=11ms) 4. The other option would be to right click on the readKale transaction in the Fabric Gateway section. Once you right click on readKale you can select Evaluate Transaction , which doesn't actually get recorded as a transaction, but rather as a query. If you select Submit Transaction , that would be recorded as a transaction. Once it gives you a prompt, enter the text below. Then hit enter and then enter again to bypass the transient data prompt and execute the query: \"001\" Output Logs: [6/11/2019 2:37:11 PM] [INFO] submitting transaction readKale with args 001 [6/11/2019 2:37:13 PM] [SUCCESS] Returned value from readKale: {\"value\":\"a bunch of kale\"} 5. We can also update our Kale by right clicking on the updateKale transaction and selecting Submit Transaction . You can enter the text below to update our existing kale. Again, hit enter to go to the next prompt and then enter again to bypass the transient data prompt and execute our transaction: \"001\", \"a bunch of organic kale\" 6. Now, we can repeat step 4 and execute the readKale transaction. This time, select Submit Transaction instead of Evaluate Transaction . Here is what to enter in the prompt: \"001\" Output Logs: [6/11/2019 2:42:56 PM] [INFO] evaluateTransaction [6/11/2019 2:43:01 PM] [INFO] evaluating transaction readKale with args 001 [6/11/2019 2:43:01 PM] [SUCCESS] Returned value from readKale: {\"value\":\"a bunch of organic kale\"} 7. Because Barry is on a major health kick and is hungry for some organic Kale, we can execute the deleteKale transaction after Barry transforms the Kale into its base nutrients fighting for attention along with everything else in his bloodstream. To do this, right click on the deleteKale transaction and select submit transaction and enter this between the brackets. Hit enter to go to the next prompt and then enter once more to actually execute the transaction: \"001\" 8. To confirm that it is actually deleted, you can execute the readKale transaction once more. Once you do that, you'll get an error message in the bottom right. Those errors talk about endorsement failure or no peers are available to be queried, but the real issue is that there is no kale with an ID of 001","title":"Section 5: Submit Transactions"},{"location":"vscode-part1/#section-6-tests","text":"1. VSCode gives us a couple ways to test our smart contract. We will test them both, but let's focus on unit testing first. 2. If you go to the Editor perspective, toggle the test folder. Then right click on the kale-contract.js file and select Open in terminal . 3. Once you get your terminal prompt, enter the text below to test our smart contract out: tecadmin@ubuntubase:~/Documents/Kale/tests$ npm test Output Logs: KaleContract #kaleExists \u2713 should return true for a kale \u2713 should return false for a kale that does not exist #createKale \u2713 should create a kale \u2713 should throw an error for a kale that already exists #readKale \u2713 should return a kale \u2713 should throw an error for a kale that does not exist #updateKale \u2713 should update a kale \u2713 should throw an error for a kale that does not exist #deleteKale \u2713 should delete a kale \u2713 should throw an error for a kale that does not exist 10 passing (334ms) =============================== Coverage summary =============================== Statements : 100% ( 29/29 ) Branches : 100% ( 10/10 ) Functions : 100% ( 5/5 ) Lines : 100% ( 29/29 ) You should get all green signs with some check marks. That is a good sign that transactions should work as they are. Very nice! 4. Another way we can test is by generating a smart contract test client. To do that, jump back down to the IBM Blockchain Platform Extension by clicking on the outline of a block. Once you are there, right click on your smart contract that is in your Fabric Gateway section. Then select your only option, Generate Tests for Smart Contract . Then select JavaScript once it prompts you for which test language you prefer. 5. Then it will install some npm packages for us. You should see some messaging in the bottom right. Once that is done, scroll down to line 72 in the file that was generated. 6. On line 74 , enter the following within the brackets: \"001\", \"a new bunch of kale\" 7. Then save this file by either doing Control + s or by doing File - Save . Once you have done that, there should be a button that says Run Test in between lines 71 and 72. You can click on Run Test to actually run the test: Output Logs: KaleContract-Kale@0.0.1 \u2713 createKale (2352ms) 1 passing (3s) 8. All the other transactions will work as well, but you will need to save the file before trying to run the tests. Please try a few of the tests for yourself.","title":"Section 6: Tests"},{"location":"vscode-part2/","text":"Section 1: Commercial Paper Overview This tutorial works with a sample commercial paper trading network called PaperNet . Commercial paper is a type of unsecured lending in the form of a \"promissory note\". The papers are normally issued by large corporations to raise funds to meet short-term financial obligations at a fixed rate of interest. Once issued at a fixed price, for a fixed term, another company or bank will purchase them at a discount to the face value and when the term is up, they will be redeemed for their face value. As an example, if a paper was issued at a face value of 10M USD for a 6-month term at 2% interest then it could be bought for 9.8M USD (10M less 2%) by another company or bank who is willing to bear the risk that the issuer will not default. Once the term is up, then the paper could be redeemed or sold back to the issuer for its full face value of 10M USD. Between buying and redemption, the paper can be bought or sold between different parties on a commercial paper market. These three key steps of issue, buy and redeem are the main transactions in a simplified commercial paper marketplace, which we will mirror in our lab. We will see a commercial paper issued by a company called MagnetoCorp and, once issued on the commercial paper blockchain network, another company called DigiBank will first buy the paper and then redeem it. You'll act as a developer, end user, and administrator, within different organizations, performing various steps designed to help you understand what it's like to collaborate as two different organizations working independently, but according to mutually agreed rules in a Hyperledger Fabric network. Below is an image of our PaperNet network. For our lab, we will create Isabella who is with MagnetoCorp. Additionally, we will create Balaji who is with DigiBank. Isabella will issue a paper for the network. The paper will have an ID number, when it was issued, the maturity date, and the face value in USD. Balaji, from DigiBank, will then buy the paper and then eventually redeem it. Below is the full breakdown of Part 2 of this lab: Setting the Stage : Based off of Part 1, we have started a blockchain network, created a smart contract, created and run tests and then submitted transactions. For Part 2, we need to create a couple more docker containers that will set us up for success for the rest of the lab. One of these containers will just monitor the docker network we are operating in. If you have no idea what a docker network is, I will explain later on. The other container contains Hyperledger Fabric tools and is named cliMagnetoCorp, as MagnetoCorp will use the Hyperledger Fabric command line interface (cli) within this container. Install and Instantiate Smart Contract : Now that we have those new docker containers up and running, we will enter our cliMagnetoCorp container and install and instantiate our smart contract. Since we are connected to the same running local Hyperledger Fabric network, we will see the smart contract show up in VSCode. Issue Identities and Submit Transactions : In this section, we will issue two identities. One is an end-user named Isabella with MagnetoCorp. She will invoke a transaction that will issue a paper. Then we will issue an identity for DigiBank named Balaji. Balaji will act as the adminstrator for DigiBank and will buy and redeem the paper that Isabella issued. Balaji is important in this lab, as we will add a Fabric Gateway connection to connect to his perspective of the network. Create Fabric Gateways and Submit Transactions : In this section we will create gateways that allows VSCode to connect to a running Hyperledger Fabric or IBM Blockchain Platform instance through a connection profile. In this lab, we will connect to our local_fabric network, which is also the Papernet network. We will create two gateways and associate our identities to these gateways. That way we can ensure the appropriate people are making the transactions they should. Lab Cleanup : This is the most bittersweet part of the entire lab. It means that this lab portion is over and we have to clean up. If you have kids (I don't), I'd imagine their faces are sad and full of despair when you (the guardian) tell them to clean up their mess. I'd also like to imagine your face is making a similar expression when we get to this lab. It's okay, more fun is going to be had soon - very soon! Loopback APIs : We have proven that we can submit transactions through the command line interface (CLI) and the VSCode user interface. In this section, we will deploy two loopback API applications (for each of our organizations) and submit transactions through loopback. We will also include some transactions through the CLI and VSCode. Section 2: Setting the Stage 1. Navigate to your Desktop and then do a git clone of a repository to gather all the things you need to run through this tutorial : tecadmin@ubuntubase:~$ cd Desktop/ tecadmin@ubuntubase:~/Desktop$ ls -l total 0 drwxr-xr-x 16 tecadmin tecadmin 512 Jun 11 12:34 Kale tecadmin@ubuntubase:~/Desktop$ git clone https://github.com/austingrice/fabric-samples-cp.git Cloning into 'fabric-samples-cp'... remote: Enumerating objects: 85, done. remote: Counting objects: 100% (85/85), done. remote: Compressing objects: 100% (71/71), done. remote: Total 2658 (delta 26), reused 71 (delta 13), pack-reused 2573 Receiving objects: 100% (2658/2658), 927.08 KiB | 0 bytes/s, done. Resolving deltas: 100% (1293/1293), done. tecadmin@ubuntubase:~/Desktop$ ls -l total 0 drwxr-xr-x 22 tecadmin tecadmin 704 Jun 11 12:41 fabric-samples-cp drwxr-xr-x 16 tecadmin tecadmin 512 Jun 11 12:34 Kale 2. Then, do a docker network list to see all the running Docker networks : tecadmin@ubuntubase:~/Desktop$ docker network list NETWORK ID NAME DRIVER SCOPE ad2e1a3e2fc2 bridge bridge local 35837170ae5b fabricvscodelocalfabric_basic bridge local c5e0411b0d34 host host local 42ffa501f2f9 none null local 3. The network we are operating out of is the fabricvscodelocalfabric_basic network. You can see that by entering the following command below : tecadmin@ubuntubase:~/Desktop$ docker network inspect fabricvscodelocalfabric_basic That command will show you all the containers running in this network. In a nutshell, docker networks are natural ways to isolate containers from other containers or other networks. Having containers within a network allows them to communicate with other containers in the same network. 4. Within VSCode, go to the Explorer perspective and click on File and select Add Folder to Workplace.. . This will allow us to work from an Untitled Workplace, but have the fabric-samples-cp folder in there. 5. Within VSCode, navigate to the folder below within MagnetoCorp : fabric-samples-cp - commercial-paper - organizations - magnetocorp - configuration - cli You will see two files in there. One file is monitordocker.sh that will produce log messages across the network that you specify it to look at. If you click on this file to open it up, you'll see the file is called to look at the fabricvscodelocalfabric_basic Docker network. The other file is docker-compose.yml , which pulls down a fabric-tools container that is connected to our local network. When we spun up our local_fabric network, back in Part 1, it placed all the cryptographic material in our /home/tecadmin/.fabric-vscode/runtime/crypto-config/ directory. It is then taking all the crypto material and placing it in our fabric-tools container. This will make more sense once we install and instantiate the smart contract from this container instead of VSCode. 6. Now from the terminal navigate to the cli directory within MagnetoCorp. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop$ cd fabric-samples-cp/commercial-paper/organization/magnetocorp/configuration/cli/ tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/configuration/cli/$ ls -l total 16 -rw-r--r-- 1 tecadmin tecadmin 1168 Jun 11 12:41 docker-compose.yml -rwxr-xr-x 1 tecadmin tecadmin 751 Jun 11 12:44 monitordocker.sh 7. From here, we can actually start the monitordocker.sh script by entering the command below. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/configuration/cli/$ ./monitordocker.sh fabricvscodelocalfabric_basic # 8. Since this terminal is occupied with log messages, let's open another terminal tab. We can open a new tab by clicking on File and then selecting New Tab 9. When you opened a new tab, you should have been taken to the same file path that you were in on the previous tab. Now that we have a command line ready, go ahead and enter the command below that will create a cliMagnetoCorp container for our docker network to use. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/configuration/cli/$ docker-compose -f docker-compose.yml up -d cliMagnetoCorp . . # We'll see docker messages . Status: Downloaded newer image for hyperledger/fabric-tools:latest Creating cliMagnetoCorp ... Creating cliMagnetoCorp ... done When we first install the smart contract, we will go through the cliMagnetoCorp container, which is our Administrator Console. This will allow us to use Fabric peer commands. 10. We can also do a docker ps -a command to see all of our docker containers. We should see two new containers - cliMagnetoCorp and logspout from steps 9 and 10. 11. Equally, we could do docker network inspect fabricvscodelocalfabric_basic to see all of our containers together in one network - and no, not in a blockchain network. They are, however, the components that make up our local blockchain network :-) Section 3: Install and Instantiate Commercial Paper Smart Contract Before we actually install the commercial paper smart contract, let's actually open the file to see what the smart contract is trying to do. 1. From your explorer perspective within VSCode, navigate from the fabric-samples-cp folder to the contract folder of MagnetoCorp : fabric-samples-cp - commercial-paper - organization - magnetocorp - contract Within the lib folder, you'll see 3 javascript (.js) files in there. Click on the papercontract.js file, which will open it within VSCode Let's dissect our papercontract.js file as it is our smart contract. We will only go over the issue transaction, but the other transactions follow pretty closely to this one Below, these 2 lines of code bring into scope two key Hyperledger Fabric classes that will be used extensively by the smart contract -- Contract and Context : // Fabric smart contract classes const { Contract, Context } = require('fabric-contract-api'); Below, we define the smart contract class CommercialPaperContract based on the built-in Fabric Contract class. The methods which implement the key transactions to issue, buy and redeem commercial paper are defined within this class : /** * Define commercial paper smart contract by extending Fabric Contract class * */ class CommercialPaperContract extends Contract { Below, this method defines the commercial paper issue transaction for the commercial paper blockchain network. The parameters that are passed to this method will be used to create the new commercial paper. Locate and examine the buy and redeem transactions within the smart contract : /** * Issue commercial paper * * @param {Context} ctx the transaction context * @param {String} issuer commercial paper issuer * @param {Integer} paperNumber paper number for this issuer * @param {String} issueDateTime paper issue date * @param {String} maturityDateTime paper maturity date * @param {Integer} faceValue face value of paper */ async issue(ctx, issuer, paperNumber, issueDateTime, maturityDateTime, faceValue) { Within the issue transaction, this statement creates a new commercial paper in memory using the CommercialPaper class with the supplied transaction inputs. Examine the buy, get paper and redeem transactions to see how they similarly use this class : // create an instance of the paper let paper = CommercialPaper.createInstance(issuer, paperNumber, issueDateTime, maturityDateTime, faceValue); Below, this statement adds the new commercial paper to the ledger using ctx.paperList , an instance of a PaperList class that was created when the smart contract context CommercialPaperContext was initialized. Again, examine the buy and redeem methods to see how they use this class : // Add the paper to the list of all similar commercial papers in the ledger world state await ctx.paperList.addPaper(paper); Below you will find that this statement returns a binary buffer as response from the issue transaction for processing by the caller of the smart contract : // Must return a serialized paper to caller of smart contract return paper.toBuffer(); 2. Now that we have an understanding of the smart contract, let's actually install it on our peer through our terminal application. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/configuration/cli/$ docker exec cliMagnetoCorp peer chaincode install -n papercontract -v 0 -p /opt/gopath/src/github.com/contract -l node 2019-06-11 17:48:23.721 UTC [chaincodeCmd] checkChaincodeCmdParams - INFO 001 Using default escc 2019-06-11 17:48:23.721 UTC [chaincodeCmd] checkChaincodeCmdParams - INFO 002 Using default vscc 2019-06-11 17:48:23.862 UTC [chaincodeCmd] install - INFO 003 Installed remotely response: status:200 payload:\"OK\" A message saying 200 is a great sign to see. If you notice, we are not in the contract folder of our command line interface. Instead, we are entering the cliMagnetoCorp docker container with docker exec cliMagnetoCorp and navigating to the /opt/gopath/src/github.com/contract file path within our container to grab the files we need to install the smart contract. The -n papercontract flag names our smart contract papercontract. The -v 0 gives our smart contract a version of 0. Finally, the -l node tells us that the language of our smart contract is nodejs. The picture below goes into detail, visually, as to how we are actually installing a copy of the commercial paper smart contract on our peer. 3. Since our network is connected to our VSCode instance, you can refresh the Local Fabric Ops panel in VSCode under the IBM Blockchain Extension . The refresh button ( unclosed circle icon ) is revealed when you hover your mouse over the Local Fabric Ops panel 4. Since we have installed the smart contract, we should actually make it active by instantiating it. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/configuration/cli/$ docker exec cliMagnetoCorp peer chaincode instantiate -n papercontract -v 0 -l node -c '{\"Args\":[\"org.papernet.commercialpaper:instantiate\"]}' -C mychannel -P \"\" 2019-06-11 17:50:34.673 UTC [chaincodeCmd] InitCmdFactory - INFO 001 Retrieved channel (mychannel) orderer endpoint: orderer.example.com:17050 2019-06-11 17:50:34.675 UTC [chaincodeCmd] checkChaincodeCmdParams - INFO 002 Using default escc 2019-06-11 17:50:34.675 UTC [chaincodeCmd] checkChaincodeCmdParams - INFO 003 Using default vscc tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/configuration/cli/$ As you can see in the image below, we are instantiating a copy of the commercial paper smart contract on our MagnetoCorp peer. Similar to the installation of the smart contract, the instantiation goes into the cliMagnetoCorp container. After successfully instantiating the smart contract, there will be a commercial paper smart contract docker image and container. 5. You will know our instantiate command worked when we get our command prompt back without any error messages. You can really verify it worked by going back to the VSCode and refreshing the Local Fabric Ops panel and you should see it under the instantiate section. Section 4: Create Identities and Submit Transactions Now that we have a ready-to-use smart contract, let's issue some identities so that those identities can invoke and query transactions. 1. You should be within the cli folder of the MagnetoCorp folder. You can confirm this by issuing the command below. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/configuration/cli/$ pwd /home/tecadmin/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/configuration/cli tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/configuration/cli/$ 2. This is a good sign. Issue the following command below to get to the application folder within MagnetoCorp. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/configuration/cli/$ cd ../../application/ tecadmin@ubuntubase:~/Desktop/fabric-samples/commercial-paper/organization/magnetocorp/application$ 3. Within VSCode, navigate to the same folder : fabric-samples-cp - commercial-paper - organization - magnetocorp - appplication 4. In that folder, you should see a file called addtoWallet.js . Go ahead and click on it to open it up. 5. On line 25, you should see what is below : const key = fs.readFileSync(path.join(credPath, '/msp/keystore/ PUT_PRIVATE_KEY_HERE ')).toString(); 6. To put in the file name of your actual private key, you can enter the command below in your terminal application to find the key's file name. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/application$ ls -l /home/tecadmin/.fabric-vscode/runtime/crypto-config/peerOrganizations/org1.example.com/users/User1@org1.example.com/msp/keystore/ -rw-------@ 1 tecadmin tecadmin 241 Jun 11 08:57 e7a117b799890646fe1d6e688d9c979845a411830400b673e2fe7dc01f91f9b8_sk 7. Now, copy your private key's file name, e7a117b799890646fe1d6e688d9c979845a411830400b673e2fe7dc01f91f9b8_sk in this example- but your name will differ- and paste it in the field asking for your private key. For example, line 25 looks like this now. NOTE: scroll over to see the entire key file name below: const key = fs.readFileSync(path.join(credPath, '/msp/keystore/e7a117b799890646fe1d6e688d9c979845a411830400b673e2fe7dc01f91f9b8_sk')).toString(); NOTE: It is of the upmost importance that you are doing this from the magnetocorp/application folder and you save this file. We will do the DigiBank folder here in a second. 8. Go ahead and save this file by either doing File - Save or Control + s . 9. Back in your terminal application, you can enter the command below to install some dependencies. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/application$ npm install . . # A bunch of output, with some of the output repeating . node-pre-gyp WARN Using request for node-pre-gyp https download [grpc] Success: \"/home/tecadmin/Desktop/fabric-samples/commercial-paper/organization/magnetocorp/application/node_modules/grpc/src/node/extension_binary/node-v57-darwin-x64-unknown/grpc_node.node\" is installed via remote npm notice created a lockfile as package-lock.json. You should commit this file. npm WARN nodejs@1.0.0 No description npm WARN nodejs@1.0.0 No repository field. added 318 packages in 36.994s 10. Since we are in our command line, let's issue the following command that will create Isabella. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/application$ node addToWallet.js done 11. We will know it worked if we can execute the following command successfully. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/application$ ls -l ../identity/user/isabella/wallet/ total 0 drwxr-xr-x 5 tecadmin tecadmin 160 Jun 11 12:53 User1@org1.example.com tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/application$ ls -l ../identity/user/isabella/wallet/User1@org1.example.com/ total 24 -rw-r--r-- 1 tecadmin tecadmin 1037 Jun 11 12:53 User1@org1.example.com -rw-r--r-- 1 tecadmin tecadmin 246 Jun 11 12:53 e7a117b799890646fe1d6e688d9c979845a411830400b673e2fe7dc01f91f9b8-priv -rw-r--r-- 1 tecadmin tecadmin 182 Jun 11 12:53 e7a117b799890646fe1d6e688d9c979845a411830400b673e2fe7dc01f91f9b8-pub Keys are vital to understanding how transactions and identity work within a blockchain network. Below is a breakdown of the keys and certificate used in this example: a private key e7a117b799...-priv used to sign transactions on Isabella's behalf, but not distributed outside of her immediate control a public key e7a117b799...-pub which is cryptographically linked to Isabella's private key. This public key is contained within Isabella's X.509 certificate a certificate User1@org.example.com which contains Isabella's public key and other X.509 attributes added by the Certificate Authority at certificate creation. This certificate is distributed to the network so that different actors at different times can cryptographically verify information signed by Isabella's private key 12. Before we submit our first transaction, let's go over it below. You can find the code by clicking on issue.js within the magnetocorp/application folder in VSCode. Below we bring two key Hyperledger Fabric SDK classes into scope -- Wallet and Gateway . Because Isabella's X.509 certificate is in the local file system, the application uses FileSystemWallet : // Bring key classes into scope, most importantly Fabric SDK network class const { FileSystemWallet, Gateway } = require('fabric-network'); Below, this statement identifies that the application will use Isabella's wallet when it connects to the blockchain network channel. The application will select a particular identity within Isabella's wallet. (The wallet must have been loaded with Isabella's X.509 certificate -- that's what addToWallet.js does): // A wallet stores a collection of identities for use const wallet = new FileSystemWallet('../identity/user/isabella/wallet'); This line of code, below, connects to the network using the gateway identified by connectionProfile, using the identity referred to in connectionOptions. See how ../gateway/networkConnection.yaml and User1@org1.example.com are used for these values respectively: // Connect to gateway using application specified parameters await gateway.connect(connectionProfile, connectionOptions); Below in the couple lines of code, the application connects to the network channel mychannel , where the papercontract was previously instantiated. If you had a different channel name, you would have to modify this line of code: // Access commercial paper network const network = await gateway.getNetwork('mychannel'); Below, this statement gives the application addressability to the smart contract defined by the namespace org.papernet.commercialpaper within papercontract . Once an application has issued getContract , it can submit any transaction implemented within it: // Get addressability to commercial paper contract const contract = await network.getContract('papercontract', 'org.papernet.comm...'); Below, these lines of code submit a transaction to the network using the issue transaction defined within the smart contract. MagnetoCorp, 00001 are the values to be used by the issue transaction to create a new commercial paper: // issue commercial paper const issueResponse = await contract.submitTransaction('issue','MagnetoCorp', '00001', '2020-05-31', '2020-11-30','5000000'); This statement, below, processes the response from the issue transaction. The response needs to be deserialized from a buffer into paper, a CommercialPaper object which can be interpreted correctly by the application: // process response let paper = CommercialPaper.fromBuffer(issueResponse); 13. Now that we have Isabella from MagnetoCorp, let's perform the issue transaction from our terminal. NOTE: scroll over to see the entire command below: tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/application$ node issue.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper issue transaction. 2019-02-22T17:55:20.631Z - info: [TransactionEventHandler]: _strategySuccess: strategy success for transaction \"f8e124886d6cb84434cb6a996f4889145c0541199c88bab7d4d85ae41266e51e\" Process issue transaction response. MagnetoCorp commercial paper : 00001 successfully issued for value 5000000 Transaction complete. Disconnect from Fabric gateway. Issue program complete. This successfully committed a transaction to the ledger. See how it outputted a transaction hash for us. You can look at our monitoring docker terminal tab as well. As you can see in the image below, we are using the certificate belonging to Isabella to submit our paper issue transaction. Once we verify that Isabella can submit a transaction (via her certificate), the gateway allows the application to focus on transaction generation, submission and response. It coordinates the transaction proposal, ordering and notification processing between the different network components. 14. Since we have created an identity for MagnetoCorp, let's also create Balaji from DigiBank. To do so, we will need a third command line tab. We can add another command line tab by clicking on File - New Tab. This will create a new tab in the terminal from the exact folder directory we were in from our second command line tab. This third tab will act as DigiBank. 15. We now need to switch to a new directory, specifically the application folder of DigiBank. NOTE: scroll over to see the entire command below: tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/application$ cd ../../digibank/application/ tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/digibank/application$ 16. Within VSCode, navigate to the application folder of DigiBank : fabric-samples-cp - commercial-paper - organization - digibank - application 17. Similarly, you will see PUT_PRIVATE_KEY_HERE in the addtoWallet.js file within the application folder. On line 25, you should see what is below : const key = fs.readFileSync(path.join(credPath, '/msp/keystore/ PUT_PRIVATE_KEY_HERE ')).toString(); 18. To put in an actual private keys's file name, you can enter the command below in your terminal application to find the key's file name. NOTE: scroll over to see the entire key below: tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/digibank/application$ ls -l /home/tecadmin/.fabric-vscode/runtime/crypto-config/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp/keystore/ -rw-------@ 1 tecadmin tecadmin 241 Jun 11 08:57 4fd5a19cad827af71cf356d629f95c41f77e27db09d268a3c72aabdaead43737_sk 19. Now, copy your private key's file name, 4fd5a19cad827af71cf356d629f95c41f77e27db09d268a3c72aabdaead43737_sk in our example- yours will differ- and paste in the field asking for your private key. For example, line 25 looks like this now. NOTE: scroll over to see the entire file name below: const key = fs.readFileSync(path.join(credPath, '/msp/keystore/4fd5a19cad827af71cf356d629f95c41f77e27db09d268a3c72aabdaead43737_sk')).toString(); NOTE: It is of the upmost importance that you are doing this from the digibank/application folder and you save this file. 20. Now we can install some dependencies that are required to create our identity. To do this, enter the command that is below. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/digibank/application$ npm install . . # A bunch of output, with some of the output repeating . node-pre-gyp WARN Using request for node-pre-gyp https download [grpc] Success: \"/home/tecadmin/Desktop/fabric-samples/commercial-paper/organization/magnetocorp/application/node_modules/grpc/src/node/extension_binary/node-v57-darwin-x64-unknown/grpc_node.node\" is installed via remote npm notice created a lockfile as package-lock.json. You should commit this file. npm WARN nodejs@1.0.0 No description npm WARN nodejs@1.0.0 No repository field. added 318 packages in 36.994s 21. Since we are in our command line, let's issue the following command that will create Balaji. NOTE: scroll over to see the entire command below: tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/digibank/application$ node addToWallet.js done 22. We will know it worked if we can execute the following command successfully. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/digibank/application$ ls -l ../identity/user/balaji/wallet/ total 0 drwxr-xr-x 5 tecadmin tecadmin 160 Jun 11 12:53 Admin@org1.example.com tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/digibank/application$ ls -l ../identity/user/balaji/wallet/Admin@org1.example.com/ total 24 -rw-r--r-- 1 tecadmin tecadmin 1037 Jun 11 12:53 User1@org1.example.com -rw-r--r-- 1 tecadmin tecadmin 246 Jun 11 12:53 4fd5a19cad827af71cf356d629f95c41f77e27db09d268a3c72aabdaead43737-priv -rw-r--r-- 1 tecadmin tecadmin 182 Jun 11 12:53 4fd5a19cad827af71cf356d629f95c41f77e27db09d268a3c72aabdaead43737-pub Based on the picture below, we now have 2 participants in this network. Obviously, this is MagnetoCorp (Isabella) and DigiBank (Balaji). Both participants are allowed to interact with the commercial paper blockchain network through their application. 23. Since we have issued a paper from Isabella, let's go ahead and submit a couple of transactions from Balaji and DigiBank. Go ahead and get the latest status of our paper by entering the command below. NOTE: scroll over to see the entire command below: tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/digibank/application$ node getPaper.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper getPaper transaction. Process getPaper transaction response. +--------- Paper Retrieved ---------+ | Paper number: \"00001\" | Paper is owned by: \"MagnetoCorp\" | Paper is currently: \"ISSUED\" | Paper face value: \"5000000\" | Paper is issued by: \"MagnetoCorp\" | Paper issue on: \"2020-05-31\" | Paper matures on: \"2020-11-30\" +-----------------------------------+ Transaction complete. Disconnect from Fabric gateway. getPaper program complete. 24. Now that we know the current status of our 00001 paper, let's go ahead and buy and redeem the paper by entering the command below. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/digibank/application$ node buy.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper buy transaction. 2019-02-28T19:52:17.372Z - info: [TransactionEventHandler]: _strategySuccess: strategy success for transaction \"871e7743c58e406575d4e553330faae3711c0a65a2f677b6e6d398650069d81a\" Process buy transaction response. MagnetoCorp commercial paper : 00001 successfully purchased by DigiBank Transaction complete. Disconnect from Fabric gateway. Buy program complete. 25. We can finish the cycle of paper 00001 by doing a redeem transaction. The command is below. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/digibank/application$ node redeem.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper redeem transaction. 2019-02-28T19:52:46.452Z - info: [TransactionEventHandler]: _strategySuccess: strategy success for transaction \"c26ecbf1077d99a5ea025c339ffabd88eb22cf4e6ac5ff8d9b570cd6c38eb531\" Process redeem transaction response. MagnetoCorp commercial paper : 00001 successfully redeemed with MagnetoCorp Transaction complete. Disconnect from Fabric gateway. Redeem program complete 26. To confirm that we actually redeemed the paper, you can do a getPaper transaction to see that it was, indeed, redeemed. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/digibank/application$ node getPaper.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper getPaper transaction. Process getPaper transaction response. +--------- Paper Retrieved ---------+ | Paper number: \"00001\" | Paper is owned by: \"MagnetoCorp\" | Paper is currently: \"REDEEMED\" | Paper face value: \"5000000\" | Paper is issued by: \"MagnetoCorp\" | Paper issue on: \"2020-05-31\" | Paper matures on: \"2020-11-30\" +-----------------------------------+ Transaction complete. Disconnect from Fabric gateway. getPaper program complete Now, we have run through the full lifecycle of one paper through the command line interface (CLI). In the following sections we will use a mixture of the CLI, the VSCode user interface, and a loopback API service application. Section 5: Create Fabric Gateways and Submit Transactions In the previous section, we created two identities - Isabella and Balaji - and then completed a full lifecycle of one paper. Let's create a fabric gateway for Isabella and Balaji and then submit some more transactions. 1. Within VSCode, go to the IBM Blockchain Platform Extension. One of the sections you'll see is called Fabric Gateways . If you click on the gear icon in the bottom left, select Command Palette.. . You'll be given a prompt and you can enter this command below : IBM Blockchain Platform: Add Gateway 2. For our first Gateway, let's create MagnetoCorp. So when it prompts you for: Enter a name for the gateway enter the following below : MagnetoCorp 3. Then it will prompt you for a path to the connection profile. Click on browse and it will open a file window. Navigate to the path below and select networkConnection.yaml . NOTE: scroll over to see the entire file path below : Desktop - fabric-samples-cp - commercial-paper - organization - magnetocorp - gateway - networkConnection.yaml . 4. Then it will place that new gateway in the Fabric Gateway section within the IBM Blockchain Platform Extension. Now that we have a gateway, we need to create an identity to use this gateway. To do this, hover your cursor over the Fabric Wallets section of the extension. There you'll see a + icon. Click on that + icon to add a wallet. 5. Then it will prompt you: Choose a method to add a wallet and for that select Specify an existing file system wallet . We are selecting this because we already have added Isabella as an identity and she has a wallet folder. 6. Then it will prompt you: Enter file path to a wallet directory and then select Browse . It will then pop-up a file window. From there, you can navigate to the following path below. NOTE: scroll over to see the entire file path below: Desktop - fabric-samples-cp - commercial-paper - organization - magnetocorp - identity - user - isabella - wallet . Once you have selected wallet , click on select to choose this option. Then it will add a wallet, called wallet , to our Fabric Wallets section of the extension. 7. Once you see the wallet called wallet in the Fabric Wallet section, go ahead and right click on wallet . How many times can you say wallet in a sentence. From there, select Edit Wallet and it will open a settings.json file with your wallet name and wallet path highlighted. Go ahead and only change the wallet name to MagnetoCorpWallet . Look below to see the example: \"name\": \"wallet\", \"walletPath\": \"/home/tecadmin/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/identity/user/isabella/wallet\" ---- CHANGE TO ----- \"name\": \"MagnetoCorpWallet\", \"walletPath\": \"/home/tecadmin/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/identity/user/isabella/wallet\" 8. Once you have made that change, go ahead and save this file by doing a File - Save or Control + S . Also - leave this file open as we will want to change the name for DigiBank once we create their wallet. 9. Speaking of DigiBank, we now need to do the same process for them. So click on the gear icon in the bottom left, select Command Palette.. . You'll be given a prompt and you can enter this command below: IBM Blockchain Platform: Add Gateway 10. For our second Gateway, let's create DigiBank. So when it prompts you for: Enter a name for the gateway enter the following below: DigiBank 11. Then it will prompt you for a path to the connection profile. Click on browse and it will open a file window. Navigate to the path below and select networkConnection.yaml . NOTE: scroll over to see the entire file path below: Desktop - fabric-samples-cp - commercial-paper - organization - digibank - gateway - networkConnection.yaml . 12. Then it will place that new gateway in the Fabric Gateway section within the IBM Blockchain Platform Extension. Now that we have a gateway, we need to create an identity to use this gateway. To do this, hover your cursor over the Fabric Wallets section of the extension. There you'll see a + icon. Click on that + icon to add a wallet. 13. Then it will prompt you: Choose a method to add a wallet and for that select Specify an existing file system wallet . We are selecting this because we already have added Isabella as an identity and she has a wallet folder. 14. Then it will prompt you: Enter file path to a wallet directory and then select Browse . It will then pop-up a file window. From there, you can navigate to the following path below. NOTE: scroll over to see the entire file path below: Desktop - fabric-samples-cp - commercial-paper - organization - digibank - identity - user - balaji - wallet . Once you have selected wallet , click on select to choose this option. Then it will add a wallet, called wallet , to our Fabric Wallets section of the extension. 15. Once you see the wallet called wallet in the Fabric Wallet section, go ahead and right click on wallet . From there, select Edit Wallet and it will open a settings.json file with your wallet name and wallet path highlighted. Go ahead and only change the wallet name to DigiBankWallet . Look below to see the example: \"name\": \"wallet\", \"walletPath\": \"/home/tecadmin/Desktop/fabric-samples-cp/commercial-paper/organization/digibank/identity/user/balaji/wallet\" ---- CHANGE TO ----- \"name\": \"DigiBankWallet\", \"walletPath\": \"/home/tecadmin/Desktop/fabric-samples-cp/commercial-paper/organization/digibank/identity/user/balaji/wallet\" 16. Once you have made that change, go ahead and save this file by doing a File - Save or Control + S . Now within your Fabric Wallets section, you should have MagnetCorpWallet and DigiBankWallet as our two custom wallets. 17. Now that we have two wallets, we can associate our wallets to our two gateways. To do this right click on MagnetoCorp within the Fabric Gateways section. Then select Associate A Wallet . Then it will prompt you for which wallet to associate with this gateway. You will want to select MagnetoCorpWallet . What this does is when you connect with a specific gateway, it will automatically use that wallet you associated it with. For example, whenever you click on MagnetoCorp within the Fabric Gateway section, it will automatically use the MagnetoCorpWallet wallet without prompting you. 18. Do the same thing for DigiBank. Right click on DigiBank within the Fabric Gateways section. Then select Associate A Wallet . Then it will prompt you for which wallet to associate with this gateway. You will want to select DigiBankWallet . 19. To confirm that we have done this successfully, you can click on both gateways. You'll see the identities it is using once you connect to a specific gateway. To disconnect from a gateway, there is a door in the Fabric Gateways section in which you can click on to leave. 20. Now that we have our gateways figured out, let's do another lifecycle of a commercial paper. To do this, we need to do an issue transaction. First click on the MagnetoCorp gateway and untoggle till you see the transactions within the papercontract@0 . From there, right click on the issue transaction and select Submit Transaction . Within the brackets, place the text below: \"MagnetoCorp\", \"00002\", \"2020-05-31\", \"2020-11-30\", \"5000000\" You can hit enter again to bypass the next prompt asking for transient data. That will execute the transaction and issue paper 00002 21. To make sure we are all operating on the same paper number, we need to change a few files. I have broken down the files we need to change below within VSCode in the Editor perspective. From digibank/application folder, within the getPaper.js file on line 68 : const getPaperResponse = await contract.evaluateTransaction('getPaper', 'MagnetoCorp', '00001'); ---- CHANGE TO ---- const getPaperResponse = await contract.evaluateTransaction('getPaper', 'MagnetoCorp', '00002'); Make sure you save this file. From `digibank/application folder, within the redeem.js file on line 67 : const redeemResponse = await contract.submitTransaction('redeem', 'MagnetoCorp', '00001', 'DigiBank', '2020-11-30'); ---- CHANGE TO ---- const redeemResponse = await contract.submitTransaction('redeem', 'MagnetoCorp', '00002', 'DigiBank', '2020-11-30'); Make sure you save this file. 22. Now we can execute more transactions. First, jump back to the CLI and do a getPaper.js transaction. Below you will see what the command is to execute the transaction. NOTE: scroll over to see the entire command below: tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/digibank/application$ node getPaper.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper getPaper transaction. Process getPaper transaction response. +--------- Paper Retrieved ---------+ | Paper number: \"00002\" | Paper is owned by: \"MagnetoCorp\" | Paper is currently: \"ISSUED\" | Paper face value: \"5000000\" | Paper is issued by: \"MagnetoCorp\" | Paper issue on: \"2020-05-31\" | Paper matures on: \"2020-11-30\" +-----------------------------------+ Transaction complete. Disconnect from Fabric gateway. getPaper program complete. 23. Within VSCode and the IBM Blockchain Platform, we can buy the same paper. To do this, leave the MagnetoCorp gateway, and then click on the DigiBank gateway. 24. Now, untoggle till you see the buy transaction within the papercontract@0 smart contract. From there, right click on the buy transaction and select Submit Transaction . Once it gives you a prompt, enter the text below between the brackets: \"MagnetoCorp\",\"00002\",\"MagnetoCorp\",\"DigiBank\",\"4900000\",\"2019-07-31\" Then hit enter to go to the next prompt. Hit enter once again to bypass the transient data prompt. Then that will execute the buy transaction. 25. To confirm that the transaction worked (other than the log messages in the output window), we can do a getPaper transaction from the CLI again. NOTE: scroll over to see the entire command below: tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/digibank/application$ node getPaper.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper getPaper transaction. Process getPaper transaction response. +--------- Paper Retrieved ---------+ | Paper number: \"00002\" | Paper is owned by: \"DigiBank\" | Paper is currently: \"TRADING\" | Paper face value: \"5000000\" | Paper is issued by: \"MagnetoCorp\" | Paper issue on: \"2020-05-31\" | Paper matures on: \"2020-11-30\" +-----------------------------------+ Transaction complete. Disconnect from Fabric gateway. getPaper program complete. 26. From the same CLI, we can do a redeem.js transaction. NOTE: scroll over to see the entire command below: tecadmin@ubuntubase:~/Desktop/fabric-samples/commercial-paper/organization/digibank/application$ node redeem.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper redeem transaction. 2019-02-28T19:52:46.452Z - info: [TransactionEventHandler]: _strategySuccess: strategy success for transaction \"c26ecbf1077d99a5ea025c339ffabd88eb22cf4e6ac5ff8d9b570cd6c38eb531\" Process redeem transaction response. MagnetoCorp commercial paper : 00002 successfully redeemed with MagnetoCorp Transaction complete. Disconnect from Fabric gateway. Redeem program complete. 27. Again, we can confirm that this was recorded by doing another getPaper.js transaction. NOTE: scroll over to see the entire command below: tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/digibank/application$ node getPaper.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper getPaper transaction. Process getPaper transaction response. +--------- Paper Retrieved ---------+ | Paper number: \"00002\" | Paper is owned by: \"MagnetoCorp\" | Paper is currently: \"REDEEMED\" | Paper face value: \"5000000\" | Paper is issued by: \"MagnetoCorp\" | Paper issue on: \"2020-05-31\" | Paper matures on: \"2020-11-30\" +-----------------------------------+ Transaction complete. Disconnect from Fabric gateway. getPaper program complete. Section 6: Lab Clean-Up This lab has run its course, but now it is time to clean up. Don't worry, this is a very short section! 1. Entering the following commands to stop and remove our docker containers. Then we can remove the images as well. Look at the following commands below :: tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/digibank/application$ docker stop $(docker ps -a -q) * * * Docker container IDs * * tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/digibank/application$ docker rm $(docker ps -a -q) * * * Docker container IDs * * 2. From within the IBM Blockchain Platform Extension in VSCode, find the Local Fabric Ops section and hover your cursor in that section. Within that section, click on the three dots ( ... ) in the top right. Then select Teardown Fabric Runtime . This will clear the local Fabric cleanly. 3. Once that has ran its course, click on the three dots ( ... ) and select Start Fabric Runtime . This will start up a new local Fabric that we will use in the next part of the lab. That's it!","title":"Vscode part2"},{"location":"vscode-part2/#section-1-commercial-paper-overview","text":"This tutorial works with a sample commercial paper trading network called PaperNet . Commercial paper is a type of unsecured lending in the form of a \"promissory note\". The papers are normally issued by large corporations to raise funds to meet short-term financial obligations at a fixed rate of interest. Once issued at a fixed price, for a fixed term, another company or bank will purchase them at a discount to the face value and when the term is up, they will be redeemed for their face value. As an example, if a paper was issued at a face value of 10M USD for a 6-month term at 2% interest then it could be bought for 9.8M USD (10M less 2%) by another company or bank who is willing to bear the risk that the issuer will not default. Once the term is up, then the paper could be redeemed or sold back to the issuer for its full face value of 10M USD. Between buying and redemption, the paper can be bought or sold between different parties on a commercial paper market. These three key steps of issue, buy and redeem are the main transactions in a simplified commercial paper marketplace, which we will mirror in our lab. We will see a commercial paper issued by a company called MagnetoCorp and, once issued on the commercial paper blockchain network, another company called DigiBank will first buy the paper and then redeem it. You'll act as a developer, end user, and administrator, within different organizations, performing various steps designed to help you understand what it's like to collaborate as two different organizations working independently, but according to mutually agreed rules in a Hyperledger Fabric network. Below is an image of our PaperNet network. For our lab, we will create Isabella who is with MagnetoCorp. Additionally, we will create Balaji who is with DigiBank. Isabella will issue a paper for the network. The paper will have an ID number, when it was issued, the maturity date, and the face value in USD. Balaji, from DigiBank, will then buy the paper and then eventually redeem it. Below is the full breakdown of Part 2 of this lab: Setting the Stage : Based off of Part 1, we have started a blockchain network, created a smart contract, created and run tests and then submitted transactions. For Part 2, we need to create a couple more docker containers that will set us up for success for the rest of the lab. One of these containers will just monitor the docker network we are operating in. If you have no idea what a docker network is, I will explain later on. The other container contains Hyperledger Fabric tools and is named cliMagnetoCorp, as MagnetoCorp will use the Hyperledger Fabric command line interface (cli) within this container. Install and Instantiate Smart Contract : Now that we have those new docker containers up and running, we will enter our cliMagnetoCorp container and install and instantiate our smart contract. Since we are connected to the same running local Hyperledger Fabric network, we will see the smart contract show up in VSCode. Issue Identities and Submit Transactions : In this section, we will issue two identities. One is an end-user named Isabella with MagnetoCorp. She will invoke a transaction that will issue a paper. Then we will issue an identity for DigiBank named Balaji. Balaji will act as the adminstrator for DigiBank and will buy and redeem the paper that Isabella issued. Balaji is important in this lab, as we will add a Fabric Gateway connection to connect to his perspective of the network. Create Fabric Gateways and Submit Transactions : In this section we will create gateways that allows VSCode to connect to a running Hyperledger Fabric or IBM Blockchain Platform instance through a connection profile. In this lab, we will connect to our local_fabric network, which is also the Papernet network. We will create two gateways and associate our identities to these gateways. That way we can ensure the appropriate people are making the transactions they should. Lab Cleanup : This is the most bittersweet part of the entire lab. It means that this lab portion is over and we have to clean up. If you have kids (I don't), I'd imagine their faces are sad and full of despair when you (the guardian) tell them to clean up their mess. I'd also like to imagine your face is making a similar expression when we get to this lab. It's okay, more fun is going to be had soon - very soon! Loopback APIs : We have proven that we can submit transactions through the command line interface (CLI) and the VSCode user interface. In this section, we will deploy two loopback API applications (for each of our organizations) and submit transactions through loopback. We will also include some transactions through the CLI and VSCode.","title":"Section 1: Commercial Paper Overview"},{"location":"vscode-part2/#section-2-setting-the-stage","text":"1. Navigate to your Desktop and then do a git clone of a repository to gather all the things you need to run through this tutorial : tecadmin@ubuntubase:~$ cd Desktop/ tecadmin@ubuntubase:~/Desktop$ ls -l total 0 drwxr-xr-x 16 tecadmin tecadmin 512 Jun 11 12:34 Kale tecadmin@ubuntubase:~/Desktop$ git clone https://github.com/austingrice/fabric-samples-cp.git Cloning into 'fabric-samples-cp'... remote: Enumerating objects: 85, done. remote: Counting objects: 100% (85/85), done. remote: Compressing objects: 100% (71/71), done. remote: Total 2658 (delta 26), reused 71 (delta 13), pack-reused 2573 Receiving objects: 100% (2658/2658), 927.08 KiB | 0 bytes/s, done. Resolving deltas: 100% (1293/1293), done. tecadmin@ubuntubase:~/Desktop$ ls -l total 0 drwxr-xr-x 22 tecadmin tecadmin 704 Jun 11 12:41 fabric-samples-cp drwxr-xr-x 16 tecadmin tecadmin 512 Jun 11 12:34 Kale 2. Then, do a docker network list to see all the running Docker networks : tecadmin@ubuntubase:~/Desktop$ docker network list NETWORK ID NAME DRIVER SCOPE ad2e1a3e2fc2 bridge bridge local 35837170ae5b fabricvscodelocalfabric_basic bridge local c5e0411b0d34 host host local 42ffa501f2f9 none null local 3. The network we are operating out of is the fabricvscodelocalfabric_basic network. You can see that by entering the following command below : tecadmin@ubuntubase:~/Desktop$ docker network inspect fabricvscodelocalfabric_basic That command will show you all the containers running in this network. In a nutshell, docker networks are natural ways to isolate containers from other containers or other networks. Having containers within a network allows them to communicate with other containers in the same network. 4. Within VSCode, go to the Explorer perspective and click on File and select Add Folder to Workplace.. . This will allow us to work from an Untitled Workplace, but have the fabric-samples-cp folder in there. 5. Within VSCode, navigate to the folder below within MagnetoCorp : fabric-samples-cp - commercial-paper - organizations - magnetocorp - configuration - cli You will see two files in there. One file is monitordocker.sh that will produce log messages across the network that you specify it to look at. If you click on this file to open it up, you'll see the file is called to look at the fabricvscodelocalfabric_basic Docker network. The other file is docker-compose.yml , which pulls down a fabric-tools container that is connected to our local network. When we spun up our local_fabric network, back in Part 1, it placed all the cryptographic material in our /home/tecadmin/.fabric-vscode/runtime/crypto-config/ directory. It is then taking all the crypto material and placing it in our fabric-tools container. This will make more sense once we install and instantiate the smart contract from this container instead of VSCode. 6. Now from the terminal navigate to the cli directory within MagnetoCorp. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop$ cd fabric-samples-cp/commercial-paper/organization/magnetocorp/configuration/cli/ tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/configuration/cli/$ ls -l total 16 -rw-r--r-- 1 tecadmin tecadmin 1168 Jun 11 12:41 docker-compose.yml -rwxr-xr-x 1 tecadmin tecadmin 751 Jun 11 12:44 monitordocker.sh 7. From here, we can actually start the monitordocker.sh script by entering the command below. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/configuration/cli/$ ./monitordocker.sh fabricvscodelocalfabric_basic # 8. Since this terminal is occupied with log messages, let's open another terminal tab. We can open a new tab by clicking on File and then selecting New Tab 9. When you opened a new tab, you should have been taken to the same file path that you were in on the previous tab. Now that we have a command line ready, go ahead and enter the command below that will create a cliMagnetoCorp container for our docker network to use. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/configuration/cli/$ docker-compose -f docker-compose.yml up -d cliMagnetoCorp . . # We'll see docker messages . Status: Downloaded newer image for hyperledger/fabric-tools:latest Creating cliMagnetoCorp ... Creating cliMagnetoCorp ... done When we first install the smart contract, we will go through the cliMagnetoCorp container, which is our Administrator Console. This will allow us to use Fabric peer commands. 10. We can also do a docker ps -a command to see all of our docker containers. We should see two new containers - cliMagnetoCorp and logspout from steps 9 and 10. 11. Equally, we could do docker network inspect fabricvscodelocalfabric_basic to see all of our containers together in one network - and no, not in a blockchain network. They are, however, the components that make up our local blockchain network :-)","title":"Section 2: Setting the Stage"},{"location":"vscode-part2/#section-3-install-and-instantiate-commercial-paper-smart-contract","text":"Before we actually install the commercial paper smart contract, let's actually open the file to see what the smart contract is trying to do. 1. From your explorer perspective within VSCode, navigate from the fabric-samples-cp folder to the contract folder of MagnetoCorp : fabric-samples-cp - commercial-paper - organization - magnetocorp - contract Within the lib folder, you'll see 3 javascript (.js) files in there. Click on the papercontract.js file, which will open it within VSCode Let's dissect our papercontract.js file as it is our smart contract. We will only go over the issue transaction, but the other transactions follow pretty closely to this one Below, these 2 lines of code bring into scope two key Hyperledger Fabric classes that will be used extensively by the smart contract -- Contract and Context : // Fabric smart contract classes const { Contract, Context } = require('fabric-contract-api'); Below, we define the smart contract class CommercialPaperContract based on the built-in Fabric Contract class. The methods which implement the key transactions to issue, buy and redeem commercial paper are defined within this class : /** * Define commercial paper smart contract by extending Fabric Contract class * */ class CommercialPaperContract extends Contract { Below, this method defines the commercial paper issue transaction for the commercial paper blockchain network. The parameters that are passed to this method will be used to create the new commercial paper. Locate and examine the buy and redeem transactions within the smart contract : /** * Issue commercial paper * * @param {Context} ctx the transaction context * @param {String} issuer commercial paper issuer * @param {Integer} paperNumber paper number for this issuer * @param {String} issueDateTime paper issue date * @param {String} maturityDateTime paper maturity date * @param {Integer} faceValue face value of paper */ async issue(ctx, issuer, paperNumber, issueDateTime, maturityDateTime, faceValue) { Within the issue transaction, this statement creates a new commercial paper in memory using the CommercialPaper class with the supplied transaction inputs. Examine the buy, get paper and redeem transactions to see how they similarly use this class : // create an instance of the paper let paper = CommercialPaper.createInstance(issuer, paperNumber, issueDateTime, maturityDateTime, faceValue); Below, this statement adds the new commercial paper to the ledger using ctx.paperList , an instance of a PaperList class that was created when the smart contract context CommercialPaperContext was initialized. Again, examine the buy and redeem methods to see how they use this class : // Add the paper to the list of all similar commercial papers in the ledger world state await ctx.paperList.addPaper(paper); Below you will find that this statement returns a binary buffer as response from the issue transaction for processing by the caller of the smart contract : // Must return a serialized paper to caller of smart contract return paper.toBuffer(); 2. Now that we have an understanding of the smart contract, let's actually install it on our peer through our terminal application. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/configuration/cli/$ docker exec cliMagnetoCorp peer chaincode install -n papercontract -v 0 -p /opt/gopath/src/github.com/contract -l node 2019-06-11 17:48:23.721 UTC [chaincodeCmd] checkChaincodeCmdParams - INFO 001 Using default escc 2019-06-11 17:48:23.721 UTC [chaincodeCmd] checkChaincodeCmdParams - INFO 002 Using default vscc 2019-06-11 17:48:23.862 UTC [chaincodeCmd] install - INFO 003 Installed remotely response: status:200 payload:\"OK\" A message saying 200 is a great sign to see. If you notice, we are not in the contract folder of our command line interface. Instead, we are entering the cliMagnetoCorp docker container with docker exec cliMagnetoCorp and navigating to the /opt/gopath/src/github.com/contract file path within our container to grab the files we need to install the smart contract. The -n papercontract flag names our smart contract papercontract. The -v 0 gives our smart contract a version of 0. Finally, the -l node tells us that the language of our smart contract is nodejs. The picture below goes into detail, visually, as to how we are actually installing a copy of the commercial paper smart contract on our peer. 3. Since our network is connected to our VSCode instance, you can refresh the Local Fabric Ops panel in VSCode under the IBM Blockchain Extension . The refresh button ( unclosed circle icon ) is revealed when you hover your mouse over the Local Fabric Ops panel 4. Since we have installed the smart contract, we should actually make it active by instantiating it. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/configuration/cli/$ docker exec cliMagnetoCorp peer chaincode instantiate -n papercontract -v 0 -l node -c '{\"Args\":[\"org.papernet.commercialpaper:instantiate\"]}' -C mychannel -P \"\" 2019-06-11 17:50:34.673 UTC [chaincodeCmd] InitCmdFactory - INFO 001 Retrieved channel (mychannel) orderer endpoint: orderer.example.com:17050 2019-06-11 17:50:34.675 UTC [chaincodeCmd] checkChaincodeCmdParams - INFO 002 Using default escc 2019-06-11 17:50:34.675 UTC [chaincodeCmd] checkChaincodeCmdParams - INFO 003 Using default vscc tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/configuration/cli/$ As you can see in the image below, we are instantiating a copy of the commercial paper smart contract on our MagnetoCorp peer. Similar to the installation of the smart contract, the instantiation goes into the cliMagnetoCorp container. After successfully instantiating the smart contract, there will be a commercial paper smart contract docker image and container. 5. You will know our instantiate command worked when we get our command prompt back without any error messages. You can really verify it worked by going back to the VSCode and refreshing the Local Fabric Ops panel and you should see it under the instantiate section.","title":"Section 3: Install and Instantiate Commercial Paper Smart Contract"},{"location":"vscode-part2/#section-4-create-identities-and-submit-transactions","text":"Now that we have a ready-to-use smart contract, let's issue some identities so that those identities can invoke and query transactions. 1. You should be within the cli folder of the MagnetoCorp folder. You can confirm this by issuing the command below. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/configuration/cli/$ pwd /home/tecadmin/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/configuration/cli tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/configuration/cli/$ 2. This is a good sign. Issue the following command below to get to the application folder within MagnetoCorp. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/configuration/cli/$ cd ../../application/ tecadmin@ubuntubase:~/Desktop/fabric-samples/commercial-paper/organization/magnetocorp/application$ 3. Within VSCode, navigate to the same folder : fabric-samples-cp - commercial-paper - organization - magnetocorp - appplication 4. In that folder, you should see a file called addtoWallet.js . Go ahead and click on it to open it up. 5. On line 25, you should see what is below : const key = fs.readFileSync(path.join(credPath, '/msp/keystore/ PUT_PRIVATE_KEY_HERE ')).toString(); 6. To put in the file name of your actual private key, you can enter the command below in your terminal application to find the key's file name. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/application$ ls -l /home/tecadmin/.fabric-vscode/runtime/crypto-config/peerOrganizations/org1.example.com/users/User1@org1.example.com/msp/keystore/ -rw-------@ 1 tecadmin tecadmin 241 Jun 11 08:57 e7a117b799890646fe1d6e688d9c979845a411830400b673e2fe7dc01f91f9b8_sk 7. Now, copy your private key's file name, e7a117b799890646fe1d6e688d9c979845a411830400b673e2fe7dc01f91f9b8_sk in this example- but your name will differ- and paste it in the field asking for your private key. For example, line 25 looks like this now. NOTE: scroll over to see the entire key file name below: const key = fs.readFileSync(path.join(credPath, '/msp/keystore/e7a117b799890646fe1d6e688d9c979845a411830400b673e2fe7dc01f91f9b8_sk')).toString(); NOTE: It is of the upmost importance that you are doing this from the magnetocorp/application folder and you save this file. We will do the DigiBank folder here in a second. 8. Go ahead and save this file by either doing File - Save or Control + s . 9. Back in your terminal application, you can enter the command below to install some dependencies. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/application$ npm install . . # A bunch of output, with some of the output repeating . node-pre-gyp WARN Using request for node-pre-gyp https download [grpc] Success: \"/home/tecadmin/Desktop/fabric-samples/commercial-paper/organization/magnetocorp/application/node_modules/grpc/src/node/extension_binary/node-v57-darwin-x64-unknown/grpc_node.node\" is installed via remote npm notice created a lockfile as package-lock.json. You should commit this file. npm WARN nodejs@1.0.0 No description npm WARN nodejs@1.0.0 No repository field. added 318 packages in 36.994s 10. Since we are in our command line, let's issue the following command that will create Isabella. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/application$ node addToWallet.js done 11. We will know it worked if we can execute the following command successfully. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/application$ ls -l ../identity/user/isabella/wallet/ total 0 drwxr-xr-x 5 tecadmin tecadmin 160 Jun 11 12:53 User1@org1.example.com tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/application$ ls -l ../identity/user/isabella/wallet/User1@org1.example.com/ total 24 -rw-r--r-- 1 tecadmin tecadmin 1037 Jun 11 12:53 User1@org1.example.com -rw-r--r-- 1 tecadmin tecadmin 246 Jun 11 12:53 e7a117b799890646fe1d6e688d9c979845a411830400b673e2fe7dc01f91f9b8-priv -rw-r--r-- 1 tecadmin tecadmin 182 Jun 11 12:53 e7a117b799890646fe1d6e688d9c979845a411830400b673e2fe7dc01f91f9b8-pub Keys are vital to understanding how transactions and identity work within a blockchain network. Below is a breakdown of the keys and certificate used in this example: a private key e7a117b799...-priv used to sign transactions on Isabella's behalf, but not distributed outside of her immediate control a public key e7a117b799...-pub which is cryptographically linked to Isabella's private key. This public key is contained within Isabella's X.509 certificate a certificate User1@org.example.com which contains Isabella's public key and other X.509 attributes added by the Certificate Authority at certificate creation. This certificate is distributed to the network so that different actors at different times can cryptographically verify information signed by Isabella's private key 12. Before we submit our first transaction, let's go over it below. You can find the code by clicking on issue.js within the magnetocorp/application folder in VSCode. Below we bring two key Hyperledger Fabric SDK classes into scope -- Wallet and Gateway . Because Isabella's X.509 certificate is in the local file system, the application uses FileSystemWallet : // Bring key classes into scope, most importantly Fabric SDK network class const { FileSystemWallet, Gateway } = require('fabric-network'); Below, this statement identifies that the application will use Isabella's wallet when it connects to the blockchain network channel. The application will select a particular identity within Isabella's wallet. (The wallet must have been loaded with Isabella's X.509 certificate -- that's what addToWallet.js does): // A wallet stores a collection of identities for use const wallet = new FileSystemWallet('../identity/user/isabella/wallet'); This line of code, below, connects to the network using the gateway identified by connectionProfile, using the identity referred to in connectionOptions. See how ../gateway/networkConnection.yaml and User1@org1.example.com are used for these values respectively: // Connect to gateway using application specified parameters await gateway.connect(connectionProfile, connectionOptions); Below in the couple lines of code, the application connects to the network channel mychannel , where the papercontract was previously instantiated. If you had a different channel name, you would have to modify this line of code: // Access commercial paper network const network = await gateway.getNetwork('mychannel'); Below, this statement gives the application addressability to the smart contract defined by the namespace org.papernet.commercialpaper within papercontract . Once an application has issued getContract , it can submit any transaction implemented within it: // Get addressability to commercial paper contract const contract = await network.getContract('papercontract', 'org.papernet.comm...'); Below, these lines of code submit a transaction to the network using the issue transaction defined within the smart contract. MagnetoCorp, 00001 are the values to be used by the issue transaction to create a new commercial paper: // issue commercial paper const issueResponse = await contract.submitTransaction('issue','MagnetoCorp', '00001', '2020-05-31', '2020-11-30','5000000'); This statement, below, processes the response from the issue transaction. The response needs to be deserialized from a buffer into paper, a CommercialPaper object which can be interpreted correctly by the application: // process response let paper = CommercialPaper.fromBuffer(issueResponse); 13. Now that we have Isabella from MagnetoCorp, let's perform the issue transaction from our terminal. NOTE: scroll over to see the entire command below: tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/application$ node issue.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper issue transaction. 2019-02-22T17:55:20.631Z - info: [TransactionEventHandler]: _strategySuccess: strategy success for transaction \"f8e124886d6cb84434cb6a996f4889145c0541199c88bab7d4d85ae41266e51e\" Process issue transaction response. MagnetoCorp commercial paper : 00001 successfully issued for value 5000000 Transaction complete. Disconnect from Fabric gateway. Issue program complete. This successfully committed a transaction to the ledger. See how it outputted a transaction hash for us. You can look at our monitoring docker terminal tab as well. As you can see in the image below, we are using the certificate belonging to Isabella to submit our paper issue transaction. Once we verify that Isabella can submit a transaction (via her certificate), the gateway allows the application to focus on transaction generation, submission and response. It coordinates the transaction proposal, ordering and notification processing between the different network components. 14. Since we have created an identity for MagnetoCorp, let's also create Balaji from DigiBank. To do so, we will need a third command line tab. We can add another command line tab by clicking on File - New Tab. This will create a new tab in the terminal from the exact folder directory we were in from our second command line tab. This third tab will act as DigiBank. 15. We now need to switch to a new directory, specifically the application folder of DigiBank. NOTE: scroll over to see the entire command below: tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/application$ cd ../../digibank/application/ tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/digibank/application$ 16. Within VSCode, navigate to the application folder of DigiBank : fabric-samples-cp - commercial-paper - organization - digibank - application 17. Similarly, you will see PUT_PRIVATE_KEY_HERE in the addtoWallet.js file within the application folder. On line 25, you should see what is below : const key = fs.readFileSync(path.join(credPath, '/msp/keystore/ PUT_PRIVATE_KEY_HERE ')).toString(); 18. To put in an actual private keys's file name, you can enter the command below in your terminal application to find the key's file name. NOTE: scroll over to see the entire key below: tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/digibank/application$ ls -l /home/tecadmin/.fabric-vscode/runtime/crypto-config/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp/keystore/ -rw-------@ 1 tecadmin tecadmin 241 Jun 11 08:57 4fd5a19cad827af71cf356d629f95c41f77e27db09d268a3c72aabdaead43737_sk 19. Now, copy your private key's file name, 4fd5a19cad827af71cf356d629f95c41f77e27db09d268a3c72aabdaead43737_sk in our example- yours will differ- and paste in the field asking for your private key. For example, line 25 looks like this now. NOTE: scroll over to see the entire file name below: const key = fs.readFileSync(path.join(credPath, '/msp/keystore/4fd5a19cad827af71cf356d629f95c41f77e27db09d268a3c72aabdaead43737_sk')).toString(); NOTE: It is of the upmost importance that you are doing this from the digibank/application folder and you save this file. 20. Now we can install some dependencies that are required to create our identity. To do this, enter the command that is below. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/digibank/application$ npm install . . # A bunch of output, with some of the output repeating . node-pre-gyp WARN Using request for node-pre-gyp https download [grpc] Success: \"/home/tecadmin/Desktop/fabric-samples/commercial-paper/organization/magnetocorp/application/node_modules/grpc/src/node/extension_binary/node-v57-darwin-x64-unknown/grpc_node.node\" is installed via remote npm notice created a lockfile as package-lock.json. You should commit this file. npm WARN nodejs@1.0.0 No description npm WARN nodejs@1.0.0 No repository field. added 318 packages in 36.994s 21. Since we are in our command line, let's issue the following command that will create Balaji. NOTE: scroll over to see the entire command below: tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/digibank/application$ node addToWallet.js done 22. We will know it worked if we can execute the following command successfully. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/digibank/application$ ls -l ../identity/user/balaji/wallet/ total 0 drwxr-xr-x 5 tecadmin tecadmin 160 Jun 11 12:53 Admin@org1.example.com tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/digibank/application$ ls -l ../identity/user/balaji/wallet/Admin@org1.example.com/ total 24 -rw-r--r-- 1 tecadmin tecadmin 1037 Jun 11 12:53 User1@org1.example.com -rw-r--r-- 1 tecadmin tecadmin 246 Jun 11 12:53 4fd5a19cad827af71cf356d629f95c41f77e27db09d268a3c72aabdaead43737-priv -rw-r--r-- 1 tecadmin tecadmin 182 Jun 11 12:53 4fd5a19cad827af71cf356d629f95c41f77e27db09d268a3c72aabdaead43737-pub Based on the picture below, we now have 2 participants in this network. Obviously, this is MagnetoCorp (Isabella) and DigiBank (Balaji). Both participants are allowed to interact with the commercial paper blockchain network through their application. 23. Since we have issued a paper from Isabella, let's go ahead and submit a couple of transactions from Balaji and DigiBank. Go ahead and get the latest status of our paper by entering the command below. NOTE: scroll over to see the entire command below: tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/digibank/application$ node getPaper.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper getPaper transaction. Process getPaper transaction response. +--------- Paper Retrieved ---------+ | Paper number: \"00001\" | Paper is owned by: \"MagnetoCorp\" | Paper is currently: \"ISSUED\" | Paper face value: \"5000000\" | Paper is issued by: \"MagnetoCorp\" | Paper issue on: \"2020-05-31\" | Paper matures on: \"2020-11-30\" +-----------------------------------+ Transaction complete. Disconnect from Fabric gateway. getPaper program complete. 24. Now that we know the current status of our 00001 paper, let's go ahead and buy and redeem the paper by entering the command below. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/digibank/application$ node buy.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper buy transaction. 2019-02-28T19:52:17.372Z - info: [TransactionEventHandler]: _strategySuccess: strategy success for transaction \"871e7743c58e406575d4e553330faae3711c0a65a2f677b6e6d398650069d81a\" Process buy transaction response. MagnetoCorp commercial paper : 00001 successfully purchased by DigiBank Transaction complete. Disconnect from Fabric gateway. Buy program complete. 25. We can finish the cycle of paper 00001 by doing a redeem transaction. The command is below. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/digibank/application$ node redeem.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper redeem transaction. 2019-02-28T19:52:46.452Z - info: [TransactionEventHandler]: _strategySuccess: strategy success for transaction \"c26ecbf1077d99a5ea025c339ffabd88eb22cf4e6ac5ff8d9b570cd6c38eb531\" Process redeem transaction response. MagnetoCorp commercial paper : 00001 successfully redeemed with MagnetoCorp Transaction complete. Disconnect from Fabric gateway. Redeem program complete 26. To confirm that we actually redeemed the paper, you can do a getPaper transaction to see that it was, indeed, redeemed. NOTE: scroll over to see the entire command below : tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/digibank/application$ node getPaper.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper getPaper transaction. Process getPaper transaction response. +--------- Paper Retrieved ---------+ | Paper number: \"00001\" | Paper is owned by: \"MagnetoCorp\" | Paper is currently: \"REDEEMED\" | Paper face value: \"5000000\" | Paper is issued by: \"MagnetoCorp\" | Paper issue on: \"2020-05-31\" | Paper matures on: \"2020-11-30\" +-----------------------------------+ Transaction complete. Disconnect from Fabric gateway. getPaper program complete Now, we have run through the full lifecycle of one paper through the command line interface (CLI). In the following sections we will use a mixture of the CLI, the VSCode user interface, and a loopback API service application.","title":"Section 4: Create Identities and Submit Transactions"},{"location":"vscode-part2/#section-5-create-fabric-gateways-and-submit-transactions","text":"In the previous section, we created two identities - Isabella and Balaji - and then completed a full lifecycle of one paper. Let's create a fabric gateway for Isabella and Balaji and then submit some more transactions. 1. Within VSCode, go to the IBM Blockchain Platform Extension. One of the sections you'll see is called Fabric Gateways . If you click on the gear icon in the bottom left, select Command Palette.. . You'll be given a prompt and you can enter this command below : IBM Blockchain Platform: Add Gateway 2. For our first Gateway, let's create MagnetoCorp. So when it prompts you for: Enter a name for the gateway enter the following below : MagnetoCorp 3. Then it will prompt you for a path to the connection profile. Click on browse and it will open a file window. Navigate to the path below and select networkConnection.yaml . NOTE: scroll over to see the entire file path below : Desktop - fabric-samples-cp - commercial-paper - organization - magnetocorp - gateway - networkConnection.yaml . 4. Then it will place that new gateway in the Fabric Gateway section within the IBM Blockchain Platform Extension. Now that we have a gateway, we need to create an identity to use this gateway. To do this, hover your cursor over the Fabric Wallets section of the extension. There you'll see a + icon. Click on that + icon to add a wallet. 5. Then it will prompt you: Choose a method to add a wallet and for that select Specify an existing file system wallet . We are selecting this because we already have added Isabella as an identity and she has a wallet folder. 6. Then it will prompt you: Enter file path to a wallet directory and then select Browse . It will then pop-up a file window. From there, you can navigate to the following path below. NOTE: scroll over to see the entire file path below: Desktop - fabric-samples-cp - commercial-paper - organization - magnetocorp - identity - user - isabella - wallet . Once you have selected wallet , click on select to choose this option. Then it will add a wallet, called wallet , to our Fabric Wallets section of the extension. 7. Once you see the wallet called wallet in the Fabric Wallet section, go ahead and right click on wallet . How many times can you say wallet in a sentence. From there, select Edit Wallet and it will open a settings.json file with your wallet name and wallet path highlighted. Go ahead and only change the wallet name to MagnetoCorpWallet . Look below to see the example: \"name\": \"wallet\", \"walletPath\": \"/home/tecadmin/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/identity/user/isabella/wallet\" ---- CHANGE TO ----- \"name\": \"MagnetoCorpWallet\", \"walletPath\": \"/home/tecadmin/Desktop/fabric-samples-cp/commercial-paper/organization/magnetocorp/identity/user/isabella/wallet\" 8. Once you have made that change, go ahead and save this file by doing a File - Save or Control + S . Also - leave this file open as we will want to change the name for DigiBank once we create their wallet. 9. Speaking of DigiBank, we now need to do the same process for them. So click on the gear icon in the bottom left, select Command Palette.. . You'll be given a prompt and you can enter this command below: IBM Blockchain Platform: Add Gateway 10. For our second Gateway, let's create DigiBank. So when it prompts you for: Enter a name for the gateway enter the following below: DigiBank 11. Then it will prompt you for a path to the connection profile. Click on browse and it will open a file window. Navigate to the path below and select networkConnection.yaml . NOTE: scroll over to see the entire file path below: Desktop - fabric-samples-cp - commercial-paper - organization - digibank - gateway - networkConnection.yaml . 12. Then it will place that new gateway in the Fabric Gateway section within the IBM Blockchain Platform Extension. Now that we have a gateway, we need to create an identity to use this gateway. To do this, hover your cursor over the Fabric Wallets section of the extension. There you'll see a + icon. Click on that + icon to add a wallet. 13. Then it will prompt you: Choose a method to add a wallet and for that select Specify an existing file system wallet . We are selecting this because we already have added Isabella as an identity and she has a wallet folder. 14. Then it will prompt you: Enter file path to a wallet directory and then select Browse . It will then pop-up a file window. From there, you can navigate to the following path below. NOTE: scroll over to see the entire file path below: Desktop - fabric-samples-cp - commercial-paper - organization - digibank - identity - user - balaji - wallet . Once you have selected wallet , click on select to choose this option. Then it will add a wallet, called wallet , to our Fabric Wallets section of the extension. 15. Once you see the wallet called wallet in the Fabric Wallet section, go ahead and right click on wallet . From there, select Edit Wallet and it will open a settings.json file with your wallet name and wallet path highlighted. Go ahead and only change the wallet name to DigiBankWallet . Look below to see the example: \"name\": \"wallet\", \"walletPath\": \"/home/tecadmin/Desktop/fabric-samples-cp/commercial-paper/organization/digibank/identity/user/balaji/wallet\" ---- CHANGE TO ----- \"name\": \"DigiBankWallet\", \"walletPath\": \"/home/tecadmin/Desktop/fabric-samples-cp/commercial-paper/organization/digibank/identity/user/balaji/wallet\" 16. Once you have made that change, go ahead and save this file by doing a File - Save or Control + S . Now within your Fabric Wallets section, you should have MagnetCorpWallet and DigiBankWallet as our two custom wallets. 17. Now that we have two wallets, we can associate our wallets to our two gateways. To do this right click on MagnetoCorp within the Fabric Gateways section. Then select Associate A Wallet . Then it will prompt you for which wallet to associate with this gateway. You will want to select MagnetoCorpWallet . What this does is when you connect with a specific gateway, it will automatically use that wallet you associated it with. For example, whenever you click on MagnetoCorp within the Fabric Gateway section, it will automatically use the MagnetoCorpWallet wallet without prompting you. 18. Do the same thing for DigiBank. Right click on DigiBank within the Fabric Gateways section. Then select Associate A Wallet . Then it will prompt you for which wallet to associate with this gateway. You will want to select DigiBankWallet . 19. To confirm that we have done this successfully, you can click on both gateways. You'll see the identities it is using once you connect to a specific gateway. To disconnect from a gateway, there is a door in the Fabric Gateways section in which you can click on to leave. 20. Now that we have our gateways figured out, let's do another lifecycle of a commercial paper. To do this, we need to do an issue transaction. First click on the MagnetoCorp gateway and untoggle till you see the transactions within the papercontract@0 . From there, right click on the issue transaction and select Submit Transaction . Within the brackets, place the text below: \"MagnetoCorp\", \"00002\", \"2020-05-31\", \"2020-11-30\", \"5000000\" You can hit enter again to bypass the next prompt asking for transient data. That will execute the transaction and issue paper 00002 21. To make sure we are all operating on the same paper number, we need to change a few files. I have broken down the files we need to change below within VSCode in the Editor perspective. From digibank/application folder, within the getPaper.js file on line 68 : const getPaperResponse = await contract.evaluateTransaction('getPaper', 'MagnetoCorp', '00001'); ---- CHANGE TO ---- const getPaperResponse = await contract.evaluateTransaction('getPaper', 'MagnetoCorp', '00002'); Make sure you save this file. From `digibank/application folder, within the redeem.js file on line 67 : const redeemResponse = await contract.submitTransaction('redeem', 'MagnetoCorp', '00001', 'DigiBank', '2020-11-30'); ---- CHANGE TO ---- const redeemResponse = await contract.submitTransaction('redeem', 'MagnetoCorp', '00002', 'DigiBank', '2020-11-30'); Make sure you save this file. 22. Now we can execute more transactions. First, jump back to the CLI and do a getPaper.js transaction. Below you will see what the command is to execute the transaction. NOTE: scroll over to see the entire command below: tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/digibank/application$ node getPaper.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper getPaper transaction. Process getPaper transaction response. +--------- Paper Retrieved ---------+ | Paper number: \"00002\" | Paper is owned by: \"MagnetoCorp\" | Paper is currently: \"ISSUED\" | Paper face value: \"5000000\" | Paper is issued by: \"MagnetoCorp\" | Paper issue on: \"2020-05-31\" | Paper matures on: \"2020-11-30\" +-----------------------------------+ Transaction complete. Disconnect from Fabric gateway. getPaper program complete. 23. Within VSCode and the IBM Blockchain Platform, we can buy the same paper. To do this, leave the MagnetoCorp gateway, and then click on the DigiBank gateway. 24. Now, untoggle till you see the buy transaction within the papercontract@0 smart contract. From there, right click on the buy transaction and select Submit Transaction . Once it gives you a prompt, enter the text below between the brackets: \"MagnetoCorp\",\"00002\",\"MagnetoCorp\",\"DigiBank\",\"4900000\",\"2019-07-31\" Then hit enter to go to the next prompt. Hit enter once again to bypass the transient data prompt. Then that will execute the buy transaction. 25. To confirm that the transaction worked (other than the log messages in the output window), we can do a getPaper transaction from the CLI again. NOTE: scroll over to see the entire command below: tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/digibank/application$ node getPaper.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper getPaper transaction. Process getPaper transaction response. +--------- Paper Retrieved ---------+ | Paper number: \"00002\" | Paper is owned by: \"DigiBank\" | Paper is currently: \"TRADING\" | Paper face value: \"5000000\" | Paper is issued by: \"MagnetoCorp\" | Paper issue on: \"2020-05-31\" | Paper matures on: \"2020-11-30\" +-----------------------------------+ Transaction complete. Disconnect from Fabric gateway. getPaper program complete. 26. From the same CLI, we can do a redeem.js transaction. NOTE: scroll over to see the entire command below: tecadmin@ubuntubase:~/Desktop/fabric-samples/commercial-paper/organization/digibank/application$ node redeem.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper redeem transaction. 2019-02-28T19:52:46.452Z - info: [TransactionEventHandler]: _strategySuccess: strategy success for transaction \"c26ecbf1077d99a5ea025c339ffabd88eb22cf4e6ac5ff8d9b570cd6c38eb531\" Process redeem transaction response. MagnetoCorp commercial paper : 00002 successfully redeemed with MagnetoCorp Transaction complete. Disconnect from Fabric gateway. Redeem program complete. 27. Again, we can confirm that this was recorded by doing another getPaper.js transaction. NOTE: scroll over to see the entire command below: tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/digibank/application$ node getPaper.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper getPaper transaction. Process getPaper transaction response. +--------- Paper Retrieved ---------+ | Paper number: \"00002\" | Paper is owned by: \"MagnetoCorp\" | Paper is currently: \"REDEEMED\" | Paper face value: \"5000000\" | Paper is issued by: \"MagnetoCorp\" | Paper issue on: \"2020-05-31\" | Paper matures on: \"2020-11-30\" +-----------------------------------+ Transaction complete. Disconnect from Fabric gateway. getPaper program complete.","title":"Section 5: Create Fabric Gateways and Submit Transactions"},{"location":"vscode-part2/#section-6-lab-clean-up","text":"This lab has run its course, but now it is time to clean up. Don't worry, this is a very short section! 1. Entering the following commands to stop and remove our docker containers. Then we can remove the images as well. Look at the following commands below :: tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/digibank/application$ docker stop $(docker ps -a -q) * * * Docker container IDs * * tecadmin@ubuntubase:~/Desktop/fabric-samples-cp/commercial-paper/organization/digibank/application$ docker rm $(docker ps -a -q) * * * Docker container IDs * * 2. From within the IBM Blockchain Platform Extension in VSCode, find the Local Fabric Ops section and hover your cursor in that section. Within that section, click on the three dots ( ... ) in the top right. Then select Teardown Fabric Runtime . This will clear the local Fabric cleanly. 3. Once that has ran its course, click on the three dots ( ... ) and select Start Fabric Runtime . This will start up a new local Fabric that we will use in the next part of the lab. That's it!","title":"Section 6: Lab Clean-Up"},{"location":"xchaincode/","text":"VSCode Lab Part 3 - Cross-Chaincode Calls and Debugging a Smart Contract You can use a chaincode to invoke other chaincodes. This allows a chaincode to query and write to data outside of its namespace. A chaincode can both read and update data outside of its namespace when calling chaincode that is instantiated on the same channel. However, a chaincode can only query data when calling chaincode on different channels. Chaincode to chaincode interactions can be very useful if you are looking to integrate business logic at the chaincode level or for migration purposes. The goal of this lab is to show you how to code cross-chaincode calls in a smart contract. The API that is used for doing this is the invokeChaincode() API from the fabric-shim library\u2019s ChaincodeStub class. The invokeChaincode() API is a lower-level Fabric API that can be invoked through the higher-level Fabric API that you have been using in the previous labs. Part of the cross-chaincode process is to understand how and where you want to code the chaincode to chaincode interaction. In this lab, we add a new smart contract called commercial-bond that we want commercial-paper to query. We want to simulate the situation that when a commercial-paper is issued, the commercial-paper smart contract queries the commercial-bond contract for current returns on bonds with a similar maturity date, and sets the paper price accordingly. For more details on this particular use case, see the scenario described here: Cross Chaincode Calls . For this lab commercial-bond is already written and packaged up for you. You will clone and add the package to your VSCode IBM Blockchain Platform Extension. Then you will package, install and instantiate the contract to your locally-running fabric environment. The instantiate process will also add a few sample bonds to the ledger and to commercial-bond's world state. This way your commercial-paper will have existing bonds to query and extract rates from. You can also experiment with commercial-bond's functions by issuing your own bonds. The bulk of the lab will be done against the existing commercial-paper. This is where you will add additional functions that interact with the commercial-bond contract. We will also use the VSCode IBM Blockchain Platform Debug Smart Contract function so you get an understanding of how to quickly iterate through changes to a smart contract in development mode and debug a smart contract. Finally we will deploy the bond-query-enabled commercial-paper to your local fabric, generate some functional tests, and run through them to make sure that the smart contract is functional. These are the general steps you will take: Clone the commercial-bond smart contract package and add package to VSCode workspace Package commercial-bond, install and instantiate Run a few tests to get familiar with commercial-bond Clone fresh commercial-paper Setup Debug Smart Contract in Development Mode Go through existing papercontract function in debugger Make smart contract update to include cross-chaincode call, test in debug session Add getPaperRate transaction to smart contract, test in debug session Add getAllPapersFromIssuer transaction to smart contract, test in debug session Package commercial-paper, install and instantiate The end! Section 1: Clone the commercial-bond smart contract package 1. Open up your terminal and run the following command from your home directory: $ git clone https://github.com/jinvanstee/commercial-bond.git Sample output: Cloning into 'commercial-bond'... remote: Enumerating objects: 32, done. remote: Counting objects: 100% (32/32), done. remote: Compressing objects: 100% (28/28), done. remote: Total 32 (delta 3), reused 31 (delta 2), pack-reused 0 Unpacking objects: 100% (32/32), done. 2. Return to your VSCode Explorer and add the commercial-bond smart contract folder to your workspace. Right click in a blank area in your workspace to get the drop down and select Add Folder to Workspace. Then browse to path to commercial-bond /organization/magnetocorp/ and select commercial-bond and click Add. You should see the contents of the folder in your workspace, like the following picture: (Please note that your other folders may look different than the screenshot below, but the contents within the commercial-bond folder should be the same) Section 2: Package commercial-bond, install and instantiate 1. In VSCode, open up the Command Palette (either by clicking on the gear icon to the lower left and selecting Command Palette or pressing Command + Shift + P if you are on a Mac and Ctl + Shift + P if you are on Linux). Select IBM Blockchain Platform: Package a Smart Contract Project : 2. Then select commercial-bond . Upon success, you will see in the lower right corner a message like this: 3. Now you will install this chaincode to your local-fabric. Navigate to the IBM Blockchain Platform view in VSCode (the 6th button down from the left menu): 4. Under the Local Fabric Ops panel, click on + Install , then select commercial-bond@0.0.1 from the list: Upon success, you will see a message similar to the following in the lower right corner of VSCode: You will also see the package listed under Installed in the Local Fabric Ops panel: 5. Now you will instantiate the installed contract. In the Local Fabric Ops panel, select + Instantiate . In the pop-up, similar to when you installed the smart contract, select commercial-bond@0.0.1 . Next, type instantiate when it asks you What function do you want to call. Press Enter to continue: Then you will see another pop-up asking what arguments to pass to the function. You will just hit Enter here: Lastly, you will be asked if you want to provide a private data collection configuration file. Again, just hit Enter here because private data collection doesn't apply in this case.: First time initialization of Node.js chaincode can take a while because it will need to pull down all the Node dependencies from the npm registry. After a few minutes, upon success, you will see a success message in the lower right corner of VSCode: 6. For reference for later, these are the bonds that were added to the ledger in the initialization phase: const bonds = [ { issuer: 'MagnetoCorp', bondNumber: '00001', issueDateTime: '2019-04-17', maturityDateTime: '2020-04-17', faceValue: '10000', interestRate: '0.05', }, { issuer: 'Digibank', bondNumber: '00001', issueDateTime: '2019-05-17', maturityDateTime: '2020-05-17', faceValue: '50000', interestRate: '0.04', }, { issuer: 'MagnetoCorp', bondNumber: '00002', issueDateTime: '2019-06-17', maturityDateTime: '2020-06-17', faceValue: '10000', interestRate: '0.05', }, { issuer: 'Digibank', bondNumber: '00002', issueDateTime: '2019-07-17', maturityDateTime: '2020-07-17', faceValue: '50000', interestRate: '0.04', }, ]; Now that you have instantiated commercial-bond on your locally-running fabric, you can... Section 3: Run a few tests to get familiar with commercial-bond 1. VSCode IBM Blockchain Platform Extension makes it easy for you to test out functions of your smart contract directly inside VSCode. Let's run a few tests directly through the functions made visible in the Fabric Gateways panel of the IBM Blockchain Platform view. Refresh the Fabric Gateways panel, and click on all the twisties to reveal the functions of commercial-bond: Scroll down to see all the functions of this smart contract: All of these functions represent transactions in this smart contract. Now, let's evaluate a few transactions. 2. Let's start with getAllBondsFromIssuer which will return all the bonds from a specified issuer. Select the function getAllBondsFromIssuer , and either right-click or Ctl+click and select Evaluate Transaction : 3. Next, you will see a familiar pop-up at the top of VSCode that asks you what are the arguments to the transaction. This transaction only takes one argument, and that is the name of the issuer. Let's type in \"MagnetoCorp\" as follows (important to include the double quotes): 4. Next, it will ask you what transient data to pass for the transaction. In this case we have none, so just press Enter to move forward. Now, in the OUTPUT view, you will see the results of evaluating this transaction. And you will see that there are two bonds issued by MagnetoCorp: Study the output and you will see other key/value pairs for each bond such as maturityDateTime , issuer , and interestRate . 5. A quick exercise- what is the interestRate for bondNumber 00002? 6. Now, let's issue a bond. This time we will submit the transaction so it gets committed to the ledger. In the Fabric Gateways panel, select the issue transaction. Either right-click or Ctl+click and select Submit Transaction . 7. Next, copy and paste the following inside the brackets when the pop-up asks you what are the arguments to the transaction: \"MagnetoCorp\", \"00003\", \"2019-02-28\", \"2020-02-28\", \"50000\",\"0.01\" Hit Enter and next you will see the screen that asks you for transient data. Hit Enter here because we don't have any transient data in this case. Then the transaction will get submitted. Upon success, you will see the following OUTPUT panel. Notice the [SUCCESS] message which means the transaction was successfully submitted. 8. The output to the issue command represents the bond, but it isn\u2019t very helpful as it is printed as the ASCII value of each character in decimal notation. Let's re-evaluate the getAllBondsFromIssuer transaction and see if this bond shows up. Use steps 2-4 above to re-run this transaction. Upon success, you will see the following output, and notice that the bond we just added shows up now: 9. Now, the last transaction for you to test is the getClosestBondRate transaction. This is the transaction that we will update commercial-paper to call. This transaction takes two arguments: 1) bondIssuer and 2) compareMaturityDate . This transaction will iterate through all the bonds issued by the specified bondIssuer until it finds a bond that has a similar maturity date as the one passed through compareMaturityDate , and it will return that bond's interest rate. If it cannot find a bond with a similar maturity date it will return an empty string. Select getClosestBondRate from the Fabric Gateways panel, and either right-click or Ctl+click and select Evaluate Transaction . 10. Next you will be asked what arguments to pass. Copy and paste the following inside the brackets: \"MagnetoCorp\",\"2020-02-15\" Hit Enter . Again, you will be asked for transient data and again you will just hit Enter to progress forward to evaluating the transaction. Upon success, you will see the following output in the OUTPUT panel: 11. Notice that the interest rate returned is 0.01, which if you recall is the interest rate associated with MagnetoCorp's bondNumber 00003, which has a maturity date of 2020-02-28 which is the same month as the second argument you passed for getClosestBondRate . 12. Now re-evaluate the transaction getClosestBondRate (steps 9 - 11) with the following arguments: \"MagnetoCorp\",\"2020-04-30\" What do you get returned? Is it expected? Which bond does the rate belong to? 13. Lastly, run the same evaluation but with the following arguments: \"MagnetoCorp\",\"2020-05-31\" Now what do you get returned? Is it expected? Section 4: Clone commercial-paper For this lab, we will start with a fresh commercial paper smart contract. Let's use the IBM Blockchain Platform Extension sample home page to get the commercial-paper package. Click on the IBM Blockchain Platform Extension icon in the upper right corner of VSCode: This will bring up the following page in VSCode: Click on Commercial Paper in the Explore sample code section: On the Commercial Paper Sample page, click on Clone (the picture below shows Clone again but if you are doing this the first time it should just say Clone ): Now it will ask you where you want to clone the repository. Pick a location on your workstation, and click Clone Repository . When it is done cloning, you will see the location that you cloned to here: Now, from the same Commercial Paper Sample page, go to the Smart Contracts section and select Open Locally for MagnetoCorp Contract : In the pop-up window, select Add to workspace : In your VSCode Explorer workspace panel, you will see the following folder with its contents added: Now you are ready to make changes and test them quickly by working in Hyperledger Fabric development mode in conjunction with the VSCode Debugger. Section 5: Setup Debug Smart Contract in Development Mode The VSCode IBM Blockchain Platform Extension provides an integrated Debug Smart Contract experience with VSCode's built-in debugger. It is a powerful tool for digging deeper into your smart contract code stack, and can be extremely useful in your smart contract development workflow. Using the debug feature will allow you to efficiently test out updates to your smart contract against a local Hyperledger Fabric running in development mode, without having to re-package, re-install and upgrade your smart contract manually with every change. Now, let's get into setting up the debug environment. 1. The first thing you will do is to Toggle Development Mode on your peer. Navigate to the IBM Blockchain Platform view in your VSCode: In the Local Fabric Ops panel, scroll down to find Nodes and expand that section. Ctl + select peer0.org1.example.com and select \"Toggle Development Mode\": This will take a minute. Upon success you will see the following message in the lower right corner: You will also see in the Local Fabric Ops panel, under Nodes , a little infinity symbol next to the peer: 2. Let's return to the VSCode Explorer perspective, and click on papercontract.js to open it. If you are unfamiliar with commercial-paper, please review what papercontract.js does in VSCode Lab Part 2 Section 1 and Section 3. 3. Next, navigate to the Debug view in VSCode: In this view you will see the following panels: An explanation of each of the panels: Variables - this panel will display all the variables in the current function Watch - you can pick specific variables to watch here, and track them as you step through your code Call Stack - this panel will display the call stack of the current function you are stepping through Breakpoints - this panel will display all the breakpoints in the current program 4. Let's configure a launch.json file for papercontract.js . According to VSCode's debugging documentation: For most debugging scenarios, creating a launch configuration file is beneficial because it allows you to configure and save debugging setup details. VSCode keeps debugging configuration information in a launch.json file located in a .vscode folder in your workspace (project root folder) or in your user settings or workspace settings. To get started, click on the little arrows next to the DEBUG toolbar at the top of the Debug view. Now select the name of your paper-contract project folder from the drop down. In the sample picture below the name of the project folder is cp-magnetocorp-contract-javascript : Next a pop-up window will ask you to select an environment. Because we are dealing with Node.js chaincode, select the option Fabric Smart Contract (Node.js) : This will open a launch.json . It should look like the following: Make sure your launch.json file looks like the above (if there are extra entries delete them). Save the file with Ctl+S and close it. 5. We are ready to launch a debug session for papercontract.js . Click on the little arrows again next to the DEBUG toolbar at the top of the Debug view: This time select Launch Smart Contract (cp-magnetocorp-contract-javascript) . Please note your project folder name may be slightly different. You will see your project folder name appear in parenthesis. Now, click on the green arrow in the DEBUG toolbar to launch a debug session against the smart contract: You should now see a little debugging toolbar appear at the top of VSCode, like the following picture. You can see the blue IBM Blockchain Platform logo at the right of this toolbar. Click on that button: 6. Clicking on the IBM Blockchain Platform button will bring up another pop-up menu, select Instantiate Smart Contract from this menu as follows: 7. Now the IBM Blockchain Platform Extension will package your smart contract and install it to your local peer running in development mode. Next you will be presented with a familiar pop-up asking what function you'd like to call. Type in instantiate as follows: Then you will see another pop-up asking what arguments to pass to the function. You will just hit Enter here: Lastly, you will be asked if you want to provide a private data collection configuration file. Again, just hit Enter here: Finally, upon successful instantiation, you will see the following message in the lower right corner: 8. To double check that the debug package was instantiated onto the local Hyperledger Fabric peer, navigate to the IBM Blockchain Platform view in VSCode, and look for the debug smart contract package in the Local Fabric Ops panel (Note: you may have to refresh that panel to see the new package): 9. Return to the VSCode Debug view. Now you are setup for developing and debugging the commercial-paper smart contract! Section 6: Go through existing papercontract function in debugger It may seem like a lot of steps to setup the smart contract debugging environment in VSCode, but it is worth spending time up front to configure a debugging session. You will be a more effective smart contract developer with this tool in your toolkit. 1. In the VSCode Debug view, if you look at the DEBUG CONSOLE output, you will see all the console.log messages for the functions that have been executed so far. So far we've only instantiated the smart contract, so you will only see the following message in the DEBUG CONSOLE : And if you look at the papercontract.js code at line 52 you will see the console.log instruction (note that where this code is located in your papercontract.js may be slightly different. If you see the DEBUG CONSOLE output it tells you which line this is from): 2. Let's put in a breakpoint and walk through one of the functions. Let's place a breakpoint on the first instruction in the issue function. Your screen should look like the following (you can either click on the space to the left of the line number, or put your cursor on that line and hit the F9 key): 3. Now let's execute the issue transaction and walk through the debugging process on the current papercontract.js . To submit or evaluate a transaction in the debugging environment we will leverage the integrated IBM Blockchain Platform Extension debug functionality. In the debug toolbar, click on the IBM Blockchain Platform button: A familiar pop-up window will appear at the top, select Submit Transaction : Then another pop-up window will appear listing all the functions/transactions that are available in papercontract.js for you to test. Let's select issue : Then, in the pop-up that asks what arguments to pass to the transaction, enter the following inside the brackets: \"MagnetoCorp\", \"00005\", \"2020-05-31\", \"2020-11-30\", \"500000\" For the next pop-up you will be asked for transient data for this transaction. Just hit Enter here: 4. Now the debugger will automatically stop at the breakpoint you set inside the issue function. And you should see the various debug panels on the left populated with information related to that line of code: Here you can choose to Step Over that line of code onto the next line, or Step Into the function which will dive into that call stack. If you've used debuggers before these should be familiar to you. The debugger toolbar at the top has the most commonly used debugging functions: Hover over each of the buttons to see what each one does. Let's select the Step Over function or you can press F10 to do the same thing. You will see that you are at the next line of code, and the variables panel has been updated with the results of executing the previous line of code. Notice that the paper variable has now been updated with the arguments input to the transaction: Ctl + click on the paper variable in the Variables panel and select Add to watch : You can now easily track this variable in the Watch panel as you progress with your debugging session: Continue to Step Over or Step into the rest of the issue transaction until you are satisfied with this flow. If you just want to get through to the end of the transaction hit the Continue button which will complete the transaction. You will see the output from this transaction below in the OUTPUT box. Section 7: Make smart contract updates to include cross-chaincode call, test in debugging session 1. OK, now that you have played with the debugger, let's add additional code to papercontract.js . We will first amend the issue function to take in interest rate as another parameter. The new issue function will also include code to query the commercial-bond contract for the interest rate of a bond that has a similar maturity date as the paper and align the paper rate to the bond rate. Then we will add the following the helper function: getPaperRate . 2. Before we edit papercontract.js , we need to update the createInstance function to include the paperRate parameter. Keep in mind papercontract.js uses paper.js to represent a paper. Go to your VSCode Explorer and open up paper.js : Replace the entire paper.js with the following code block: /* SPDX-License-Identifier: Apache-2.0 */ 'use strict'; // Utility class for ledger state const State = require('./../ledger-api/state.js'); // Enumerate commercial paper state values const cpState = { ISSUED: 1, TRADING: 2, REDEEMED: 3 }; /** * CommercialPaper class extends State class * Class will be used by application and smart contract to define a paper */ class CommercialPaper extends State { constructor(obj) { super(CommercialPaper.getClass(), [obj.issuer, obj.paperNumber]); Object.assign(this, obj); } /** * Basic getters and setters */ getIssuer() { return this.issuer; } setIssuer(newIssuer) { this.issuer = newIssuer; } getOwner() { return this.owner; } setOwner(newOwner) { this.owner = newOwner; } /** * Useful methods to encapsulate commercial paper states */ setIssued() { this.currentState = cpState.ISSUED; } setTrading() { this.currentState = cpState.TRADING; } setRedeemed() { this.currentState = cpState.REDEEMED; } isIssued() { return this.currentState === cpState.ISSUED; } isTrading() { return this.currentState === cpState.TRADING; } isRedeemed() { return this.currentState === cpState.REDEEMED; } static fromBuffer(buffer) { return CommercialPaper.deserialize(Buffer.from(JSON.parse(buffer))); } toBuffer() { return Buffer.from(JSON.stringify(this)); } /** * Deserialize a state data to commercial paper * @param {Buffer} data to form back into the object */ static deserialize(data) { return State.deserializeClass(data, CommercialPaper); } /** * Factory method to create a commercial paper object */ static createInstance(issuer, paperNumber, issueDateTime, maturityDateTime, faceValue, paperRate) { return new CommercialPaper({ issuer, paperNumber, issueDateTime, maturityDateTime, faceValue, paperRate }); } static getClass() { return 'org.papernet.commercialpaper'; } } module.exports = CommercialPaper; Save this file before moving on to the next step. Save the file with Command + S if you are on Mac, or Ctl + S if you are on Linux or Windows. 3. Return to the VSCode Debug view, and return to papercontract.js : 4. Replace the following issue function in existing papercontract.js : /** * Issue commercial paper * * @param {Context} ctx the transaction context * @param {String} issuer commercial paper issuer * @param {Integer} paperNumber paper number for this issuer * @param {String} issueDateTime paper issue date * @param {String} maturityDateTime paper maturity date * @param {Integer} faceValue face value of paper */ async issue(ctx, issuer, paperNumber, issueDateTime, maturityDateTime, faceValue) { // create an instance of the paper let paper = CommercialPaper.createInstance(issuer, paperNumber, issueDateTime, maturityDateTime, faceValue); // Smart contract, rather than paper, moves paper into ISSUED state paper.setIssued(); // Newly issued paper is owned by the issuer paper.setOwner(issuer); // Add the paper to the list of all similar commercial papers in the ledger world state await ctx.paperList.addPaper(paper); // Must return a serialized paper to caller of smart contract return paper.toBuffer(); } With this: /** * Issue commercial paper * * @param {Context} ctx the transaction context * @param {String} issuer commercial paper issuer * @param {Integer} paperNumber paper number for this issuer * @param {String} issueDateTime paper issue date * @param {String} maturityDateTime paper maturity date * @param {Integer} faceValue face value of paper * @param {Float} paperRate rate to price the paper */ async issue(ctx, issuer, paperNumber, issueDateTime, maturityDateTime, faceValue, paperRate) { // query commercial-bond contract for return rate on bond with similar maturity date let assignPaperRate = await ctx.stub.invokeChaincode( commercial-bond , [ getClosestBondRate , issuer, maturityDateTime], ctx.stub.getChannelID()); let newPaperRate = JSON.parse(assignPaperRate.payload.toString('utf8')); console.log( bond rate received back is: + newPaperRate); // create an instance of the paper, if there is a bond with similar maturity rate, set paper rate to be same as bond rate, otherwise use paper rate from input. var paper; if (newPaperRate != ) { console.log( set paper with bond rate + newPaperRate); paper = CommercialPaper.createInstance(issuer, paperNumber, issueDateTime, maturityDateTime, faceValue, newPaperRate); } else { console.log( set paper with original rate + paperRate); paper = CommercialPaper.createInstance(issuer, paperNumber, issueDateTime, maturityDateTime, faceValue, paperRate); } // Smart contract, rather than paper, moves paper into ISSUED state paper.setIssued(); // Newly issued paper is owned by the issuer paper.setOwner(issuer); // Add the paper to the list of all similar commercial papers in the ledger world state await ctx.paperList.addPaper(paper); // Must return a serialized paper to caller of smart contract return paper.toBuffer(); } Save this file with Command + S if you are on Mac, or Ctl + S if you are on Linux or Windows. Note: During the copy and paste process, the formatting of the code block might look off. You can highlight the code block, then Ctl + click and select Format Selection which should format the highlighted section nicely. The above issue function first queries the commercial-bond contract for the return rate on a bond with a similar maturity date. It uses the invokeChaincode() API from the ChaincodeStub class of the fabirc-shim library. The invokeChaincode() API takes three arguments: async invokeChaincode(chaincodeName, args, channel) (see full spec here ). In the invokeChaincode() example in the issue function above: The first argument passed is commercial-bond which is the name of the chaincode that you want to invoke. The second argument in our example is [\"getClosestBondRate\", issuer, maturityDateTime] which is an array of strings. The first array element \"getClosestBondRate\" is the function within the commercial-bond contract you want to invoke, the second and third elements are the arguments to pass to the getClosestBondRate function- in this case they are the name of the organization that issued the bonds you want to query and the maturity date that you want to compare bonds to. The third argument is ctx.stub.getChannelID() which returns the current channel that the calling chaincode is transacting on. In our example, this is because papercontract and commercial-bond reside in the same channel. If the chaincode you want to invoke resides in a different channel, you will specify the name of that channel directly here. Remember, you can only invoke query transactions for chaincodes that are on a different channel. The if-else code block in the above issue function will then test to see if the result of the invokeChaincode() function is an empty string. If the result is not an empty string, you want to create the paper asset with the bond rate (called newPaperRate ). If the result is an empty string, you want to create the paper asset with the paperRate passed through the issue function. Your issue function should look like the following: 5. Notice the breakpoint is still there in papercontract.js from Section 6. Let's remove it by clicking on the red dot or placing your cursor on that line and hitting F9. After this step you should not see any breakpoints. Note: If for whatever reason, you have exited the debug session, you can always bring it back by clicking on the green arrow button in the DEBUG toolbar or by clicking on the blue bar at the bottom of VSCode that says Launch Smart Contract : 6. Because we made updates to the smart contract we will need to upgrade the smart contract in order for the modifications to take effect against the local Fabric network. With the integrated IBM Blockchain Platform Debugger you can do everything from one screen and without exiting the current debug session. Click the blue IBM Blockchain Platform button in the debug toolbar to reveal the debug command list. 7. Select Upgrade Smart Contract from the list of options: 8. You will be asked what function you want to invoke, type in instantiate : 9. Then you will see another pop-up asking what arguments to pass to the function. You will just hit Enter here: 10. Lastly, you will be asked if you want to provide a private data collection configuration file. Again, just hit Enter here: 11. Finally, upon successful instantiation, you will see a message in the lower right corner saying Successfully upgraded smart contract . 12. Re-start your debug session to pick up the update. Hit Stop in the debug toolbar: 13. Now, click on either the green arrow button in the DEBUG toolbar or click on the blue bar at the bottom of VSCode that says Launch Smart Contract (cp-magnetocorp-contract-javascript) : And you will see the debug tool bar with the blue IBM Blockchain Platform logo launched at the top. The bar at the bottom turns orange to indicate that you are currently in a debug session. 14. Return to papercontract.js , and place a new breakpoint on the following line, which is the first uncommented line in the issue function: let assignPaperRate = await ctx.stub.invokeChaincode(\"commercial-bond\", [\"getClosestBondRate\", issuer, maturityDateTime], ctx.stub.getChannelID()); 15. Let's click on the IBM Blockchain Platform button in the debug toolbar: 16. Select Submit Transaction in the pop-up window: 17. Select the issue transaction in the pop-up window: 18. For the arguments pop-up, pass the following arguments inside the brackets: \"MagnetoCorp\", \"00004\", \"2020-01-31\", \"2020-04-30\", \"1000000\",\"0.03\" 19. In the transient data pop-up, hit Enter to skip this step and move forward: 20. And the debugger should stop at the breakpoint. 21. Add the variable newPaperRate to the Watch list. In the Variables panel, scroll down until you see the newPaperRate variable. Ctl + Click on newPaperRate and select Add to Watch , then press Enter for the variable to get added to the Watch panel: 22. Now find the variable paper in the Variables panel, and add that to the Watch panel as well: 23. Use the debug toolbar to Step over (or press F10) each line of code until you reach paper.setIssued() . Notice how the newPaperRate variable got set to the bond rate of bondNumber 00001 which is 0.05 (see Section 2 step 6). And the paper variable in the Watch panel has an interestRate of 0.05 (vs the 0.03 that was passed through the issue transaction): 24. Then you can hit Continue in the debug toolbar to complete the transaction. 25. You should see the following in the OUTPUT below upon a successful submission. 26. Click on the DEBUG CONSOLE view at the bottom of VSCode and see the console.log messages from submitting the new issue transaction. 27. Take a closer look at the OUTPUT from step 20, and you will see a line that says [INFO] submitting transaction issue with args MagnetoCorp,00004,2020-01-31,2020-04-30,1000000,0.03 . To double check that the paper we just submitted, MagnetoCorp:00004 indeed has been set with a rate of 0.05, instead of the 0.03 passed through the issue transaction, let's add a helper function called getPaperRate in section 8. Section 8: Add a helper function to the paper contract, test in debugging session 1. Go back to papercontract.js . Add the following code block right after the instantiate function: /** * Get paper rate for specified paper * @param {Context} ctx the transaction context * @param {String} issuer commercial paper issuer * @param {Integer} paperNumber paper number for this issuer */ async getPaperRate(ctx, issuer, paperNumber) { try { console.log( getPaper for: + issuer + + paperNumber); let paperKey = CommercialPaper.makeKey([issuer, paperNumber]); let paper = await ctx.paperList.getPaper(paperKey); console.log( paper rate for: + issuer + + paperNumber + is + paper.paperRate); return paper.paperRate; } catch (e) { throw new Error('Paper does not exist: ' + issuer + paperNumber); } } Save this file with Command + S if you are on Mac, or Ctl + S if you are on Linux or Windows. Your papercontract.js should look like the following: 2. Now that you have updated the smart contract again, you will need to deploy this new one to the local running peer. Follow the steps in Section 7: steps 6 - 13. 3. Let's evaluate a getPaperRate transaction. Let's click on the IBM Blockchain Platform button in the debug toolbar: 4. Now select Evaluate Transaction from the list: 5. In the next pop-up window, you will see the new transaction getPaperRate that you just added. Select it: 6. In the next pop-up, enter the following as arguments inside the brackets: \"MagnetoCorp\",\"00004\" 7. For the next pop-up you will be asked for transient data for this transaction. Just hit Enter here: 8. Upon success you will see the following output, which confirms that the paper submitted in Section 7 did indeed take the bond rate of 0.05: 9. If you have time, evaluate another issue transaction. This time pass a maturity date that you know does not have a match in commercial-bond . You can always go back to Section 2 step 6 to see which bonds are in the commercial-bond world state, and pick a maturity date for your paper that is not in the same month as the bonds. Step through the debugger with variables added to the Watch panel, and see if the logic behaves the way you expect. 10. Go to the VSCode IBM Blockchain Platform view. Under the Local Fabric Ops panel, you should see three papercontract@vscode-debug- datetime packages under Installed and one papercontract@vscode-debug- datetime under Instantiated . The instantiated package should have the same datetime as the latest installed one. The first papercontract@vscode-debug package was done against the original paper contract, the second package was done against the paper contract with the modified issue transaction, and the third package was built upon the second with a new getPaperRate function. 11. At this point you have successfully tweaked the papercontract.js to include a cross-chaincode call to another contract residing in the same channel. You have also added a helper function to get a paper rate on an existing paper on the ledger. One last useful transaction to have is one that queries and returns all papers by the same issuer. Let's make this update in the next section. Section 9: Add getAllPapers transaction to contract in debugging session 1. Return to your papercontract.js and paste in the following code block right after the getPaperRate() function: /** * Get all the commercial papers from issuer * @param {Context} ctx the transaction context * @param {String} paperIssuer the organization that issued the paper */ async getAllPapersFromIssuer(ctx, paperIssuer) { //following is required to setup the key in the proper format that getStateByPartialCompositeKey expects var paperKey = CommercialPaper.makeKey([paperIssuer]); var org = CommercialPaper.splitKey(paperKey); var iterator = await ctx.stub.getStateByPartialCompositeKey( org.papernet.commercialpaperlist , org); const allResults = []; while (true) { const res = await iterator.next(); if (res.value res.value.value.toString()) { console.log(res.value.value.toString('utf8')); const Key = res.value.key; let Record; try { Record = JSON.parse(res.value.value.toString('utf8')); } catch (err) { console.log(err); Record = res.value.value.toString('utf8'); } allResults.push({ Key, Record }); } if (res.done) { console.log('end of data'); await iterator.close(); console.info(allResults); return JSON.stringify(allResults); } } } This getAllPapersFromIssuer() function takes one argument, the name of the paper issuer you want to query. In our example so far, we have only used MagnetoCorp , so that is the string that would be passed as an argument to this transaction at this point. You should have noticed by now that this lab uses function and transaction interchangeably. They really mean the same thing in this lab, where one Node.js function invokes one smart contract transaction. You may also have noticed that in every papercontract.js function, the first argument is ctx . However, when we actually submit or evaluate that transaction, we don't pass anything to represent the ctx argument. In the new Fabric programming model, ctx represents the current transaction context. It gets passed automatically when the transaction is invoked. In the above function, the first thing we do is construct a partial composite key in the format that the API getStateByPartialCompositeKey() requires. A composite key is a key that is made up of two or more parts. In a smart contract you need to define assets with keys that distinguish them. You can have simple keys, meaning one unique key represents one asset. You can also have composite keys, meaning the asset is represented by the combination of multiple unique values. In the case of our commercial-paper and commercial-bond , their composite key is issuer : unique number . This means MagnetoCorp can have a paper with the number 00001, and Digibank can also have a paper with number 00001, and on the ledger they would be viewed as two separate assets. So in essence what we are constructing is a partial composite key that represents part of the whole key. What this allows us to do is use the getStateByPartialCompositeKey() API to get all the assets that match that partial composite key. getStateByPartialCompositeKey() returns an iterator object that you can then use to iterate through all the assets that match the partial composite key. For the complete spec on getStateByPartialCompositeKey() see here . In the while loop in the above function, we iterate through the assets and capture the attributes of each paper and add them to an array. And then the papers are returned in JSON format. 2. Now save the modified papercontract.js and use Section 7, steps 6 - 13 , to upgrade the smart contract from your current debug session. 3. Within a few seconds, you should see the debug toolbar appear at the top. Click on the blue IBM Blockchain Platform button: 4. Let's evaluate a transaction with the newly added getAllPapersFromIssuer transaction. First, select Evaluate Transaction : 5. Select the new transanction getAllPapersFromIssuer from the list: 6. Type in \"MagnetoCorp\" inside the brackets for the arguments window: 7. Next, it will ask you what transient data to pass for the transaction. Press Enter to move forward. 8. Upon successful evaluation, you will see the following message in the lower right corner: 9. You will also see all the papers issued by MagnetoCorp in the OUTPUT panel (In the following screenshot you will see three papers. But in your output you should only have two: MagnetoCorp:00004 and MagnetoCorp:00005 ): 10. Go to the VSCode IBM Blockchain Platform view, under the Local Fabric Ops panel, you should see four papercontract@vscode-debug- datetime packages under Installed and one papercontract@vscode-debug- datetime under Instantiated . The instantiated package should have the same datetime as the latest installed one. The latest instantiated package is from this section when we added the getAllPapersFromIssuer transaction. We hope that with this flow, you get to experience one way you can develop and build upon your smart contract. Section 10: Package commercial-paper, install and instantiate Now that you are done updating the commercial-paper smart contract, you can exit out of the debug session, toggle off development mode on your peer, and package, install and upgrade to the completed smart contract. 1. Exit debug session by pressing Stop (or Ctl + F5 ) in the debug toolbar: 2. Now to go the IBM Blockchain Platform Extension view in VSCode, and toggle development mode off on peer0.org1.example.com : 3. Upon success, you will no longer see the infinity symbol next to peer0.org1.example.com and you will see the following message appear in the lower right corner: 4. Now we will manually package up commercial-paper . Go back to the VSCode Explorer perspective. In the workspace panel, select package.json in the cp-magnetocorp-contract-javascript folder to open it in the editor: 5. Change the package version to 0.0.2 as follows: Save the file with Command + S if you are on Mac, or Ctl + S if you are on Linux or Windows. 6. Open up the Command Palette (either by clicking on the gear icon to the lower left and selecting Command Palette or pressing Command + Shift + P if you are on a Mac and Ctl + Shift + P if you are on Linux). Select IBM Blockchain Platform: Package a Smart Contract Project : 7. Then select cp-magnetocorp-contract-javascript and press Enter . 8. Upon success, you will see the following message in the lower right corner: 9. Now you will install this chaincode to your local-fabric. Navigate to the IBM Blockchain Platform view in VSCode (the 6th button down from the left menu): 10. Under the Local Fabric Ops panel, click on + Install , then select papercontract@0.0.2 from the list: Upon success, you will see a message similar to the following in the lower right corner of VSCode: You will also see the package listed under Installed in the Local Fabric Ops panel: 11. Now you can upgrade the debug package to the papercontract@0.0.2 package. Select the existing debug papercontract package and Ctl + Click or right click and select Upgrade Smart Contract : 12. Select papercontract@0.0.2 from the list: 13. In the function box, enter instantiate as follows: Then you will see another pop-up asking what arguments to pass to the function. You will just hit Enter here: Lastly, you will be asked if you want to provide a private data collection configuration file. Again, just hit Enter here: 14. Upon successful upgrade you will see the following message in the lower right corner: You will aso see in the Local Fabric Ops panel, that papercontract@0.0.2 is listed under the Instantiated section: 15. Let's run a couple of quick tests to make sure the package looks good. In the Fabric Gateways panel, expand on the mychannel twistie to reveal the two chaincodes. Drill into the papercontract chaincode to reveal all the transactions. 16. Let's first submit an issue transaction. This time let's issue a paper as Digibank . Right click on issue and select Submit Transaction . 17. Then enter the following arguments inside the brackets to pass to issue : \"Digibank\",\"00001\",\"2020-01-31\",\"2020-05-31\",\"90000\",\"0.02\" For transient data, just press Enter : 18. Upon success, you will see the following in the OUTPUT panel: 19. Now we want to check that this paper actually has been issued with the rate of 0.04, which is the bond rate from bond Digibank:00001 (see Section 2 step 6). Again, if you recall, this is because paper Digibank:00001 has a maturity date in the same month as bond Digibank:00001 . Let's do this by submitting a getPaperRate transaction. From the Fabric Gateways panel, right click on getPaperRate and select Submit Transaction : 20. Then enter the following arguments inside the brackets to pass to getPaperRate : \"Digibank\",\"00001\" For transient data, just press Enter : 21. Upon success, you will see the following in the OUTPUT panel. And you will see that indeed, paper Digibank:00001 has been set with a paper rate of 0.04: 22. The last transaction we want to test is the getAllPapersFromIssuer . I will leave it to you to complete this test given the knowledge you now possess. 23. Leave the environment running for now. Congratulations! You are done with this part of the lab!","title":"VSCode Lab Part 3 - Cross-Chaincode Calls and Debugging a Smart Contract"},{"location":"xchaincode/#vscode-lab-part-3-cross-chaincode-calls-and-debugging-a-smart-contract","text":"You can use a chaincode to invoke other chaincodes. This allows a chaincode to query and write to data outside of its namespace. A chaincode can both read and update data outside of its namespace when calling chaincode that is instantiated on the same channel. However, a chaincode can only query data when calling chaincode on different channels. Chaincode to chaincode interactions can be very useful if you are looking to integrate business logic at the chaincode level or for migration purposes. The goal of this lab is to show you how to code cross-chaincode calls in a smart contract. The API that is used for doing this is the invokeChaincode() API from the fabric-shim library\u2019s ChaincodeStub class. The invokeChaincode() API is a lower-level Fabric API that can be invoked through the higher-level Fabric API that you have been using in the previous labs. Part of the cross-chaincode process is to understand how and where you want to code the chaincode to chaincode interaction. In this lab, we add a new smart contract called commercial-bond that we want commercial-paper to query. We want to simulate the situation that when a commercial-paper is issued, the commercial-paper smart contract queries the commercial-bond contract for current returns on bonds with a similar maturity date, and sets the paper price accordingly. For more details on this particular use case, see the scenario described here: Cross Chaincode Calls . For this lab commercial-bond is already written and packaged up for you. You will clone and add the package to your VSCode IBM Blockchain Platform Extension. Then you will package, install and instantiate the contract to your locally-running fabric environment. The instantiate process will also add a few sample bonds to the ledger and to commercial-bond's world state. This way your commercial-paper will have existing bonds to query and extract rates from. You can also experiment with commercial-bond's functions by issuing your own bonds. The bulk of the lab will be done against the existing commercial-paper. This is where you will add additional functions that interact with the commercial-bond contract. We will also use the VSCode IBM Blockchain Platform Debug Smart Contract function so you get an understanding of how to quickly iterate through changes to a smart contract in development mode and debug a smart contract. Finally we will deploy the bond-query-enabled commercial-paper to your local fabric, generate some functional tests, and run through them to make sure that the smart contract is functional. These are the general steps you will take: Clone the commercial-bond smart contract package and add package to VSCode workspace Package commercial-bond, install and instantiate Run a few tests to get familiar with commercial-bond Clone fresh commercial-paper Setup Debug Smart Contract in Development Mode Go through existing papercontract function in debugger Make smart contract update to include cross-chaincode call, test in debug session Add getPaperRate transaction to smart contract, test in debug session Add getAllPapersFromIssuer transaction to smart contract, test in debug session Package commercial-paper, install and instantiate The end!","title":"VSCode Lab Part 3 - Cross-Chaincode Calls and Debugging a Smart Contract"},{"location":"xchaincode/#section-1-clone-the-commercial-bond-smart-contract-package","text":"1. Open up your terminal and run the following command from your home directory: $ git clone https://github.com/jinvanstee/commercial-bond.git Sample output: Cloning into 'commercial-bond'... remote: Enumerating objects: 32, done. remote: Counting objects: 100% (32/32), done. remote: Compressing objects: 100% (28/28), done. remote: Total 32 (delta 3), reused 31 (delta 2), pack-reused 0 Unpacking objects: 100% (32/32), done. 2. Return to your VSCode Explorer and add the commercial-bond smart contract folder to your workspace. Right click in a blank area in your workspace to get the drop down and select Add Folder to Workspace. Then browse to path to commercial-bond /organization/magnetocorp/ and select commercial-bond and click Add. You should see the contents of the folder in your workspace, like the following picture: (Please note that your other folders may look different than the screenshot below, but the contents within the commercial-bond folder should be the same)","title":"Section 1: Clone the commercial-bond smart contract package"},{"location":"xchaincode/#section-2-package-commercial-bond-install-and-instantiate","text":"1. In VSCode, open up the Command Palette (either by clicking on the gear icon to the lower left and selecting Command Palette or pressing Command + Shift + P if you are on a Mac and Ctl + Shift + P if you are on Linux). Select IBM Blockchain Platform: Package a Smart Contract Project : 2. Then select commercial-bond . Upon success, you will see in the lower right corner a message like this: 3. Now you will install this chaincode to your local-fabric. Navigate to the IBM Blockchain Platform view in VSCode (the 6th button down from the left menu): 4. Under the Local Fabric Ops panel, click on + Install , then select commercial-bond@0.0.1 from the list: Upon success, you will see a message similar to the following in the lower right corner of VSCode: You will also see the package listed under Installed in the Local Fabric Ops panel: 5. Now you will instantiate the installed contract. In the Local Fabric Ops panel, select + Instantiate . In the pop-up, similar to when you installed the smart contract, select commercial-bond@0.0.1 . Next, type instantiate when it asks you What function do you want to call. Press Enter to continue: Then you will see another pop-up asking what arguments to pass to the function. You will just hit Enter here: Lastly, you will be asked if you want to provide a private data collection configuration file. Again, just hit Enter here because private data collection doesn't apply in this case.: First time initialization of Node.js chaincode can take a while because it will need to pull down all the Node dependencies from the npm registry. After a few minutes, upon success, you will see a success message in the lower right corner of VSCode: 6. For reference for later, these are the bonds that were added to the ledger in the initialization phase: const bonds = [ { issuer: 'MagnetoCorp', bondNumber: '00001', issueDateTime: '2019-04-17', maturityDateTime: '2020-04-17', faceValue: '10000', interestRate: '0.05', }, { issuer: 'Digibank', bondNumber: '00001', issueDateTime: '2019-05-17', maturityDateTime: '2020-05-17', faceValue: '50000', interestRate: '0.04', }, { issuer: 'MagnetoCorp', bondNumber: '00002', issueDateTime: '2019-06-17', maturityDateTime: '2020-06-17', faceValue: '10000', interestRate: '0.05', }, { issuer: 'Digibank', bondNumber: '00002', issueDateTime: '2019-07-17', maturityDateTime: '2020-07-17', faceValue: '50000', interestRate: '0.04', }, ]; Now that you have instantiated commercial-bond on your locally-running fabric, you can...","title":"Section 2: Package commercial-bond, install and instantiate"},{"location":"xchaincode/#section-3-run-a-few-tests-to-get-familiar-with-commercial-bond","text":"1. VSCode IBM Blockchain Platform Extension makes it easy for you to test out functions of your smart contract directly inside VSCode. Let's run a few tests directly through the functions made visible in the Fabric Gateways panel of the IBM Blockchain Platform view. Refresh the Fabric Gateways panel, and click on all the twisties to reveal the functions of commercial-bond: Scroll down to see all the functions of this smart contract: All of these functions represent transactions in this smart contract. Now, let's evaluate a few transactions. 2. Let's start with getAllBondsFromIssuer which will return all the bonds from a specified issuer. Select the function getAllBondsFromIssuer , and either right-click or Ctl+click and select Evaluate Transaction : 3. Next, you will see a familiar pop-up at the top of VSCode that asks you what are the arguments to the transaction. This transaction only takes one argument, and that is the name of the issuer. Let's type in \"MagnetoCorp\" as follows (important to include the double quotes): 4. Next, it will ask you what transient data to pass for the transaction. In this case we have none, so just press Enter to move forward. Now, in the OUTPUT view, you will see the results of evaluating this transaction. And you will see that there are two bonds issued by MagnetoCorp: Study the output and you will see other key/value pairs for each bond such as maturityDateTime , issuer , and interestRate . 5. A quick exercise- what is the interestRate for bondNumber 00002? 6. Now, let's issue a bond. This time we will submit the transaction so it gets committed to the ledger. In the Fabric Gateways panel, select the issue transaction. Either right-click or Ctl+click and select Submit Transaction . 7. Next, copy and paste the following inside the brackets when the pop-up asks you what are the arguments to the transaction: \"MagnetoCorp\", \"00003\", \"2019-02-28\", \"2020-02-28\", \"50000\",\"0.01\" Hit Enter and next you will see the screen that asks you for transient data. Hit Enter here because we don't have any transient data in this case. Then the transaction will get submitted. Upon success, you will see the following OUTPUT panel. Notice the [SUCCESS] message which means the transaction was successfully submitted. 8. The output to the issue command represents the bond, but it isn\u2019t very helpful as it is printed as the ASCII value of each character in decimal notation. Let's re-evaluate the getAllBondsFromIssuer transaction and see if this bond shows up. Use steps 2-4 above to re-run this transaction. Upon success, you will see the following output, and notice that the bond we just added shows up now: 9. Now, the last transaction for you to test is the getClosestBondRate transaction. This is the transaction that we will update commercial-paper to call. This transaction takes two arguments: 1) bondIssuer and 2) compareMaturityDate . This transaction will iterate through all the bonds issued by the specified bondIssuer until it finds a bond that has a similar maturity date as the one passed through compareMaturityDate , and it will return that bond's interest rate. If it cannot find a bond with a similar maturity date it will return an empty string. Select getClosestBondRate from the Fabric Gateways panel, and either right-click or Ctl+click and select Evaluate Transaction . 10. Next you will be asked what arguments to pass. Copy and paste the following inside the brackets: \"MagnetoCorp\",\"2020-02-15\" Hit Enter . Again, you will be asked for transient data and again you will just hit Enter to progress forward to evaluating the transaction. Upon success, you will see the following output in the OUTPUT panel: 11. Notice that the interest rate returned is 0.01, which if you recall is the interest rate associated with MagnetoCorp's bondNumber 00003, which has a maturity date of 2020-02-28 which is the same month as the second argument you passed for getClosestBondRate . 12. Now re-evaluate the transaction getClosestBondRate (steps 9 - 11) with the following arguments: \"MagnetoCorp\",\"2020-04-30\" What do you get returned? Is it expected? Which bond does the rate belong to? 13. Lastly, run the same evaluation but with the following arguments: \"MagnetoCorp\",\"2020-05-31\" Now what do you get returned? Is it expected?","title":"Section 3: Run a few tests to get familiar with commercial-bond"},{"location":"xchaincode/#section-4-clone-commercial-paper","text":"For this lab, we will start with a fresh commercial paper smart contract. Let's use the IBM Blockchain Platform Extension sample home page to get the commercial-paper package. Click on the IBM Blockchain Platform Extension icon in the upper right corner of VSCode: This will bring up the following page in VSCode: Click on Commercial Paper in the Explore sample code section: On the Commercial Paper Sample page, click on Clone (the picture below shows Clone again but if you are doing this the first time it should just say Clone ): Now it will ask you where you want to clone the repository. Pick a location on your workstation, and click Clone Repository . When it is done cloning, you will see the location that you cloned to here: Now, from the same Commercial Paper Sample page, go to the Smart Contracts section and select Open Locally for MagnetoCorp Contract : In the pop-up window, select Add to workspace : In your VSCode Explorer workspace panel, you will see the following folder with its contents added: Now you are ready to make changes and test them quickly by working in Hyperledger Fabric development mode in conjunction with the VSCode Debugger.","title":"Section 4: Clone commercial-paper"},{"location":"xchaincode/#section-5-setup-debug-smart-contract-in-development-mode","text":"The VSCode IBM Blockchain Platform Extension provides an integrated Debug Smart Contract experience with VSCode's built-in debugger. It is a powerful tool for digging deeper into your smart contract code stack, and can be extremely useful in your smart contract development workflow. Using the debug feature will allow you to efficiently test out updates to your smart contract against a local Hyperledger Fabric running in development mode, without having to re-package, re-install and upgrade your smart contract manually with every change. Now, let's get into setting up the debug environment. 1. The first thing you will do is to Toggle Development Mode on your peer. Navigate to the IBM Blockchain Platform view in your VSCode: In the Local Fabric Ops panel, scroll down to find Nodes and expand that section. Ctl + select peer0.org1.example.com and select \"Toggle Development Mode\": This will take a minute. Upon success you will see the following message in the lower right corner: You will also see in the Local Fabric Ops panel, under Nodes , a little infinity symbol next to the peer: 2. Let's return to the VSCode Explorer perspective, and click on papercontract.js to open it. If you are unfamiliar with commercial-paper, please review what papercontract.js does in VSCode Lab Part 2 Section 1 and Section 3. 3. Next, navigate to the Debug view in VSCode: In this view you will see the following panels: An explanation of each of the panels: Variables - this panel will display all the variables in the current function Watch - you can pick specific variables to watch here, and track them as you step through your code Call Stack - this panel will display the call stack of the current function you are stepping through Breakpoints - this panel will display all the breakpoints in the current program 4. Let's configure a launch.json file for papercontract.js . According to VSCode's debugging documentation: For most debugging scenarios, creating a launch configuration file is beneficial because it allows you to configure and save debugging setup details. VSCode keeps debugging configuration information in a launch.json file located in a .vscode folder in your workspace (project root folder) or in your user settings or workspace settings. To get started, click on the little arrows next to the DEBUG toolbar at the top of the Debug view. Now select the name of your paper-contract project folder from the drop down. In the sample picture below the name of the project folder is cp-magnetocorp-contract-javascript : Next a pop-up window will ask you to select an environment. Because we are dealing with Node.js chaincode, select the option Fabric Smart Contract (Node.js) : This will open a launch.json . It should look like the following: Make sure your launch.json file looks like the above (if there are extra entries delete them). Save the file with Ctl+S and close it. 5. We are ready to launch a debug session for papercontract.js . Click on the little arrows again next to the DEBUG toolbar at the top of the Debug view: This time select Launch Smart Contract (cp-magnetocorp-contract-javascript) . Please note your project folder name may be slightly different. You will see your project folder name appear in parenthesis. Now, click on the green arrow in the DEBUG toolbar to launch a debug session against the smart contract: You should now see a little debugging toolbar appear at the top of VSCode, like the following picture. You can see the blue IBM Blockchain Platform logo at the right of this toolbar. Click on that button: 6. Clicking on the IBM Blockchain Platform button will bring up another pop-up menu, select Instantiate Smart Contract from this menu as follows: 7. Now the IBM Blockchain Platform Extension will package your smart contract and install it to your local peer running in development mode. Next you will be presented with a familiar pop-up asking what function you'd like to call. Type in instantiate as follows: Then you will see another pop-up asking what arguments to pass to the function. You will just hit Enter here: Lastly, you will be asked if you want to provide a private data collection configuration file. Again, just hit Enter here: Finally, upon successful instantiation, you will see the following message in the lower right corner: 8. To double check that the debug package was instantiated onto the local Hyperledger Fabric peer, navigate to the IBM Blockchain Platform view in VSCode, and look for the debug smart contract package in the Local Fabric Ops panel (Note: you may have to refresh that panel to see the new package): 9. Return to the VSCode Debug view. Now you are setup for developing and debugging the commercial-paper smart contract!","title":"Section 5: Setup Debug Smart Contract in Development Mode"},{"location":"xchaincode/#section-6-go-through-existing-papercontract-function-in-debugger","text":"It may seem like a lot of steps to setup the smart contract debugging environment in VSCode, but it is worth spending time up front to configure a debugging session. You will be a more effective smart contract developer with this tool in your toolkit. 1. In the VSCode Debug view, if you look at the DEBUG CONSOLE output, you will see all the console.log messages for the functions that have been executed so far. So far we've only instantiated the smart contract, so you will only see the following message in the DEBUG CONSOLE : And if you look at the papercontract.js code at line 52 you will see the console.log instruction (note that where this code is located in your papercontract.js may be slightly different. If you see the DEBUG CONSOLE output it tells you which line this is from): 2. Let's put in a breakpoint and walk through one of the functions. Let's place a breakpoint on the first instruction in the issue function. Your screen should look like the following (you can either click on the space to the left of the line number, or put your cursor on that line and hit the F9 key): 3. Now let's execute the issue transaction and walk through the debugging process on the current papercontract.js . To submit or evaluate a transaction in the debugging environment we will leverage the integrated IBM Blockchain Platform Extension debug functionality. In the debug toolbar, click on the IBM Blockchain Platform button: A familiar pop-up window will appear at the top, select Submit Transaction : Then another pop-up window will appear listing all the functions/transactions that are available in papercontract.js for you to test. Let's select issue : Then, in the pop-up that asks what arguments to pass to the transaction, enter the following inside the brackets: \"MagnetoCorp\", \"00005\", \"2020-05-31\", \"2020-11-30\", \"500000\" For the next pop-up you will be asked for transient data for this transaction. Just hit Enter here: 4. Now the debugger will automatically stop at the breakpoint you set inside the issue function. And you should see the various debug panels on the left populated with information related to that line of code: Here you can choose to Step Over that line of code onto the next line, or Step Into the function which will dive into that call stack. If you've used debuggers before these should be familiar to you. The debugger toolbar at the top has the most commonly used debugging functions: Hover over each of the buttons to see what each one does. Let's select the Step Over function or you can press F10 to do the same thing. You will see that you are at the next line of code, and the variables panel has been updated with the results of executing the previous line of code. Notice that the paper variable has now been updated with the arguments input to the transaction: Ctl + click on the paper variable in the Variables panel and select Add to watch : You can now easily track this variable in the Watch panel as you progress with your debugging session: Continue to Step Over or Step into the rest of the issue transaction until you are satisfied with this flow. If you just want to get through to the end of the transaction hit the Continue button which will complete the transaction. You will see the output from this transaction below in the OUTPUT box.","title":"Section 6: Go through existing papercontract function in debugger"},{"location":"xchaincode/#section-7-make-smart-contract-updates-to-include-cross-chaincode-call-test-in-debugging-session","text":"1. OK, now that you have played with the debugger, let's add additional code to papercontract.js . We will first amend the issue function to take in interest rate as another parameter. The new issue function will also include code to query the commercial-bond contract for the interest rate of a bond that has a similar maturity date as the paper and align the paper rate to the bond rate. Then we will add the following the helper function: getPaperRate . 2. Before we edit papercontract.js , we need to update the createInstance function to include the paperRate parameter. Keep in mind papercontract.js uses paper.js to represent a paper. Go to your VSCode Explorer and open up paper.js : Replace the entire paper.js with the following code block: /* SPDX-License-Identifier: Apache-2.0 */ 'use strict'; // Utility class for ledger state const State = require('./../ledger-api/state.js'); // Enumerate commercial paper state values const cpState = { ISSUED: 1, TRADING: 2, REDEEMED: 3 }; /** * CommercialPaper class extends State class * Class will be used by application and smart contract to define a paper */ class CommercialPaper extends State { constructor(obj) { super(CommercialPaper.getClass(), [obj.issuer, obj.paperNumber]); Object.assign(this, obj); } /** * Basic getters and setters */ getIssuer() { return this.issuer; } setIssuer(newIssuer) { this.issuer = newIssuer; } getOwner() { return this.owner; } setOwner(newOwner) { this.owner = newOwner; } /** * Useful methods to encapsulate commercial paper states */ setIssued() { this.currentState = cpState.ISSUED; } setTrading() { this.currentState = cpState.TRADING; } setRedeemed() { this.currentState = cpState.REDEEMED; } isIssued() { return this.currentState === cpState.ISSUED; } isTrading() { return this.currentState === cpState.TRADING; } isRedeemed() { return this.currentState === cpState.REDEEMED; } static fromBuffer(buffer) { return CommercialPaper.deserialize(Buffer.from(JSON.parse(buffer))); } toBuffer() { return Buffer.from(JSON.stringify(this)); } /** * Deserialize a state data to commercial paper * @param {Buffer} data to form back into the object */ static deserialize(data) { return State.deserializeClass(data, CommercialPaper); } /** * Factory method to create a commercial paper object */ static createInstance(issuer, paperNumber, issueDateTime, maturityDateTime, faceValue, paperRate) { return new CommercialPaper({ issuer, paperNumber, issueDateTime, maturityDateTime, faceValue, paperRate }); } static getClass() { return 'org.papernet.commercialpaper'; } } module.exports = CommercialPaper; Save this file before moving on to the next step. Save the file with Command + S if you are on Mac, or Ctl + S if you are on Linux or Windows. 3. Return to the VSCode Debug view, and return to papercontract.js : 4. Replace the following issue function in existing papercontract.js : /** * Issue commercial paper * * @param {Context} ctx the transaction context * @param {String} issuer commercial paper issuer * @param {Integer} paperNumber paper number for this issuer * @param {String} issueDateTime paper issue date * @param {String} maturityDateTime paper maturity date * @param {Integer} faceValue face value of paper */ async issue(ctx, issuer, paperNumber, issueDateTime, maturityDateTime, faceValue) { // create an instance of the paper let paper = CommercialPaper.createInstance(issuer, paperNumber, issueDateTime, maturityDateTime, faceValue); // Smart contract, rather than paper, moves paper into ISSUED state paper.setIssued(); // Newly issued paper is owned by the issuer paper.setOwner(issuer); // Add the paper to the list of all similar commercial papers in the ledger world state await ctx.paperList.addPaper(paper); // Must return a serialized paper to caller of smart contract return paper.toBuffer(); } With this: /** * Issue commercial paper * * @param {Context} ctx the transaction context * @param {String} issuer commercial paper issuer * @param {Integer} paperNumber paper number for this issuer * @param {String} issueDateTime paper issue date * @param {String} maturityDateTime paper maturity date * @param {Integer} faceValue face value of paper * @param {Float} paperRate rate to price the paper */ async issue(ctx, issuer, paperNumber, issueDateTime, maturityDateTime, faceValue, paperRate) { // query commercial-bond contract for return rate on bond with similar maturity date let assignPaperRate = await ctx.stub.invokeChaincode( commercial-bond , [ getClosestBondRate , issuer, maturityDateTime], ctx.stub.getChannelID()); let newPaperRate = JSON.parse(assignPaperRate.payload.toString('utf8')); console.log( bond rate received back is: + newPaperRate); // create an instance of the paper, if there is a bond with similar maturity rate, set paper rate to be same as bond rate, otherwise use paper rate from input. var paper; if (newPaperRate != ) { console.log( set paper with bond rate + newPaperRate); paper = CommercialPaper.createInstance(issuer, paperNumber, issueDateTime, maturityDateTime, faceValue, newPaperRate); } else { console.log( set paper with original rate + paperRate); paper = CommercialPaper.createInstance(issuer, paperNumber, issueDateTime, maturityDateTime, faceValue, paperRate); } // Smart contract, rather than paper, moves paper into ISSUED state paper.setIssued(); // Newly issued paper is owned by the issuer paper.setOwner(issuer); // Add the paper to the list of all similar commercial papers in the ledger world state await ctx.paperList.addPaper(paper); // Must return a serialized paper to caller of smart contract return paper.toBuffer(); } Save this file with Command + S if you are on Mac, or Ctl + S if you are on Linux or Windows. Note: During the copy and paste process, the formatting of the code block might look off. You can highlight the code block, then Ctl + click and select Format Selection which should format the highlighted section nicely. The above issue function first queries the commercial-bond contract for the return rate on a bond with a similar maturity date. It uses the invokeChaincode() API from the ChaincodeStub class of the fabirc-shim library. The invokeChaincode() API takes three arguments: async invokeChaincode(chaincodeName, args, channel) (see full spec here ). In the invokeChaincode() example in the issue function above: The first argument passed is commercial-bond which is the name of the chaincode that you want to invoke. The second argument in our example is [\"getClosestBondRate\", issuer, maturityDateTime] which is an array of strings. The first array element \"getClosestBondRate\" is the function within the commercial-bond contract you want to invoke, the second and third elements are the arguments to pass to the getClosestBondRate function- in this case they are the name of the organization that issued the bonds you want to query and the maturity date that you want to compare bonds to. The third argument is ctx.stub.getChannelID() which returns the current channel that the calling chaincode is transacting on. In our example, this is because papercontract and commercial-bond reside in the same channel. If the chaincode you want to invoke resides in a different channel, you will specify the name of that channel directly here. Remember, you can only invoke query transactions for chaincodes that are on a different channel. The if-else code block in the above issue function will then test to see if the result of the invokeChaincode() function is an empty string. If the result is not an empty string, you want to create the paper asset with the bond rate (called newPaperRate ). If the result is an empty string, you want to create the paper asset with the paperRate passed through the issue function. Your issue function should look like the following: 5. Notice the breakpoint is still there in papercontract.js from Section 6. Let's remove it by clicking on the red dot or placing your cursor on that line and hitting F9. After this step you should not see any breakpoints. Note: If for whatever reason, you have exited the debug session, you can always bring it back by clicking on the green arrow button in the DEBUG toolbar or by clicking on the blue bar at the bottom of VSCode that says Launch Smart Contract : 6. Because we made updates to the smart contract we will need to upgrade the smart contract in order for the modifications to take effect against the local Fabric network. With the integrated IBM Blockchain Platform Debugger you can do everything from one screen and without exiting the current debug session. Click the blue IBM Blockchain Platform button in the debug toolbar to reveal the debug command list. 7. Select Upgrade Smart Contract from the list of options: 8. You will be asked what function you want to invoke, type in instantiate : 9. Then you will see another pop-up asking what arguments to pass to the function. You will just hit Enter here: 10. Lastly, you will be asked if you want to provide a private data collection configuration file. Again, just hit Enter here: 11. Finally, upon successful instantiation, you will see a message in the lower right corner saying Successfully upgraded smart contract . 12. Re-start your debug session to pick up the update. Hit Stop in the debug toolbar: 13. Now, click on either the green arrow button in the DEBUG toolbar or click on the blue bar at the bottom of VSCode that says Launch Smart Contract (cp-magnetocorp-contract-javascript) : And you will see the debug tool bar with the blue IBM Blockchain Platform logo launched at the top. The bar at the bottom turns orange to indicate that you are currently in a debug session. 14. Return to papercontract.js , and place a new breakpoint on the following line, which is the first uncommented line in the issue function: let assignPaperRate = await ctx.stub.invokeChaincode(\"commercial-bond\", [\"getClosestBondRate\", issuer, maturityDateTime], ctx.stub.getChannelID()); 15. Let's click on the IBM Blockchain Platform button in the debug toolbar: 16. Select Submit Transaction in the pop-up window: 17. Select the issue transaction in the pop-up window: 18. For the arguments pop-up, pass the following arguments inside the brackets: \"MagnetoCorp\", \"00004\", \"2020-01-31\", \"2020-04-30\", \"1000000\",\"0.03\" 19. In the transient data pop-up, hit Enter to skip this step and move forward: 20. And the debugger should stop at the breakpoint. 21. Add the variable newPaperRate to the Watch list. In the Variables panel, scroll down until you see the newPaperRate variable. Ctl + Click on newPaperRate and select Add to Watch , then press Enter for the variable to get added to the Watch panel: 22. Now find the variable paper in the Variables panel, and add that to the Watch panel as well: 23. Use the debug toolbar to Step over (or press F10) each line of code until you reach paper.setIssued() . Notice how the newPaperRate variable got set to the bond rate of bondNumber 00001 which is 0.05 (see Section 2 step 6). And the paper variable in the Watch panel has an interestRate of 0.05 (vs the 0.03 that was passed through the issue transaction): 24. Then you can hit Continue in the debug toolbar to complete the transaction. 25. You should see the following in the OUTPUT below upon a successful submission. 26. Click on the DEBUG CONSOLE view at the bottom of VSCode and see the console.log messages from submitting the new issue transaction. 27. Take a closer look at the OUTPUT from step 20, and you will see a line that says [INFO] submitting transaction issue with args MagnetoCorp,00004,2020-01-31,2020-04-30,1000000,0.03 . To double check that the paper we just submitted, MagnetoCorp:00004 indeed has been set with a rate of 0.05, instead of the 0.03 passed through the issue transaction, let's add a helper function called getPaperRate in section 8.","title":"Section 7: Make smart contract updates to include cross-chaincode call, test in debugging session"},{"location":"xchaincode/#section-8-add-a-helper-function-to-the-paper-contract-test-in-debugging-session","text":"1. Go back to papercontract.js . Add the following code block right after the instantiate function: /** * Get paper rate for specified paper * @param {Context} ctx the transaction context * @param {String} issuer commercial paper issuer * @param {Integer} paperNumber paper number for this issuer */ async getPaperRate(ctx, issuer, paperNumber) { try { console.log( getPaper for: + issuer + + paperNumber); let paperKey = CommercialPaper.makeKey([issuer, paperNumber]); let paper = await ctx.paperList.getPaper(paperKey); console.log( paper rate for: + issuer + + paperNumber + is + paper.paperRate); return paper.paperRate; } catch (e) { throw new Error('Paper does not exist: ' + issuer + paperNumber); } } Save this file with Command + S if you are on Mac, or Ctl + S if you are on Linux or Windows. Your papercontract.js should look like the following: 2. Now that you have updated the smart contract again, you will need to deploy this new one to the local running peer. Follow the steps in Section 7: steps 6 - 13. 3. Let's evaluate a getPaperRate transaction. Let's click on the IBM Blockchain Platform button in the debug toolbar: 4. Now select Evaluate Transaction from the list: 5. In the next pop-up window, you will see the new transaction getPaperRate that you just added. Select it: 6. In the next pop-up, enter the following as arguments inside the brackets: \"MagnetoCorp\",\"00004\" 7. For the next pop-up you will be asked for transient data for this transaction. Just hit Enter here: 8. Upon success you will see the following output, which confirms that the paper submitted in Section 7 did indeed take the bond rate of 0.05: 9. If you have time, evaluate another issue transaction. This time pass a maturity date that you know does not have a match in commercial-bond . You can always go back to Section 2 step 6 to see which bonds are in the commercial-bond world state, and pick a maturity date for your paper that is not in the same month as the bonds. Step through the debugger with variables added to the Watch panel, and see if the logic behaves the way you expect. 10. Go to the VSCode IBM Blockchain Platform view. Under the Local Fabric Ops panel, you should see three papercontract@vscode-debug- datetime packages under Installed and one papercontract@vscode-debug- datetime under Instantiated . The instantiated package should have the same datetime as the latest installed one. The first papercontract@vscode-debug package was done against the original paper contract, the second package was done against the paper contract with the modified issue transaction, and the third package was built upon the second with a new getPaperRate function. 11. At this point you have successfully tweaked the papercontract.js to include a cross-chaincode call to another contract residing in the same channel. You have also added a helper function to get a paper rate on an existing paper on the ledger. One last useful transaction to have is one that queries and returns all papers by the same issuer. Let's make this update in the next section.","title":"Section 8: Add a helper function to the paper contract, test in debugging session"},{"location":"xchaincode/#section-9-add-getallpapers-transaction-to-contract-in-debugging-session","text":"1. Return to your papercontract.js and paste in the following code block right after the getPaperRate() function: /** * Get all the commercial papers from issuer * @param {Context} ctx the transaction context * @param {String} paperIssuer the organization that issued the paper */ async getAllPapersFromIssuer(ctx, paperIssuer) { //following is required to setup the key in the proper format that getStateByPartialCompositeKey expects var paperKey = CommercialPaper.makeKey([paperIssuer]); var org = CommercialPaper.splitKey(paperKey); var iterator = await ctx.stub.getStateByPartialCompositeKey( org.papernet.commercialpaperlist , org); const allResults = []; while (true) { const res = await iterator.next(); if (res.value res.value.value.toString()) { console.log(res.value.value.toString('utf8')); const Key = res.value.key; let Record; try { Record = JSON.parse(res.value.value.toString('utf8')); } catch (err) { console.log(err); Record = res.value.value.toString('utf8'); } allResults.push({ Key, Record }); } if (res.done) { console.log('end of data'); await iterator.close(); console.info(allResults); return JSON.stringify(allResults); } } } This getAllPapersFromIssuer() function takes one argument, the name of the paper issuer you want to query. In our example so far, we have only used MagnetoCorp , so that is the string that would be passed as an argument to this transaction at this point. You should have noticed by now that this lab uses function and transaction interchangeably. They really mean the same thing in this lab, where one Node.js function invokes one smart contract transaction. You may also have noticed that in every papercontract.js function, the first argument is ctx . However, when we actually submit or evaluate that transaction, we don't pass anything to represent the ctx argument. In the new Fabric programming model, ctx represents the current transaction context. It gets passed automatically when the transaction is invoked. In the above function, the first thing we do is construct a partial composite key in the format that the API getStateByPartialCompositeKey() requires. A composite key is a key that is made up of two or more parts. In a smart contract you need to define assets with keys that distinguish them. You can have simple keys, meaning one unique key represents one asset. You can also have composite keys, meaning the asset is represented by the combination of multiple unique values. In the case of our commercial-paper and commercial-bond , their composite key is issuer : unique number . This means MagnetoCorp can have a paper with the number 00001, and Digibank can also have a paper with number 00001, and on the ledger they would be viewed as two separate assets. So in essence what we are constructing is a partial composite key that represents part of the whole key. What this allows us to do is use the getStateByPartialCompositeKey() API to get all the assets that match that partial composite key. getStateByPartialCompositeKey() returns an iterator object that you can then use to iterate through all the assets that match the partial composite key. For the complete spec on getStateByPartialCompositeKey() see here . In the while loop in the above function, we iterate through the assets and capture the attributes of each paper and add them to an array. And then the papers are returned in JSON format. 2. Now save the modified papercontract.js and use Section 7, steps 6 - 13 , to upgrade the smart contract from your current debug session. 3. Within a few seconds, you should see the debug toolbar appear at the top. Click on the blue IBM Blockchain Platform button: 4. Let's evaluate a transaction with the newly added getAllPapersFromIssuer transaction. First, select Evaluate Transaction : 5. Select the new transanction getAllPapersFromIssuer from the list: 6. Type in \"MagnetoCorp\" inside the brackets for the arguments window: 7. Next, it will ask you what transient data to pass for the transaction. Press Enter to move forward. 8. Upon successful evaluation, you will see the following message in the lower right corner: 9. You will also see all the papers issued by MagnetoCorp in the OUTPUT panel (In the following screenshot you will see three papers. But in your output you should only have two: MagnetoCorp:00004 and MagnetoCorp:00005 ): 10. Go to the VSCode IBM Blockchain Platform view, under the Local Fabric Ops panel, you should see four papercontract@vscode-debug- datetime packages under Installed and one papercontract@vscode-debug- datetime under Instantiated . The instantiated package should have the same datetime as the latest installed one. The latest instantiated package is from this section when we added the getAllPapersFromIssuer transaction. We hope that with this flow, you get to experience one way you can develop and build upon your smart contract.","title":"Section 9: Add getAllPapers transaction to contract in debugging session"},{"location":"xchaincode/#section-10-package-commercial-paper-install-and-instantiate","text":"Now that you are done updating the commercial-paper smart contract, you can exit out of the debug session, toggle off development mode on your peer, and package, install and upgrade to the completed smart contract. 1. Exit debug session by pressing Stop (or Ctl + F5 ) in the debug toolbar: 2. Now to go the IBM Blockchain Platform Extension view in VSCode, and toggle development mode off on peer0.org1.example.com : 3. Upon success, you will no longer see the infinity symbol next to peer0.org1.example.com and you will see the following message appear in the lower right corner: 4. Now we will manually package up commercial-paper . Go back to the VSCode Explorer perspective. In the workspace panel, select package.json in the cp-magnetocorp-contract-javascript folder to open it in the editor: 5. Change the package version to 0.0.2 as follows: Save the file with Command + S if you are on Mac, or Ctl + S if you are on Linux or Windows. 6. Open up the Command Palette (either by clicking on the gear icon to the lower left and selecting Command Palette or pressing Command + Shift + P if you are on a Mac and Ctl + Shift + P if you are on Linux). Select IBM Blockchain Platform: Package a Smart Contract Project : 7. Then select cp-magnetocorp-contract-javascript and press Enter . 8. Upon success, you will see the following message in the lower right corner: 9. Now you will install this chaincode to your local-fabric. Navigate to the IBM Blockchain Platform view in VSCode (the 6th button down from the left menu): 10. Under the Local Fabric Ops panel, click on + Install , then select papercontract@0.0.2 from the list: Upon success, you will see a message similar to the following in the lower right corner of VSCode: You will also see the package listed under Installed in the Local Fabric Ops panel: 11. Now you can upgrade the debug package to the papercontract@0.0.2 package. Select the existing debug papercontract package and Ctl + Click or right click and select Upgrade Smart Contract : 12. Select papercontract@0.0.2 from the list: 13. In the function box, enter instantiate as follows: Then you will see another pop-up asking what arguments to pass to the function. You will just hit Enter here: Lastly, you will be asked if you want to provide a private data collection configuration file. Again, just hit Enter here: 14. Upon successful upgrade you will see the following message in the lower right corner: You will aso see in the Local Fabric Ops panel, that papercontract@0.0.2 is listed under the Instantiated section: 15. Let's run a couple of quick tests to make sure the package looks good. In the Fabric Gateways panel, expand on the mychannel twistie to reveal the two chaincodes. Drill into the papercontract chaincode to reveal all the transactions. 16. Let's first submit an issue transaction. This time let's issue a paper as Digibank . Right click on issue and select Submit Transaction . 17. Then enter the following arguments inside the brackets to pass to issue : \"Digibank\",\"00001\",\"2020-01-31\",\"2020-05-31\",\"90000\",\"0.02\" For transient data, just press Enter : 18. Upon success, you will see the following in the OUTPUT panel: 19. Now we want to check that this paper actually has been issued with the rate of 0.04, which is the bond rate from bond Digibank:00001 (see Section 2 step 6). Again, if you recall, this is because paper Digibank:00001 has a maturity date in the same month as bond Digibank:00001 . Let's do this by submitting a getPaperRate transaction. From the Fabric Gateways panel, right click on getPaperRate and select Submit Transaction : 20. Then enter the following arguments inside the brackets to pass to getPaperRate : \"Digibank\",\"00001\" For transient data, just press Enter : 21. Upon success, you will see the following in the OUTPUT panel. And you will see that indeed, paper Digibank:00001 has been set with a paper rate of 0.04: 22. The last transaction we want to test is the getAllPapersFromIssuer . I will leave it to you to complete this test given the knowledge you now possess. 23. Leave the environment running for now. Congratulations! You are done with this part of the lab!","title":"Section 10: Package commercial-paper, install and instantiate"}]}